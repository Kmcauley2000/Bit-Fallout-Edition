<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Wasteland Outpost — Idle Settlement Builder</title>
  <style>
    :root{
      --adbar-h: 60px;
      --bg:#0b0f0c;
      --panel:#101a14;
      --panel2:#0d1511;
      --text:#d7f7da;
      --muted:#92c79b;
      --accent:#3cff7a;
      --warn:#ffcc66;
      --danger:#ff6b6b;
      --line:#1f3a2a;
      --shadow: 0 12px 30px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    *{ box-sizing:border-box; }
    html{
      -webkit-text-size-adjust: 100%;
      text-size-adjust: 100%;
      font-size: 18px;
    }
    @supports (font-size: clamp(16px, 2vw, 20px)) {
      html{ font-size: clamp(18px, 1.8vw + 10px, 22px); }
    }
    body{
      margin:0;
      background: radial-gradient(1200px 700px at 20% 0%, rgba(60,255,122,.10), transparent 55%),
                  radial-gradient(900px 600px at 95% 20%, rgba(255,204,102,.08), transparent 55%),
                  linear-gradient(180deg, #070a08, var(--bg));
      color:var(--text);
      font-family:var(--sans);
      min-height:100vh;
      padding-bottom: calc(92px + env(safe-area-inset-bottom));
    }

    /* Top HUD */
    header{
      padding: calc(18px + env(safe-area-inset-top)) 16px 10px;
      position:sticky;
      top:0;
      background: linear-gradient(180deg, rgba(11,15,12,.92), rgba(11,15,12,.65));
      backdrop-filter: blur(6px);
      border-bottom:1px solid rgba(31,58,42,.7);
      z-index:10;
    }
    .toprow{
      display:flex;
      gap:12px;
      align-items:flex-end;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .title{
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .title h1{
      margin:0;
      font-family:var(--mono);
      letter-spacing:.5px;
      font-size: 1.15rem;
      color:var(--accent);
      text-shadow: 0 0 14px rgba(60,255,122,.18);
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      font-size:0.78rem;
      line-height:1.35;
    }
    .pillbar{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .pill{
      border:1px solid rgba(31,58,42,.9);
      background: linear-gradient(180deg, rgba(16,26,20,.85), rgba(13,21,17,.85));
      border-radius:999px;
      padding:10px 12px;
      box-shadow: var(--shadow);
      font-family:var(--mono);
      font-size:0.78rem;
      color:var(--text);
      display:flex;
      gap:8px;
      align-items:center;
      white-space:nowrap;
    }
    .pill b{ color:var(--accent); font-weight:700; }

    /* Layout */
    .wrap{
      padding: 16px 16px calc(96px + var(--adbar-h) + env(safe-area-inset-bottom));
      max-width:900px;
      margin:0 auto;
      display:flex;
      flex-direction:column;
      gap:14px;
    }

    /* Cards */
    .card{
      background: linear-gradient(180deg, rgba(16,26,20,.92), rgba(13,21,17,.92));
      border:1px solid rgba(31,58,42,.9);
      border-radius:var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .cardHeader{
      padding: 16px 16px 10px;
      border-bottom:1px solid rgba(31,58,42,.45);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .cardHeader h2{
      margin:0;
      font-family:var(--mono);
      font-size:0.9rem;
      letter-spacing:.4px;
      color:var(--text);
    }
    .cardBody{ padding: 12px 16px 16px; }

    /* Buttons & rows */
    .grid{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:12px;
    }
    @media (max-width: 520px){
      .grid{ grid-template-columns:1fr; }
      .pillbar{ justify-content:flex-start; }
    }
    .btn{
      -webkit-tap-highlight-color: transparent;
      border:1px solid rgba(60,255,122,.35);
      background: linear-gradient(180deg, rgba(60,255,122,.18), rgba(60,255,122,.06));
      color:var(--text);
      border-radius:16px;
      padding:14px 14px;
      font-family:var(--mono);
      cursor:pointer;
      box-shadow: 0 10px 24px rgba(0,0,0,.22);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      transition: transform .08s ease, border-color .2s ease, background .2s ease;
      user-select:none;
      min-height:64px;
      touch-action: manipulation;
      width:100%;
      text-align:left;
    }
    .btn:active{ transform: translateY(1px) scale(.99); }
    .btn[disabled]{ opacity:.55; cursor:not-allowed; transform:none; }
    .btn small{
      color:var(--muted);
      font-size:0.78rem;
      font-family:var(--sans);
      line-height:1.15;
      text-align:right;
      white-space:normal;
      max-width:44%;
    }
    .btn .left{ display:flex; flex-direction:column; gap:4px; }
    .btn .name{ font-size:0.95rem; color:var(--accent); }
    .btn .desc{ font-family:var(--sans); font-size:0.85rem; line-height:1.25; color:var(--text); opacity:.92; }

    .rows{ display:flex; flex-direction:column; gap:10px; }

    .sectionTitle{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding: 10px 2px 2px;
      font-family:var(--mono);
      font-size:0.72rem;
      letter-spacing:.7px;
      color: var(--muted);
      text-transform:uppercase;
      opacity:.95;
    }
    .sectionTitle .tag{ font-size:0.68rem; padding:3px 9px; }

    /* Lightweight section headers inside panels */
    .section{
      padding: 10px 14px;
      border-radius:16px;
      border:1px solid rgba(31,58,42,55);
      background: linear-gradient(180deg, rgba(9,14,11,70), rgba(7,11,9,70));
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .section .t{
      font-family:var(--mono);
      color:var(--accent);
      font-size:0.85rem;
      letter-spacing:.35px;
    }
    .section .s{
      font-family:var(--sans);
      color:var(--muted);
      font-size:0.8rem;
      opacity:.95;
    }
    .row{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      padding:12px 14px;
      border-radius:16px;
      border:1px solid rgba(31,58,42,.85);
      background: linear-gradient(180deg, rgba(13,21,17,.85), rgba(10,16,13,.85));
      font-family:var(--mono);
      font-size:0.8rem;
      line-height:1.25;
    }
    .row .label{ color:var(--muted); }
    .row .value{ color:var(--text); }
    .tag{
      font-family:var(--mono);
      font-size:0.72rem;
      padding:4px 10px;
      border-radius:999px;
      border:1px solid rgba(31,58,42,.9);
      color:var(--muted);
      background: rgba(0,0,0,.15);
    }
    .divider{ height:1px; background: rgba(31,58,42,.8); margin:14px 0; }

    /* Log */
    .log{
      max-height:380px;
      overflow:auto;
      border-radius:16px;
      border:1px solid rgba(31,58,42,.85);
      background: linear-gradient(180deg, rgba(10,16,13,.78), rgba(7,10,8,.78));
      padding:12px;
      font-family:var(--mono);
      font-size:0.78rem;
      line-height:1.45;
      -webkit-overflow-scrolling: touch;
    }
    .log p{ margin:0 0 10px; color:var(--text); }
    .log p span{ color:var(--muted); }

    /* Bottom tab bar */
    .tabbar{
      position:fixed;
      left:0; right:0; bottom:var(--adbar-h);
      padding: 10px 12px calc(10px + env(safe-area-inset-bottom));
      background: linear-gradient(180deg, rgba(11,15,12,.0), rgba(11,15,12,.92) 40%, rgba(11,15,12,.98));
      border-top:1px solid rgba(31,58,42,.75);
      display:flex;
      flex-wrap:nowrap;
      overflow-x:auto;
      overflow-y:hidden;
      justify-content:flex-start;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior-x: contain;
      gap:10px;
      justify-content:center;
      z-index:12;
      backdrop-filter: blur(6px);
    }
    .tabbar::-webkit-scrollbar{ display:none; }
    .tabbar{ scrollbar-width:none; }

    .tab{
      border:1px solid rgba(31,58,42,.85);
      background: linear-gradient(180deg, rgba(16,26,20,.9), rgba(13,21,17,.9));
      border-radius:16px;
      padding:12px 12px;
      flex: 0 0 auto;
      white-space: nowrap;
      font-family:var(--mono);
      color:var(--text);
      cursor:pointer;
      font-size:0.82rem;
      min-height:48px;
      touch-action: manipulation;
      display:flex;
      align-items:center;
      gap:8px;
    }
    .tab.active{
      border-color: rgba(60,255,122,.55);
      box-shadow: 0 0 0 1px rgba(60,255,122,.12), 0 10px 24px rgba(0,0,0,.24);
    }
    .tab .dot{
      width:8px; height:8px; border-radius:999px;
      background: rgba(146,199,155,.65);
    }
    .tab.active .dot{ background: var(--accent); }

    /* Screens */
    .screen{ display:none; }
    .screen.active{ display:block; }

    /* Factions */
    .bar{
      height:12px;
      border-radius:999px;
      border:1px solid rgba(31,58,42,.85);
      background: rgba(0,0,0,.25);
      overflow:hidden;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
    }
    .barFill{
      height:100%;
      width:0%;
      background: linear-gradient(90deg, rgba(60,255,122,.15), rgba(60,255,122,.9));
    }
    .factionMeta{
      display:flex;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      margin-top:10px;
    }
    .miniBtns{ display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; }
    .miniBtn{
      border:1px solid rgba(31,58,42,.85);
      background: rgba(0,0,0,.16);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      cursor:pointer;
      font-family:var(--mono);
      font-size:0.78rem;
      min-height:44px;
      touch-action: manipulation;
    }
    .miniBtn.primary{
      border-color: rgba(60,255,122,.45);
      background: linear-gradient(180deg, rgba(60,255,122,.16), rgba(60,255,122,.06));
    }
    .miniBtn.danger{
      border-color: rgba(255,107,107,.55);
    }
    .miniBtn[disabled]{ opacity:.55; cursor:not-allowed; }

    .chip{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(31,58,42,.85);
      background: rgba(0,0,0,.18);
      font-family:var(--mono);
      font-size:0.72rem;
      color:var(--text);
      white-space:nowrap;
    }
    .chip.good{ border-color: rgba(60,255,122,.45); }
    .chip.warn{ border-color: rgba(255,204,102,.55); color: var(--warn); }
    .chip.danger{ border-color: rgba(255,107,107,.55); color: var(--danger); }
    .pulse{
      animation:pulseGlow 1.2s ease-in-out infinite;
    }
    @keyframes pulseGlow{
      0%,100%{ box-shadow: 0 0 0 rgba(60,255,122,.0); }
      50%{ box-shadow: 0 0 18px rgba(60,255,122,.18); }
    }
    .bar.small{ height:8px; }

    /* Modal */
    dialog{
      width:min(720px, calc(100vw - 24px));
      border:none;
      border-radius:22px;
      background: linear-gradient(180deg, rgba(16,26,20,.98), rgba(10,16,13,.98));
      color:var(--text);
      box-shadow: 0 20px 60px rgba(0,0,0,.55);
      border:1px solid rgba(31,58,42,.9);
      padding:0;
      max-height: 92vh;
      overflow: hidden;
    }
    dialog::backdrop{ background: rgba(0,0,0,.55); backdrop-filter: blur(2px); }
    .modalHeader{
      padding:14px 14px 10px;
      border-bottom:1px solid rgba(31,58,42,.8);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .modalHeader h3{ margin:0; font-family:var(--mono); font-size:0.95rem; color:var(--accent); }
    .modalBody{padding:12px 14px 14px;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      max-height: calc(92vh - 56px);
    }

    /* Mobile menu usability */
    .modalBody .rows{ overflow: visible; }
    .modalBody .btn{ min-height:48px; }
    .modalHeader{ position: sticky; top: 0; z-index: 5; background: linear-gradient(180deg, rgba(16,26,20,.98), rgba(10,16,13,.98)); }
    .modalBody p{ margin:0 0 10px; color:var(--text); opacity:.92; font-size:0.88rem; line-height:1.35; }
    .closeBtn{
      border:1px solid rgba(31,58,42,.85);
      background: rgba(0,0,0,.18);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      cursor:pointer;
      font-family:var(--mono);
      font-size:0.8rem;
      touch-action: manipulation;
      min-height:44px;
      min-width:44px;
    }

    /* Large, thumb-friendly +/- buttons (used for unit steppers) */
    .stepBtn{
      min-width:54px;
      min-height:54px;
      padding:0;
      border-radius:16px;
      font-size:1.05rem;
      line-height:1;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      user-select:none;
      -webkit-user-select:none;
      transition: transform .08s ease, filter .18s ease, border-color .18s ease;
    }
    .stepBtn:active{ transform: translateY(1px) scale(.98); }

    /* Subtle transitions for CivCrafter-style panels */
    .animIn{ animation: animIn .18s ease-out both; }
    @keyframes animIn{
      from{ opacity:0; transform: translateY(6px); }
      to{ opacity:1; transform: translateY(0); }
    }

    dialog[open]{
      animation: modalIn .18s ease-out both;
    }
    @keyframes modalIn{
      from{ opacity:0; transform: translateY(10px) scale(.985); }
      to{ opacity:1; transform: translateY(0) scale(1); }
    }
    .kbd{
      font-family:var(--mono);
      padding:2px 8px;
      border-radius:10px;
      border:1px solid rgba(31,58,42,.85);
      background: rgba(0,0,0,.2);
      color:var(--muted);
      font-size:0.75rem;
    }
  
    /* --- Factions: clearer button hierarchy + hard-lock UI --- */
    .fActions{ margin-top:10px; display:flex; flex-direction:column; gap:10px; }
    .fbtn{
      width:100%;
      min-height:54px;
      border-radius:14px;
      padding:12px 14px;
      font-family:var(--mono);
      color: var(--text);
      font-weight: 900;
      text-transform: uppercase;
      letter-spacing: .7px;
      -webkit-appearance: none;
      appearance: none;
      touch-action:manipulation;
      border:1px solid rgba(44, 112, 68, .55);
      background:linear-gradient(180deg, rgba(8,16,12,.9), rgba(6,10,8,.92));
      box-shadow: 0 10px 24px rgba(0,0,0,.28);
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      cursor:pointer;
    }
    .fbtnPrimary{
      border-color: rgba(60,255,122,.65);
      background: linear-gradient(180deg, rgba(60,255,122,.22), rgba(60,255,122,.08));
      box-shadow: 0 0 0 1px rgba(60,255,122,.18), 0 12px 30px rgba(0,0,0,.34);
    }
    .fbtnDanger{
      border-color: rgba(255,107,107,.65);
      background: linear-gradient(180deg, rgba(255,107,107,.20), rgba(255,107,107,.06));
      box-shadow: 0 0 0 1px rgba(255,107,107,.16), 0 12px 30px rgba(0,0,0,.34);
    }
    .fbtnSecondary{
      min-height:48px;
      border-color: rgba(31,58,42,.95);
      color: var(--muted);
      font-weight: 800;
      background: linear-gradient(180deg, rgba(16,26,20,.78), rgba(13,21,17,.78));
      opacity: .98;
      box-shadow:none;
    }
    .actionRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
    }
    /* In the 3-button row we want a clear horizontal hierarchy, not full-width stacked buttons */
    .actionRow .fbtn{ width:auto; }
    .actionRow > .fbtn{ flex: 1 1 120px; }
    .fbtn[disabled]{
      opacity:.42;
      filter:saturate(.6);
      cursor:not-allowed;
    }

    /* Make it obvious these are clickable (iOS needs this sometimes) */
    .fbtn:active{ transform: translateY(1px) scale(.99); }
    .lockHint{
      margin-top:-2px;
      font-family:var(--mono);
      font-size:.72rem;
      color:var(--warn);
      opacity:.95;
    }


/* --- Factions 2.0: clean mobile list + detail card --- */
.bar.mini{ height:8px; opacity:.95; }
.fList{
  display:flex;
  flex-direction:column;
  gap:10px;
  margin-top:6px;
}
.fPick{
  width:100%;
  text-align:left;
  border-radius:16px;
  padding:12px 12px 10px;
  border:1px solid rgba(31,58,42,.85);
  background: rgba(0,0,0,.14);
  color:var(--text);
  cursor:pointer;
  touch-action:manipulation;
}
.fPick.on{
  border-color: rgba(60,255,122,.55);
  background: linear-gradient(180deg, rgba(60,255,122,.10), rgba(0,0,0,.10));
  box-shadow: 0 0 0 1px rgba(60,255,122,.12);
}
.fPickTop{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  margin-bottom:8px;
  flex-wrap:wrap;
}
.fPickName{
  font-family:var(--mono);
  color:var(--accent);
  font-size:.9rem;
  min-width: 0;
  flex: 1 1 auto;
}
.fDetail{
  margin-top:12px;
  padding:12px;
  border-radius:20px;
  border:1px solid rgba(31,58,42,.9);
  background: linear-gradient(180deg, rgba(16,26,20,.55), rgba(10,16,13,.55));
  box-shadow: 0 12px 28px rgba(0,0,0,.28);
}
.fActions2{
  display:flex;
  flex-direction:column;
  gap:12px;
  margin-top:12px;
}
.fSmall{ display:flex; flex-direction:column; gap:8px; }
.fbtn2{
  width:100%;
  min-height:54px;
  border-radius:16px;
  padding:12px 14px;
  font-family:var(--mono);
  color:var(--text);
  font-weight:900;
  letter-spacing:.6px;
  text-transform:uppercase;
  border:1px solid rgba(44,112,68,.55);
  background:linear-gradient(180deg, rgba(8,16,12,.9), rgba(6,10,8,.92));
  box-shadow: 0 10px 24px rgba(0,0,0,.28);
  cursor:pointer;
  touch-action:manipulation;
}
.fbtn2.primary{
  border-color: rgba(60,255,122,.65);
  background: linear-gradient(180deg, rgba(60,255,122,.22), rgba(60,255,122,.08));
  box-shadow: 0 0 0 1px rgba(60,255,122,.18), 0 12px 30px rgba(0,0,0,.34);
}
.fbtn2.secondary{
  min-height:48px;
  border-color: rgba(31,58,42,.95);
  color: var(--muted);
  font-weight: 800;
  text-transform:none;
  letter-spacing: 0;
  background: linear-gradient(180deg, rgba(16,26,20,.78), rgba(13,21,17,.78));
  box-shadow:none;
}
.fbtn2.danger{
  border-color: rgba(255,107,107,.65);
  background: linear-gradient(180deg, rgba(255,107,107,.20), rgba(255,107,107,.06));
  box-shadow: 0 0 0 1px rgba(255,107,107,.16), 0 12px 30px rgba(0,0,0,.34);
}
.fbtn2[disabled]{ opacity:.42; filter:saturate(.6); cursor:not-allowed; }
.fPick:active, .fbtn2:active{ transform: translateY(1px) scale(.99); }

/* --- Redesigned Faction cards --- */
.facCard{
  border-radius:20px;
  border:1px solid rgba(31,58,42,.85);
  background: linear-gradient(180deg, rgba(16,26,20,.55), rgba(10,16,13,.55));
  box-shadow: 0 12px 28px rgba(0,0,0,.28);
  padding:16px;
  margin-bottom:16px;
}
.facHead{
  display:flex;
  align-items:center;
  flex-wrap:wrap;
  gap:8px;
  font-family:var(--mono);
  font-size:0.92rem;
  color:var(--accent);
  margin-bottom:6px;
}
.facHead .tag{
  padding:2px 6px;
  border-radius:8px;
  background: rgba(60,255,122,.12);
  color: var(--accent);
  font-size:0.72rem;
}
.bar.mini{
  width:100%;
  height:6px;
  border-radius:4px;
  background: rgba(31,58,42,.55);
  margin:4px 0;
  overflow:hidden;
}
.bar.mini .barFill{
  height:100%;
  border-radius:4px;
  background: linear-gradient(90deg, rgba(60,255,122,.50), rgba(60,255,122,.18));
}
.facSub{
  display:flex;
  flex-wrap:wrap;
  gap:6px;
  margin:4px 0;
}
.facSub .tag{
  padding:2px 4px;
  border-radius:6px;
  background: rgba(31,58,42,.6);
  color: var(--muted);
  font-size:0.68rem;
  white-space:nowrap;
}
.facDesc{
  font-family: var(--sans);
  font-size:0.80rem;
  color: var(--muted);
  margin-top:4px;
}
.facNext{
  font-family: var(--mono);
  font-size:0.76rem;
  color: var(--accent);
  margin-top:4px;
}
.facActions{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  margin-top:10px;
}
.facActions .fbtn2{
  flex:1 1 100%;
  font-size:0.76rem;
  letter-spacing:0.5px;
  text-transform:uppercase;
  color: var(--accent);
  border-color: rgba(60,255,122,.55);
  background: linear-gradient(180deg, rgba(60,255,122,.12), rgba(60,255,122,.04));
}
.facActions .miniRow{
  display:flex;
  flex-wrap:wrap;
  gap:6px;
  margin-top:8px;
}
.facActions .miniRow .miniBtn{
  flex:1 1 calc(33% - 4px);
}
.lockHint{
  font-family: var(--sans);
  font-size:0.68rem;
  color: var(--muted);
  margin-top:6px;
}

  
    /* ---------- Tap feedback ---------- */
    .btn.tapFlash, .fbtn.tapFlash, .miniBtn.tapFlash, .closeBtn.tapFlash, .tab.tapFlash{
      transform: translateY(1px) scale(.99);
      filter: brightness(1.08);
    }

    /* Tap overdrive: button goes "on fire" after a combo */
    .btn.onFire{
      border-color: rgba(255, 184, 77, .75) !important;
      box-shadow: 0 0 0 1px rgba(255,184,77,.25), 0 10px 30px rgba(255,120,40,.12);
      filter: brightness(1.12) saturate(1.05);
      position: relative;
      overflow: hidden;
    }
    .btn.onFire::after{
      content: "";
      position:absolute;
      inset:-40% -20% auto -20%;
      height: 120%;
      background: radial-gradient(circle at 50% 85%, rgba(255,184,77,.25), rgba(255,120,40,.10), rgba(0,0,0,0) 70%);
      animation: fireWobble 750ms ease-in-out infinite;
      pointer-events:none;
      mix-blend-mode: screen;
    }
    @keyframes fireWobble{
      0%{ transform: translateY(0) scale(1.0) rotate(-1deg); opacity:.75; }
      50%{ transform: translateY(-6px) scale(1.03) rotate(1deg); opacity:.95; }
      100%{ transform: translateY(0) scale(1.0) rotate(-1deg); opacity:.75; }
    }

    /* Floating gain text */
    .popGain{
      position: fixed;
      z-index: 9999;
      pointer-events: none;
      font-family: var(--mono);
      font-size: .88rem;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      opacity: 0;
      transform: translate(-50%, 0) scale(.96);
      animation: popFly 820ms ease-out forwards;
    }
    .popGain.good{ border-color: rgba(42,214,148,.35); }
    .popGain.warn{ border-color: rgba(255,204,102,.35); }
    .popGain.danger{ border-color: rgba(255,107,107,.35); }

    @keyframes popFly{
      0%   { opacity: 0; transform: translate(-50%, 10px) scale(.96); }
      20%  { opacity: 1; }
      100% { opacity: 0; transform: translate(-50%, -36px) scale(1.02); }
    }

    /* Toasts */
    #toastHost{
      position: fixed;
      left: 50%;
      bottom: 76px;
      transform: translateX(-50%);
      width: min(520px, calc(100vw - 24px));
      z-index: 10000;
      display: flex;
      flex-direction: column;
      gap: 10px;
      pointer-events: none;
    }
    .toast{
      pointer-events: none;
      font-family: var(--sans);
      font-size: .92rem;
      line-height: 1.25;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(15,18,22,.88);
      border: 1px solid rgba(255,255,255,.12);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      opacity: 0;
      transform: translateY(8px);
      animation: toastIn 180ms ease-out forwards, toastOut 220ms ease-in forwards;
      animation-delay: 0ms, var(--toastLife, 1800ms);
    }
    .toast.good{ border-color: rgba(42,214,148,.35); }
    .toast.warn{ border-color: rgba(255,204,102,.35); }
    .toast.danger{ border-color: rgba(255,107,107,.35); }

    @keyframes toastIn{
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes toastOut{
      to { opacity: 0; transform: translateY(8px); }
    }

  
    /* Battle ops */
    .barOuter{
      width:100%;
      height:12px;
      border-radius:999px;
      border:1px solid rgba(31,58,42,.9);
      background: linear-gradient(180deg, rgba(10,16,13,.9), rgba(7,10,8,.9));
      overflow:hidden;
    }
    .barInner{
      height:100%;
      width:0%;
      background: linear-gradient(90deg, rgba(60,255,122,.9), rgba(255,204,102,.55));
      box-shadow: 0 0 18px rgba(60,255,122,.18);
      border-radius:999px;
      transition: width .25s ease;
    }
    .miniHint{ color: var(--muted); font-family: var(--sans); font-size: .82rem; line-height:1.3; }

    /* --- Battle (CivCrafter-style) --- */
    .bSectionTitle{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      margin: 2px 0 8px;
      font-family: var(--mono);
      color: var(--muted);
      letter-spacing: .08em;
      text-transform: uppercase;
      font-size: .72rem;
    }
    .bPills{ display:flex; flex-wrap:wrap; gap:8px; }
    .bPills .chip{ font-size:.74rem; }
    .bScroll{
      display:flex; gap:10px;
      overflow-x:auto;
      padding-bottom:4px;
      -webkit-overflow-scrolling: touch;
      scroll-snap-type:x mandatory;
    }
    .bScroll > button{ scroll-snap-align:start; }
    .bPathBtn{
      min-width: 220px;
      border-radius: 16px;
      padding: 12px 12px;
    }
    .bPathBtn .name{ font-size:.92rem; }
    .bTierBtn{
      border-radius: 16px;
      padding: 12px 12px;
    }
    .bTierTop{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .bTierBadge{
      font-family: var(--mono);
      font-weight: 900;
      letter-spacing: .08em;
      padding: 6px 10px;
      border-radius: 999px;
      border:1px solid rgba(31,58,42,.85);
      background: rgba(0,0,0,.20);
      color: var(--accent);
      white-space:nowrap;
    }
    .bTierMeta{ display:flex; flex-wrap:wrap; gap:8px; margin-top:8px; }
    .bTierMeta .chip{ padding:6px 10px; }
    .bDeployGrid{
      display:flex; flex-direction:column; gap:10px;
    }
    .bStepper{ display:flex; align-items:center; justify-content:space-between; gap:12px; }
    .bStepper .left{ min-width:0; }
    .bStepper .right{ display:flex; gap:10px; align-items:center; }
    .bStepper .count{ min-width:64px; text-align:center; }

    /* --- Battle Paths: clearer stat chips + sim overlay --- */
    .statLine{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; justify-content:flex-end; }
    .statChip{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(31,58,42,75);
      background: rgba(0,0,0,18);
      font-family: var(--mono);
      font-size: 0.78rem;
      color: var(--text);
      white-space: nowrap;
    }
    .statChip b{ font-weight: 900; letter-spacing: .04em; }
    .simBox{ display:flex; flex-direction:column; gap:12px; }
    .simHeader{ display:flex; justify-content:space-between; gap:12px; align-items:flex-start; }
    .simHeader .title{ font-family: var(--mono); font-weight: 900; letter-spacing: .08em; text-transform: uppercase; }
    .simSub{ color: var(--muted); font-size:.86rem; line-height:1.35; }
    .simAnimRow{ display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap; }
    .pipWrap{ display:flex; gap:8px; align-items:center; }
    .pip{
      width:10px; height:10px;
      border-radius:999px;
      border:1px solid rgba(31,58,42,75);
      background: rgba(0,0,0,20);
      opacity:.55;
      animation: pipPulse 1.1s infinite;
    }
    .pip:nth-child(2){ animation-delay: .12s; }
    .pip:nth-child(3){ animation-delay: .24s; }
    .pip:nth-child(4){ animation-delay: .36s; }
    @keyframes pipPulse{ 0%,100%{ transform: scale(1); opacity:.45; } 50%{ transform: scale(1.35); opacity:1; } }
    .simLog{
      border:1px solid rgba(31,58,42,65);
      background: rgba(0,0,0,16);
      border-radius:14px;
      padding:10px 12px;
      font-family: var(--mono);
      font-size: 0.78rem;
      color: rgba(219,255,232,92);
      max-height: 180px;
      overflow:auto;
      white-space: pre-wrap;
      line-height:1.35;
    }
    .simBarOuter{ width:100%; height:12px; border-radius:999px; border:1px solid rgba(31,58,42,.9); background: rgba(0,0,0,20); overflow:hidden; }
    .simBarInner{ height:100%; width:0%; border-radius:999px; background: linear-gradient(90deg, rgba(60,255,122,.85), rgba(255,204,102,.55)); box-shadow: 0 0 18px rgba(60,255,122,.18); transition: width .2s ease; }

  

    /* --- Mobile/ads-friendly layout helpers --- */
    .adtop{ position:sticky; top:0; z-index:11; }
    .adbar{
      position:fixed;
      left:0; right:0; bottom:0;
      height: calc(var(--adbar-h) + env(safe-area-inset-bottom));
      padding: 8px 12px calc(8px + env(safe-area-inset-bottom));
      background: rgba(11,15,12,.92);
      border-top:1px solid rgba(31,58,42,.65);
      display:flex;
      justify-content:center;
      align-items:center;
      z-index:13;
      backdrop-filter: blur(6px);
    }
    .ad-slot{
      width:min(100%, 480px);
      height: var(--adbar-h);
      border-radius: 14px;
      border:1px dashed rgba(182,255,204,.35);
      background: rgba(0,0,0,.18);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 12px;
      letter-spacing:.08em;
      text-transform: uppercase;
      color: rgba(219,255,232,.65);
      user-select:none;
      -webkit-user-select:none;
    }
    .ad-slot:empty::before{ content:"AD SPACE"; }
    .ad-slot.native{
      width:100%;
      height: 92px;
      margin: 10px 0 2px;
    }

    /* Mobile-first tweaks */
    @media (max-width: 640px){
      header .toprow{ gap:10px; }
      header .title h1{ font-size: 20px; letter-spacing:.12em; }
      .wrap{ max-width: 560px; padding-left:12px; padding-right:12px; }
      .btn{ padding: 14px 14px; }
      .tabbar{ gap:8px; padding-left:10px; padding-right:10px; }
      .tab{ min-width: 92px; }
    }

    /* Factions: inline expand/collapse inside each faction card (mobile-friendly) */
    .fCard{ border:1px solid rgba(31,58,42,.7); border-radius:16px; background: rgba(7,12,10,.55); overflow:hidden; }
    .fCard + .fCard{ margin-top: 10px; }
    .fPick{ width:100%; text-align:left; border:0; background: transparent; padding:12px; }
    .fPick.on{ background: rgba(34, 85, 58, .18); }
    .fInline{ display:none; padding: 0 12px 12px; }
    .fCard.expanded .fInline{ display:block; }
    .fInline .tag{ margin-right:6px; }
    .fInline .fActions2{ margin-top:10px; }
    .fInline .fbtn2{ width:100%; }



/* ===================== UI Overhaul Pass (Seamless + Cleaner) ===================== */
:root{
  --radius-xl: 18px;
  --radius-lg: 14px;
  --radius-md: 12px;
  --radius-sm: 10px;
  --shadow-soft: 0 10px 30px rgba(0,0,0,.28);
  --shadow-card: 0 10px 22px rgba(0,0,0,.22);
  --stroke: rgba(255,255,255,.08);
  --stroke2: rgba(255,255,255,.12);
  --panel: rgba(20,22,28,.78);
  --panel2: rgba(26,30,38,.82);
  --panel3: rgba(34,40,52,.86);
}

body{
  letter-spacing: .1px;
}

#app{
  max-width: 980px;
  margin: 0 auto;
}

.screen{
  animation: screenIn .14s ease-out;
}
@keyframes screenIn{
  from{ transform: translateY(6px); opacity: .0; }
  to{ transform: translateY(0); opacity: 1; }
}

/* Sections: unify spacing */
.section{
  background: var(--panel);
  border: 1px solid var(--stroke);
  border-radius: var(--radius-xl);
  box-shadow: var(--shadow-card);
  padding: 14px;
  margin: 12px 0;
  backdrop-filter: blur(8px);
}
.sectionHeader{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  padding: 2px 0 10px 0;
}
.sectionTitle{
  font-family: var(--mono);
  font-size: .92rem;
  color: var(--text);
  opacity: .92;
  letter-spacing: .4px;
  text-transform: uppercase;
}
.sectionHint{
  font-family: var(--sans);
  font-size: .82rem;
  color: var(--muted);
}

/* Buttons */
button, .btn, .fbtn2, .miniBtn, .tab{
  border-radius: var(--radius-lg) !important;
}
.btn, .fbtn2{
  border: 1px solid var(--stroke2);
  box-shadow: 0 8px 18px rgba(0,0,0,.18);
  transition: transform .08s ease, filter .08s ease, background .12s ease;
}
.btn:active, .fbtn2:active, .miniBtn:active{
  transform: translateY(1px) scale(.99);
}
.btn:hover, .fbtn2:hover, .miniBtn:hover{
  filter: brightness(1.04);
}

.miniBtn{
  border: 1px solid var(--stroke2);
  background: rgba(255,255,255,.06);
  padding: 8px 10px;
}

/* Tabs bar */
.tabs{
  background: rgba(12,14,18,.55);
  border: 1px solid var(--stroke);
  border-radius: var(--radius-xl);
  padding: 8px;
  gap: 8px;
  backdrop-filter: blur(10px);
}
.tab{
  border: 1px solid transparent;
  background: transparent;
}
.tab.on{
  background: rgba(255,255,255,.08);
  border-color: var(--stroke2);
  box-shadow: 0 6px 16px rgba(0,0,0,.18);
}

/* Pills */
.pillBar{
  gap: 8px;
}
.pill{
  border: 1px solid var(--stroke);
  border-radius: 999px;
  background: rgba(255,255,255,.05);
  padding: 7px 10px;
  box-shadow: 0 6px 16px rgba(0,0,0,.14);
}

/* Rows */
.row{
  border: 1px solid transparent;
  border-radius: var(--radius-lg);
  padding: 10px 12px;
}
.row:hover{
  background: rgba(255,255,255,.03);
  border-color: rgba(255,255,255,.06);
}
.row .label{
  font-family: var(--mono);
  letter-spacing: .4px;
}

/* Cards (factions) */
.fCard{
  border: 1px solid var(--stroke);
  background: var(--panel2);
  border-radius: var(--radius-xl);
  box-shadow: var(--shadow-card);
  overflow: hidden;
}
.fPick{
  border: 0 !important;
}
.fInline{
  background: rgba(0,0,0,.12);
  border-top: 1px solid rgba(255,255,255,.06);
}
.facDesc{
  color: var(--muted);
}

/* Modal polish */
#modalBackdrop{
  backdrop-filter: blur(8px);
}
#modal{
  border-radius: var(--radius-xl);
  border: 1px solid var(--stroke2);
  background: var(--panel3);
  box-shadow: var(--shadow-soft);
}
#modal h3{
  letter-spacing: .2px;
}
.divider{
  height: 1px;
  background: rgba(255,255,255,.08);
  margin: 10px 0;
}

/* Battle sim / outcome */
.statChips{
  display:flex;
  gap:8px;
  flex-wrap:wrap;
  align-items:center;
}
.chip{
  display:inline-flex;
  gap:6px;
  align-items:center;
  padding: 6px 10px;
  border-radius: 999px;
  border: 1px solid var(--stroke);
  background: rgba(255,255,255,.05);
  font-family: var(--mono);
  font-size: .82rem;
}
.chip b{ font-family: var(--mono); }

/* Reduce visual noise in long lists */
.listTight .row{ padding: 9px 12px; }
.listTight .row:hover{ background: rgba(255,255,255,.025); }

/* Tap button: clearer state */
#tapBtn.fire{
  box-shadow: 0 0 0 1px rgba(255,120,20,.25), 0 14px 26px rgba(255,120,20,.14);
}
</style>
</head>
<body>
  <header>
    <div class="toprow">
      <div class="title">
        <h1>WASTELAND OUTPOST</h1>
        <p class="subtitle">A Fallout‑inspired idle settlement builder (original).</p>
      </div>
      <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap; justify-content:flex-end;">
        <button class="closeBtn" id="btnPillsToggle" title="Toggle advanced resources">More</button>
        <div class="pillbar" id="topPills"></div>
      </div>
    </div>
  </header>


  <div class="adtop" id="adtop" aria-label="Advertisement">
    <div class="ad-slot banner" id="adBannerTop" data-ad-slot="banner-top"></div>
  </div>

  <main class="wrap">

    <!-- CLICKER / RESOURCES -->
    <section class="screen active" id="screen-clicker">
      <div class="card">
        <div class="cardHeader"><h2>Scavenge</h2><span class="tag">Tap & automate</span></div>
        <div class="cardBody">
          <div class="grid">
            <button class="btn" id="btnScavenge">
              <div class="left">
                <div class="name">Scavenge</div>
                <div class="desc">Tap for Scrap + Food (+ a chance of Tech)</div>
              </div>
              <small><span class="kbd">tap</span><br/>+ loot</small>
            </button>

            <button class="btn" id="btnPurify">
              <div class="left">
                <div class="name">Purify Water</div>
                <div class="desc">Convert Scrap into Clean Water</div>
              </div>
              <small id="purifyCost"></small>
            </button>

            <button class="btn" id="btnRecruit">
              <div class="left">
                <div class="name">Recruit Drifter</div>
                <div class="desc">Spend Food + Water to grow population</div>
              </div>
              <small id="recruitCost"></small>
            </button>

            
            <button class="btn" id="btnTrade">
              <div class="left">
                <div class="name">Trade Scrap</div>
                <div class="desc">Swap Scrap for Caps (early economy)</div>
              </div>
              <small id="tradeCost"></small>
            </button>

            <button class="btn" id="btnHealRad">
              <div class="left">
                <div class="name">Decontaminate</div>
                <div class="desc">Spend Water to reduce Radiation</div>
              </div>
              <small id="deconCost"></small>
            </button>
          </div>

          <div class="divider"></div>
          <div class="rows" id="workerPanel"></div>
        </div>
      </div>
    </section>

    <!-- BUILDINGS -->
    <section class="screen" id="screen-build">
      <div class="card">
        <div class="cardHeader"><h2>Build</h2><span class="tag">Housing · Economy · Defense</span></div>
        <div class="cardBody">
          <div class="rows" id="buildPanel"></div>
        </div>
      </div>
    </section>

    
    <!-- BATTLE -->
    <section class="screen" id="screen-battle">
      <div class="ad-slot native" id="adNativeBattle" data-ad-slot="native-battle"></div>
      <div class="card">
        <div class="cardHeader"><h2>Battle</h2><span class="tag">Campaign Paths</span></div>
        <div class="cardBody">
          <div class="rows" id="battleStats"></div>

          <div class="divider"></div>

          <div class="rows" id="battlePathSelect"></div>

          <div class="divider"></div>

          <div class="rows" id="battleTierList"></div>

          <div class="divider"></div>

          <div class="rows" id="battleDeploy"></div>

          <div class="divider"></div>

          <button class="btn" id="btnLaunchMission" disabled>
            <div class="left">
              <div class="name">Launch Mission</div>
              <div class="desc" id="missionDesc">Choose a path and mission tier</div>
            </div>
            <small id="missionHint"></small>
          </button>

          <div class="divider"></div>

          <div class="rows" id="battleReport"></div>
        </div>
      </div>
    </section>


    <!-- TECH -->
    <section class="screen" id="screen-tech">
      <div class="card">
        <div class="cardHeader"><h2>Tech</h2><span class="tag">Upgrades</span></div>
        <div class="cardBody">
          <div class="rows" id="techPanel"></div>
        </div>
      </div>
    </section>

    <!-- FACTIONS -->
    <section class="screen" id="screen-factions">
      <div class="card">
        <div class="cardHeader"><h2>Factions</h2><span class="tag">Allies · Reputation</span></div>
        <div class="cardBody">
          <div class="rows" id="factionSummary"></div>
          <div class="divider"></div>
          <div class="rows" id="factionPanel"></div>
        </div>
      </div>
    </section>

    <!-- LOG / STATS -->
    <section class="screen" id="screen-log">
      <div class="card">
        <div class="cardHeader"><h2>Outpost</h2><span class="tag">Stats & Log</span></div>
        <div class="cardBody">
          <div class="rows" id="statRows"></div>
          <div class="divider"></div>
          <div class="log" id="log"></div>
        </div>
      </div>
    </section>

  </main>
  <div class="adbar" id="adbar" aria-label="Advertisement">
    <div class="ad-slot banner" id="adBannerBottom" data-ad-slot="banner-bottom"></div>
  </div>

  <nav class="tabbar" aria-label="Menus">
    <button class="tab active" data-screen="clicker"><span class="dot"></span>Resources</button>
    <button class="tab" data-screen="build"><span class="dot"></span>Build</button>
    <button class="tab" data-screen="battle"><span class="dot"></span>Battle</button>
    <button class="tab" data-screen="tech"><span class="dot"></span>Tech</button>
    <button class="tab" data-screen="factions"><span class="dot"></span>Factions</button>
    <button class="tab" data-screen="log"><span class="dot"></span>Log</button>
    <button class="tab" id="btnMenu"><span class="dot"></span>Menu</button>
  </nav>

  <dialog id="modal">
    <div class="modalHeader">
      <h3 id="modalTitle">Menu</h3>
      <button class="closeBtn" id="modalClose">Close</button>
    </div>
    <div class="modalBody" id="modalBody"></div>
  </dialog>

  <!-- Battle simulation overlay (used by Battle Paths launch) -->
  <dialog id="simModal">
    <div class="modalHeader">
      <h3 id="simTitle">Simulating Battle</h3>
      <button class="closeBtn" id="simClose" disabled>Close</button>
    </div>
    <div class="modalBody" id="simBody"></div>
  </dialog>

  <!-- Faction details are rendered inline inside each faction card -->

  <div id="toastHost" aria-live="polite" aria-atomic="true"></div>

<script>
(() => {
  // ---------- Utilities ----------
  const $ = (id) => document.getElementById(id);
  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
  const fmt = (n) => {
    if (!isFinite(n)) return "∞";
    if (Math.abs(n) < 1000) return (Math.round(n * 10) / 10).toString();
    const units = ["K","M","B","T"];
    let u = -1;
    let x = n;
    while (Math.abs(x) >= 1000 && u < units.length - 1) { x /= 1000; u++; }
    return (Math.round(x * 10) / 10) + units[u];
  };

  // Simple stat UI helper (used in Battle Paths)
  function statChipsHTML(atk, def, hp){
    return `
      <span class="statLine">
        <span class="statChip" title="Attack"><b>ATK</b> ${atk}</span>
        <span class="statChip" title="Defense"><b>DEF</b> ${def}</span>
        <span class="statChip" title="Health"><b>HP</b> ${hp}</span>
      </span>
    `;
  }
  const now = () => Date.now();

  // ---------- UI prefs ----------
  function ensureUI(){
    if (!S.ui) S.ui = {};
    if (S.ui.pillsExpanded === undefined) S.ui.pillsExpanded = false;
  }


  // ---------- Micro feedback (toasts + floating text + haptics) ----------
  function haptic(ms=10){
    try{ if (navigator.vibrate) navigator.vibrate(ms); } catch {}
  }

  function toast(msg, tone=""){
    const host = $("toastHost");
    if (!host) return;
    const t = document.createElement("div");
    t.className = "toast" + (tone ? " " + tone : "");
    t.style.setProperty("--toastLife", "1700ms");
    t.textContent = msg;
    host.appendChild(t);
    // cleanup after animations
    setTimeout(() => { try{ t.remove(); } catch {} }, 2100);
  }

  function popNearEl(el, text, tone="good"){
    if (!el) return;
    const r = el.getBoundingClientRect();
    const x = r.left + (r.width/2);
    const y = r.top + Math.min(r.height*0.25, 18);
    const p = document.createElement("div");
    p.className = "popGain" + (tone ? " " + tone : "");
    p.textContent = text;
    p.style.left = x + "px";
    p.style.top  = y + "px";
    document.body.appendChild(p);
    setTimeout(() => { try{ p.remove(); } catch {} }, 900);
  }

  function flashBtn(el){
    if (!el) return;
    el.classList.add("tapFlash");
    setTimeout(() => el.classList.remove("tapFlash"), 120);
  }

  // Prefer pointerdown for mobile responsiveness; guard against double-fire (pointerdown + click)
  function bindTap(el, handler){
    let last = 0;
    const fire = (ev) => {
      const t = now();
      if (t - last < 240) return;
      last = t;
      handler(ev);
      queueSave();
};
    el.addEventListener("pointerdown", (ev) => {
      if (ev.pointerType === "mouse" && ev.button !== 0) return;
      fire(ev);
    }, { passive:true });
    el.addEventListener("click", fire);
  }


  // ---------- CivCrafter Momentum ----------
  function syncMomentum(){
    // Decay 1 momentum every 6s of inactivity
    const t = now();
    if (!S.momentumLastTick) S.momentumLastTick = t;
    const dt = t - S.momentumLastTick;
    const steps = Math.floor(dt / 6000);
    if (steps > 0){
      S.momentum = Math.max(0, (S.momentum || 0) - steps);
      S.momentumLastTick += steps * 6000;
    }
  }

  function addMomentum(n=1){
    syncMomentum();
    S.momentum = clamp((S.momentum || 0) + n, 0, 10);
    S.momentumLastTick = now();
  }

  function momentumMult(){
    syncMomentum();
    return 1 + ((S.momentum || 0) * 0.01); // +0% .. +10%
  }

  function repMilestone10(rep){
    return clamp(Math.floor((rep || 0) / 10), 0, 10);
  }


  const rewardText = (rw) => {
    if (!rw) return "—";
    const parts = [];
    for (const k of ["scrap","food","water","tech","caps"]){
      const v = rw[k] || 0;
      if (v > 0) parts.push(`${k.toUpperCase()} ${Math.floor(v)}`);
    }
    return parts.length ? parts.join(" · ") : "—";
  };

  function log(msg, tone="") {
    const el = $("log");
    if (!el) return;
    const p = document.createElement("p");
    const ts = new Date().toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"});
    p.innerHTML = `<span>[${ts}]</span> ${msg}`;
    if (tone === "warn") p.style.color = "var(--warn)";
    if (tone === "danger") p.style.color = "var(--danger)";
    el.prepend(p);
    while (el.children.length > 70) el.removeChild(el.lastChild);
  }

  // ---------- Game State ----------
  const DEFAULT = {
    // Version remains 6; expansion fields are migrated dynamically via ensureExpansion
    version: 6,
    t: now(),
    scrap: 20,
    food: 15,
    water: 10,
    tech: 0,
    caps: 25,
    rad: 0,
    pop: 3,
    idle: 3,
    scav: 0,
    farmers: 0,
    purifiers: 0,
    militia: 0,

    // Tap combo / overdrive (makes active play feel spicy)
    tapCombo: 0,
    tapComboLast: 0,
    tapFireUntil: 0,
    // Expansion roles (initialize to 0)
    engineers: 0,
    medics: 0,
    researchers: 0,
    scouts: 0,
    propagandists: 0,
    fixers: 0,
    shack: 0,
    farm: 0,
    purifier: 0,
    turret: 0,
    // Expansion buildings
    annex: 0,
    cmdcenter: 0,
    hospital: 0,
    blackmarket: 0,
    lab: 0,
    depot: 0,
    techs: { workshop:false, radio:false, medbay:false, caravan:false },
    day: 1,
    raidsWon: 0,

    // Expansion resources
    medData: 0,
    breakthroughs: 0,
    strain: 0,

    // CivCrafter: session momentum
    momentum: 0,
    momentumLastTick: 0,

    // Expansion: meta-progression
    prestige: { level: 0, tokens: 0 },
    // Expansion: daily quest
    quests: { last: 0, done: false, target: null, progress: 0, rewardCaps: 40, rewardTech: 2 },

    
    // Expansion: factions
    factions: {
      active: null,              // sponsored faction (one at a time)
      cooldownUntil: 0,          // timestamp; prevents rapid swapping
      uiSelected: "bos",         // which faction card is open in the UI
      streakId: null,            // last faction you completed a contract for
      streak: 0,                 // 0..5 (adds small bonus to keep you looping)
      units: {},              // purchased faction special units by faction id
      // reputation and rank tables per faction
      rep: { bos: 0, ncr: 0, followers: 0, raiders: 0, enclave: 0 },
      rank: { bos: 0, ncr: 0, followers: 0, raiders: 0, enclave: 0 },
      // permanent alignment with one faction (locks out others)
      aligned: null,
      // track if we've shown the alignment offer for each faction
      alignmentOffered: {},
      // faction‑specific currency earned from donations and missions
      currency: { bos: 0, ncr: 0, followers: 0, raiders: 0, enclave: 0 },
    },

    // Expansion: faction contract (one at a time; feels like CivCrafter "send a party")
    contract: {
      active: false,
      faction: null,
      name: null,
      tier: 0,           // 0 quick, 1 deep
      started: 0,
      end: 0,
      busy: 0,           // settlers committed
      repGain: 0,
      reward: null,      // {scrap, food, water, tech, caps}
      ready: false
    },
  

    // Battle: operations (send militia out; they don't defend while away)
    ops: {
      selected: "patrol", // "patrol" | "raid" | "assault"
      active: null,       // { type, started, end, busy, threat, chance, supplies:{food,water}, rewards:{scrap,food,caps,techChance}, ready }
      lastReport: null    // string
    },
};

  // Save key bumped because layout & version changed
  const KEY = "wasteland_outpost_save_v5";

  let S = load() || structuredClone(DEFAULT);

  // ---------- Balancing ----------
  function housingCap() {
    return 3 + S.shack * 4 + (S.techs.workshop ? 3 : 0);
  }

  function opsBusyMilitia(){
    const a = S.ops && S.ops.active;
    if (!a) return 0;
    if (a.ready) return 0;
    return Math.max(0, a.busy|0);
  }
  function availableMilitia(){
    return Math.max(0, (S.militia|0) - opsBusyMilitia());
  }

  function defensePower(){
    return availableMilitia() * 1.0 + S.turret * 2.2 + (S.techs.medbay ? 0.4 : 0);}

  function defenseScore(){ return defensePower(); }
  function productionPerSec() {
    // global multipliers from Engineers
    const engMult = 1 + (S.engineers || 0) * 0.02;
    // base rates
    let scavRate = (0.6 + S.shack*0.03) * S.scav * engMult;
    let foodRate = (0.45 + S.farm*0.12) * S.farmers * engMult;
    let waterRate = (0.35 + S.purifier*0.18) * S.purifiers * engMult;
    // tech comes from scavengers (workshop) and engineers
    let techRate = (S.techs.workshop ? 0.05 : 0) * S.scav + (S.engineers || 0) * 0.1;
    let capsRate = (S.techs.caravan ? 0.08 : 0) * (S.pop);
    // rad gain slowed by medics
    let radGain = Math.max(0, (S.pop * 0.002 + S.day * 0.0007) * (S.techs.medbay ? 0.55 : 1));
    if (S.medics) {
      radGain *= Math.max(0.1, 1 - 0.05 * S.medics);
    }
    const foodUse = S.pop * 0.10;
    const waterUse = S.pop * 0.08;
    return { scavRate, foodRate, waterRate, techRate, capsRate, foodUse, waterUse, radGain };
  }
  function recruitCost() {
    const baseF = 10 + Math.floor(S.pop * 1.6);
    const baseW = 7 + Math.floor(S.pop * 1.2);
    return { food: baseF, water: baseW };
  }
  function purifyCost() {
    const scrap = 6 + Math.floor(S.purifier * 2.5);
    return { scrap, waterGain: 5 + Math.floor(S.purifier * 0.9) };
  }
  function deconCost() {
    // Water -> reduce rad; medbay makes it more efficient
    const w = 6 + Math.floor(S.pop * 0.6);
    let radDown = (S.techs.medbay ? 14 : 10);
    // Followers can help you scrub RAD harder
    if (S.factions && S.factions.active === "followers") {
      const r = (S.factions.rank && S.factions.rank.followers) ? S.factions.rank.followers : 0;
      radDown += r * 3;
    }
    return { water: w, radDown };
  }

  function tradeCost() {
    // Early-game: trade scrap to get caps so you can build housing/defense.
    // Scales gently so it stays useful but not broken.
    const scrap = 16 + Math.floor((S.shack + S.turret) * 4) + Math.floor(S.pop * 1.5);
    const capsGain = 10 + Math.floor(S.day * 0.6);
    return { scrap, capsGain };
  }
  function raidPlan() {
    const threat = 2.2 + S.day * 0.35 + (S.raidsWon * 0.7) + (S.pop * 0.08);
    const your = defensePower();
    const chance = clamp(0.15 + (your - threat) * 0.18, 0.05, 0.9);
    const lootScrap = Math.floor(12 + threat * 8);
    const lootFood = Math.floor(6 + threat * 3);
    const lootTech = Math.random() < 0.25 ? 1 : 0;
    const lootCaps = Math.floor(4 + threat * 4);
    return { threat, your, chance, lootScrap, lootFood, lootTech, lootCaps };
  }

  // ===================== Expansion: Prestige + Daily Quest =====================

  function prestigeBonus(){
    const lvl = S.prestige?.level || 0;
    return { prod: 1 + lvl * 0.12, caps: 1 + lvl * 0.20, radRes: 1 + lvl * 0.08 };
  }

  const _baseProductionPerSec = productionPerSec;
  productionPerSec = function(){
    const p = _baseProductionPerSec();
    const b = prestigeBonus();
    p.scavRate *= b.prod;
    p.foodRate *= b.prod;
    p.waterRate *= b.prod;
    p.techRate *= b.prod;
    p.capsRate *= b.caps;
    p.radGain /= b.radRes;
    return p;
  };

  // ===================== Expansion: Factions =====================

  const FACTIONS = {
    bos: {
      name: "Brotherhood of Steel",
      tag: "Tech · Defense",
      desc: "Donate components. Get patrols and turret upgrades.",
      currencyName: "Tech Relic",
      bonusesByRank: [
        { defFlat: 0, prod: 1, caps: 1, radRes: 1, loot: 1 },
        { defFlat: 0.8, prod: 1.00, caps: 1.00, radRes: 1.02, loot: 1.00 },
        { defFlat: 1.6, prod: 1.02, caps: 1.00, radRes: 1.05, loot: 1.00 },
        { defFlat: 2.6, prod: 1.04, caps: 1.02, radRes: 1.08, loot: 1.00 },
      ],
      donate: { tech: 2, scrap: 20, repGain: 6 },
      specialUnit: { name: "Paladin Knight", desc: "Heavily armored fighters.", cost: 5 },
    },
    ncr: {
      name: "NCR",
      tag: "Order · Economy",
      desc: "Fund a local outpost. Get caps flow and stability.",
      currencyName: "Authority",
      bonusesByRank: [
        { defFlat: 0, prod: 1, caps: 1, radRes: 1, loot: 1 },
        { defFlat: 0.3, prod: 1.00, caps: 1.08, radRes: 1.02, loot: 1.00 },
        { defFlat: 0.6, prod: 1.01, caps: 1.14, radRes: 1.04, loot: 1.00 },
        { defFlat: 1.0, prod: 1.02, caps: 1.20, radRes: 1.06, loot: 1.00 },
      ],
      donate: { caps: 18, scrap: 12, repGain: 6 },
      specialUnit: { name: "Ranger", desc: "Elite marksmen and scouts.", cost: 5 },
    },
    followers: {
      name: "Followers of the Apocalypse",
      tag: "Aid · Radiation",
      desc: "Stock their clinics. Get better decon and slower rad.",
      currencyName: "Influence",
      bonusesByRank: [
        { defFlat: 0, prod: 1, caps: 1, radRes: 1, loot: 1 },
        { defFlat: 0.0, prod: 1.01, caps: 1.00, radRes: 1.10, loot: 1.00 },
        { defFlat: 0.0, prod: 1.02, caps: 1.00, radRes: 1.18, loot: 1.00 },
        { defFlat: 0.2, prod: 1.03, caps: 1.00, radRes: 1.26, loot: 1.00 },
      ],
      donate: { water: 18, food: 14, repGain: 6 },
      specialUnit: { name: "Field Medic", desc: "Support unit that reduces losses.", cost: 4 },
    },
    raiders: {
      name: "Raiders",
      tag: "Loot · Risk",
      desc: "Pay tribute. Get bigger raid hauls (but it gets messy).",
      currencyName: "Fear",
      bonusesByRank: [
        { defFlat: 0, prod: 1, caps: 1, radRes: 1, loot: 1 },
        { defFlat: 0.0, prod: 1.00, caps: 1.00, radRes: 0.98, loot: 1.10 },
        { defFlat: 0.0, prod: 1.00, caps: 1.00, radRes: 0.95, loot: 1.20 },
        { defFlat: 0.0, prod: 1.01, caps: 1.00, radRes: 0.92, loot: 1.30 },
      ],
      donate: { caps: 14, food: 10, repGain: 6 },
      specialUnit: { name: "Berserker", desc: "Brutal shock troops.", cost: 4 },
    },
    enclave: {
      name: "Enclave",
      tag: "Science · Power",
      desc: "Trade data. Get tech salvage and production boosts.",
      currencyName: "Clearance",
      bonusesByRank: [
        { defFlat: 0, prod: 1, caps: 1, radRes: 1, loot: 1 },
        { defFlat: 0.4, prod: 1.04, caps: 1.00, radRes: 1.02, loot: 1.00 },
        { defFlat: 0.8, prod: 1.07, caps: 1.00, radRes: 1.04, loot: 1.00 },
        { defFlat: 1.2, prod: 1.10, caps: 1.02, radRes: 1.06, loot: 1.00 },
      ],
      donate: { tech: 2, caps: 16, repGain: 6 },
      specialUnit: { name: "Power Trooper", desc: "Advanced power armor troopers.", cost: 6 },
    },
  };

  const RANKS = [
    { name:"Neutral", min: 0 },
    { name:"Trusted", min: 20 },
    { name:"Ally", min: 50 },
    { name:"Champion", min: 80 },
  ];

  
function ensureFactions(){
  // Back/forward compatible init
  if (!S.factions) S.factions = structuredClone(DEFAULT.factions);

  // Legacy keys
  if (S.factions.active === undefined) S.factions.active = null;
  if (S.factions.rep === undefined) S.factions.rep = structuredClone(DEFAULT.factions.rep);
  if (S.factions.rank === undefined) S.factions.rank = structuredClone(DEFAULT.factions.rank);

  // New keys (clean mobile faction UI + addictive streak loop)
  if (S.factions.cooldownUntil === undefined) S.factions.cooldownUntil = 0;
  if (S.factions.uiSelected === undefined) S.factions.uiSelected = (S.factions.active || "bos");
  if (S.factions.streakId === undefined) S.factions.streakId = null;
  if (S.factions.streak === undefined) S.factions.streak = 0;
  if (S.factions.units === undefined) S.factions.units = {};
  // Donation pacing (prevents infinite spam and makes choices meaningful)
  if (S.factions.donateCount === undefined) S.factions.donateCount = {};
  if (S.factions.lastDonateAt === undefined) S.factions.lastDonateAt = {};

  // Ensure all factions exist (safe if new factions are added later)
  for (const id of Object.keys(FACTIONS)){
    if (S.factions.rep[id] === undefined) S.factions.rep[id] = 0;
    if (S.factions.rank[id] === undefined) S.factions.rank[id] = 0;
    if (S.factions.units[id] === undefined) S.factions.units[id] = 0;
    // ensure currency field exists per faction
    if (!S.factions.currency) S.factions.currency = {};
    if (S.factions.currency[id] === undefined) S.factions.currency[id] = 0;
    if (S.factions.donateCount[id] === undefined) S.factions.donateCount[id] = 0;
    if (S.factions.lastDonateAt[id] === undefined) S.factions.lastDonateAt[id] = 0;
  }
  // new alignment state
  if (S.factions.aligned === undefined) S.factions.aligned = null;
  if (S.factions.alignmentOffered === undefined) S.factions.alignmentOffered = {};
  // Clamp
  if (S.factions.streak < 0) S.factions.streak = 0;
  if (S.factions.streak > 5) S.factions.streak = 5;
}

// Ensure expansion-related fields exist on the save state. Without this, referencing
// new roles/buildings/resources will throw errors if loaded from an older save.
function ensureExpansion(){
  // Default values for new properties introduced in the expansion
  const defaults = {
    annex: 0,
    cmdcenter: 0,
    hospital: 0,
    blackmarket: 0,
    lab: 0,
    depot: 0,
    engineers: 0,
    medics: 0,
    researchers: 0,
    scouts: 0,
    propagandists: 0,
    fixers: 0,
    medData: 0,
    breakthroughs: 0,
    strain: 0,

    // Tap combo / overdrive
    tapCombo: 0,
    tapComboLast: 0,
    tapFireUntil: 0,
  };
  for (const k of Object.keys(defaults)) {
    if (S[k] === undefined || S[k] === null) {
      S[k] = defaults[k];
    }
  }
}

  function ensureContract(){
    if (!S.contract) S.contract = structuredClone(DEFAULT.contract);
    if (S.contract.active === undefined) S.contract.active = false;
    if (S.contract.busy === undefined) S.contract.busy = 0;
    if (S.contract.ready === undefined) S.contract.ready = false;
  }

  function contractActive(){ ensureContract(); return !!S.contract.active; }
  function contractReady(){ ensureContract(); return !!S.contract.ready; }
  function contractTimeLeft(){ ensureContract(); return Math.max(0, (S.contract.end || 0) - now()); }
  function fmtTime(ms){
    const s = Math.ceil(ms/1000);
    const m = Math.floor(s/60);
    const r = s%60;
    return m>0 ? `${m}m ${r}s` : `${r}s`;
  }

  function fmtShortTimeAgo(ts){
    const d = Math.max(0, now() - (ts||0));
    const s = Math.floor(d/1000);
    if (s < 60) return `${s}s ago`;
    const m = Math.floor(s/60);
    if (m < 60) return `${m}m ago`;
    const h = Math.floor(m/60);
    if (h < 48) return `${h}h ago`;
    const days = Math.floor(h/24);
    return `${days}d ago`;
  }

  function contractDefForFaction(id, tier){
    // CivCrafter-like: short addictive loops with scaling rewards.
    const rep = clamp(S.factions.rep[id] || 0, 0, 100);
    const rank = clamp(S.factions.rank[id] || rankForRep(rep), 0, 3);
    const day = Math.max(1, Math.floor(S.day));
    const base = 10 + day*2 + rank*6;
    const mult = tier===1 ? 2.4 : 1.0;
    const dur = tier===1 ? 6*60*1000 : 90*1000;
    const repGain = tier===1 ? (6 + rank*2) : (3 + rank);

    // Rewards flavored by faction.
    let reward = { scrap: Math.floor(base*mult), food: 0, water: 0, tech: 0, caps: 0 };
    if (id === "bos") { reward.tech = (tier===1 ? 2 : 1) + (Math.random()<0.25?1:0); reward.caps = Math.floor(6*mult); }
    if (id === "ncr") { reward.caps = Math.floor((12 + day)*mult); reward.food = Math.floor(6*mult); }
    if (id === "followers") { reward.water = Math.floor(10*mult); reward.food = Math.floor(8*mult); reward.tech = (Math.random()<0.2?1:0); }
    if (id === "raiders") { reward.caps = Math.floor(10*mult); reward.food = Math.floor(10*mult); reward.scrap = Math.floor(base*mult*1.25); }
    if (id === "enclave") { reward.tech = (tier===1 ? 3 : 1) + (Math.random()<0.35?1:0); reward.scrap = Math.floor(base*mult*0.9); reward.caps = Math.floor(6*mult); }

    // Rare "Relic" drop chance -> extra TECH
    const relicChance = tier===1 ? 0.18 : 0.07;
    return { dur, repGain, reward, relicChance, rank };
  }

  function canStartContract(){
    ensureContract();
    if (S.contract.active || S.contract.ready) return false;
    // Can start if we have at least one idle settler available
    return (S.idle || 0) >= 1;
  }

  function startContract(id, tier){
    ensureFactions(); ensureContract();
    if (!FACTIONS[id]) return;
    const rep = clamp(S.factions.rep[id] || 0, 0, 100);
    if (tier === 1 && rep < 20){ log("Deep expeditions require REP 20+. Do a few Quick Runs or donate supplies.", "warn"); return; }
    // determine costs for militia and supplies (quick missions use 0 militia)
    const costMilitia = (tier === 1 ? 1 : 0);
    const costFood    = (tier === 1 ? 8 : 4);
    const costWater   = (tier === 1 ? 4 : 2);
    // Check resource availability
    if ((S.militia || 0) < costMilitia){ log(`Not enough Militia to send (${costMilitia} required).`, "warn"); return; }
    if ((S.food || 0) < costFood){ log(`Not enough Food to send (${costFood} required).`, "warn"); return; }
    if ((S.water || 0) < costWater){ log(`Not enough Water to send (${costWater} required).`, "warn"); return; }
    // Deduct costs up front; always deduct 1 idle settler
    S.idle   -= 1;
    if (costMilitia > 0) S.militia -= costMilitia;
    S.food   -= costFood;
    S.water  -= costWater;
    const def = contractDefForFaction(id, tier);
    S.contract.active  = true;
    S.contract.faction = id;
    S.contract.tier    = tier;
    S.contract.started = now();
    S.contract.end     = now() + def.dur;
    // busy stores militia committed; they'll return later (minus casualties)
    S.contract.busy    = costMilitia;
    S.contract.repGain = def.repGain;
    S.contract.reward  = def.reward;
    S.contract.ready   = false;
    S.contract.relicChance = def.relicChance;

    const label = tier===1 ? "Deep Expedition" : "Quick Run";
    const fName = FACTIONS[id].name;
    log(`${label} dispatched for ${fName}. Used ${costMilitia} Militia, ${costFood} Food, ${costWater} Water. ETA ${fmtTime(def.dur)}.`, "warn");
  }

  
function finishContract(){
  ensureContract(); ensureFactions();
  if (!S.contract.active) return;

  // Return the idle settler that was sent on the mission
  S.idle += 1;
  // Return the committed militia (may suffer casualties). We treat 'busy' as number of militia used.
  const committed = S.contract.busy || 0;
  let casualties = 0;
  // Casualty chance: higher for deep expeditions
  const tier = S.contract.tier || 0;
  for (let i=0; i<committed; i++){
    const deathChance = (tier === 1 ? 0.4 : 0.2);
    if (Math.random() < deathChance) casualties++;
  }
  const returning = Math.max(0, committed - casualties);
  if (committed > 0) S.militia += returning;
  if (casualties > 0){
    log(`${casualties} militia were lost during the mission.`, "danger");
  }

  const id = S.contract.faction;
  const baseReward = S.contract.reward || {};

  // ===== Streak (addictive micro-loop): keep running jobs for the same faction =====
  if (id){
    if (S.factions.streakId === id) {
      S.factions.streak = clamp((S.factions.streak||0) + 1, 0, 5);
    } else {
      S.factions.streakId = id;
      S.factions.streak = 1;
    }
  } else {
    S.factions.streakId = null;
    S.factions.streak = 0;
  }

  const streak = (S.factions.streakId === id) ? (S.factions.streak||0) : 0;
  const streakMult = 1 + Math.max(0, streak - 1) * 0.05; // up to +20%
  const reward = {};
  for (const k of ["scrap","food","water","tech","caps"]){
    reward[k] = Math.floor((baseReward[k] || 0) * streakMult);
    S[k] += reward[k];
  }

  // REP gain (small extra per streak step after the first)
  let repGain = (S.contract.repGain || 0) + Math.max(0, streak - 1);
  if (id && S.factions.rep[id] !== undefined){
    const before = S.factions.rep[id] || 0;
    addRep(id, repGain);
    const after = S.factions.rep[id] || 0;
    // If we didn't move (already capped) keep rank synced
    S.factions.rank[id] = rankForRep(after);
  }

  // Relic drop
  if (Math.random() < (S.contract.relicChance || 0)) {
    const extra = 1 + (S.contract.tier===1 ? 1 : 0);
    S.tech += extra;
    log(`Relic recovered! +${extra} TECH.`, "warn");
  }

  // Award faction currency based on mission tier (quick=1, deep=2)
  if (id && S.factions && S.factions.currency){
    const currencyGain = (S.contract.tier === 1 ? 2 : 1);
    S.factions.currency[id] = (S.factions.currency[id] || 0) + currencyGain;
    log(`Mission reward: +${currencyGain} ${FACTIONS[id].currencyName}.`, "warn");
  }

  // Flavor
  const bits = [];
  if (reward.scrap) bits.push(`+${reward.scrap} Scrap`);
  if (reward.food) bits.push(`+${reward.food} Food`);
  if (reward.water) bits.push(`+${reward.water} Water`);
  if (reward.tech) bits.push(`+${reward.tech} Tech`);
  if (reward.caps) bits.push(`+${reward.caps} Caps`);
  const streakBit = streak >= 2 ? ` · Streak x${fmt(streakMult)} (+${Math.max(0,streak-1)} REP)` : ``;
  log(`Contract complete (${FACTIONS[id]?.name || "Faction"}). ${bits.join(", ")}. +${repGain} REP${streakBit}.`, "warn");

  S.contract.active = false;
  S.contract.ready = false;
  S.contract.faction = null;
  S.contract.name = null;
  S.contract.reward = null;
  S.contract.busy = 0;
  S.contract.repGain = 0;
  S.contract.end = 0;
}

  function checkContract(){
    ensureContract();
    if (!S.contract.active) return;
    if (!S.contract.ready && now() >= (S.contract.end || 0)) {
      S.contract.ready = true;
      log("A runner returns at the gates. Contract ready to collect.", "warn");
    }
  }

  function collectContract(){
    ensureContract();
    // Robust: allow collection even if the "ready" flag didn't update (e.g. timers paused in background on mobile)
    if (!S.contract.active) return;

    // If time has elapsed, mark ready now
    if (!S.contract.ready && now() >= (S.contract.end || 0)) {
      S.contract.ready = true;
    }

    if (!S.contract.ready) {
      toast(`Not ready yet — ${fmtTime(contractTimeLeft())} left.`, "warn");
      return;
    }
    finishContract();
  }

  function rankForRep(rep){
    if (rep >= 80) return 3;
    if (rep >= 50) return 2;
    if (rep >= 20) return 1;
    return 0;
  }

  function rankName(r){
    return (RANKS[r] && RANKS[r].name) || "Neutral";
  }

  function activeFactionBonus(){
    ensureFactions();
    const id = S.factions.active;
    if (!id || !FACTIONS[id]) return { defFlat:0, prod:1, caps:1, radRes:1, loot:1 };

    const rep = clamp(S.factions.rep[id] || 0, 0, 100);
    const r = clamp(S.factions.rank[id] || 0, 0, 3);

    const base = FACTIONS[id].bonusesByRank[r] || { defFlat:0, prod:1, caps:1, radRes:1, loot:1 };

    // CivCrafter: frequent micro-progress (every 10 REP)
    const m10 = repMilestone10(rep); // 0..10
    const micro = 1 + (m10 * 0.006); // up to +6%

    return {
      defFlat: base.defFlat || 0,
      prod: (base.prod || 1) * micro,
      caps: (base.caps || 1) * micro,
      radRes: (base.radRes || 1),
      loot: (base.loot || 1) * micro
    };
  }

function addRep(id, amount){
    ensureFactions();
    if (!FACTIONS[id]) return;
    const before = S.factions.rep[id] || 0;
    const after = clamp(before + amount, 0, 100);
    S.factions.rep[id] = after;
    const rb = rankForRep(before);
    const ra = rankForRep(after);
    if (ra > rb){
      S.factions.rank[id] = ra;
      log(`${FACTIONS[id].name} reputation reached ${rankName(ra)} (${Math.round(after)}/100).`, "warn");
    } else {
      S.factions.rank[id] = Math.max(S.factions.rank[id] || 0, ra);
    }

    // Check if this reputation gain should trigger an alignment offer
    maybeOfferAlignment(id);
  }

  // Offer permanent alignment when certain reputation thresholds are crossed
  function maybeOfferAlignment(id){
    ensureFactions();
    // if already aligned, do nothing
    if (S.factions.aligned) return;
    // ensure this faction exists
    if (!FACTIONS[id]) return;
    const rep = S.factions.rep[id] || 0;
    // only offer once per faction at threshold >=50
    if (rep < 50) return;
    if (S.factions.alignmentOffered && S.factions.alignmentOffered[id]) return;
    // mark as offered so we don't repeat
    if (!S.factions.alignmentOffered) S.factions.alignmentOffered = {};
    S.factions.alignmentOffered[id] = true;
    // simple confirmation prompt; if accepted, align permanently
    const name = FACTIONS[id].name || id;
    const ok = window.confirm(`${name} has offered to formally align with your settlement.\nThis choice is permanent and all other factions will disappear. Accept?`);
    if (ok) {
      alignFaction(id);
    }
  }

  // Permanently align with a faction; hide others and set as sponsor
  function alignFaction(id){
    ensureFactions();
    if (!FACTIONS[id]) return;
    S.factions.aligned = id;
    // set as sponsor if none or different
    if (!S.factions.active || S.factions.active !== id) S.factions.active = id;
    // reset rep and rank of other factions to zero to avoid UI confusion
    for (const k of Object.keys(FACTIONS)){
      if (k !== id) {
        S.factions.rep[k] = 0;
        S.factions.rank[k] = 0;
        S.factions.currency[k] = 0;
      }
    }
    // update UI
    log(`Your settlement has pledged allegiance to the ${FACTIONS[id].name}. Other factions are no longer available.`, "warn");
    renderAll();
    queueSave();
  }

  function canDonateFaction(id){
    const p = donatePlan(id);
    if (!p) return false;
    if (p.cooldownLeft > 0) return false;
    return Object.entries(p.cost).every(([k,v]) => (S[k] || 0) >= v);
  }

  function donatePlan(id){
    ensureFactions();
    const base = FACTIONS[id]?.donate;
    if (!base) return null;

    // Donation costs scale to prevent infinite spam + make late-game contributions meaningful.
    const n = (S.factions.donateCount && (S.factions.donateCount[id]||0)) || 0;
    const day = Math.max(1, Math.floor(S.day||1));
    const mult = 1 + (n * 0.18) + (day * 0.015);

    const cost = {};
    for (const [k,v] of Object.entries(base)){
      if (k === "repGain") continue;
      cost[k] = Math.max(1, Math.ceil(v * mult));
    }

    const cooldownMs = 6500;
    const last = (S.factions.lastDonateAt && (S.factions.lastDonateAt[id]||0)) || 0;
    const cooldownLeft = Math.max(0, (last + cooldownMs) - now());

    return {
      cost,
      baseRepGain: base.repGain || 1,
      tokenGain: 1,
      mult,
      cooldownLeft
    };
  }

  function donateToFaction(id){
    const p = donatePlan(id);
    if (!p) return;
    if (p.cooldownLeft > 0){ toast(`Donation teams re-stocking — ${fmtTime(p.cooldownLeft)}.`, "warn"); return; }
    if (!canDonateFaction(id)) { log("Not enough supplies to donate.", "warn"); return; }

    for (const [k,v] of Object.entries(p.cost)){
      S[k] -= v;
    }

    // Track scaling + cooldown
    S.factions.donateCount[id] = (S.factions.donateCount[id]||0) + 1;
    S.factions.lastDonateAt[id] = now();

    const mm = momentumMult();
    const repGain = Math.max(1, Math.floor((p.baseRepGain || 1) * mm));
    addRep(id, repGain);
    addMomentum(1);
    // Award one unit of faction currency per donation
    if (S.factions && S.factions.currency) {
      S.factions.currency[id] = (S.factions.currency[id] || 0) + (p.tokenGain||1);
    }
    log(`Donation delivered to ${FACTIONS[id].name}. +${repGain} REP. +${p.tokenGain||1} ${FACTIONS[id].currencyName}.` + (mm>1?` (Momentum +${Math.round((mm-1)*100)}%)`:``), "warn");
  }

  

  function canBuyFactionUnit(fid){
    ensureFactions();
    if (!S.factions.aligned || S.factions.aligned !== fid) return false;
    const unit = FACTIONS[fid]?.specialUnit;
    if (!unit) return false;
    const curr = (S.factions.currency && S.factions.currency[fid]) || 0;
    return curr >= (unit.cost || 0);
  }

  function purchaseSpecialUnit(fid){
    ensureFactions();
    if (!S.factions.aligned || S.factions.aligned !== fid){
      log("You can only buy units from your aligned faction.", "warn");
      return;
    }
    const unit = FACTIONS[fid]?.specialUnit;
    if (!unit){ log("No shop items available.", "warn"); return; }
    if (!S.factions.currency) S.factions.currency = {};
    const curr = S.factions.currency[fid] || 0;
    if (curr < unit.cost){
      log(`Not enough ${FACTIONS[fid].currencyName} (need ${unit.cost}).`, "warn");
      return;
    }
    S.factions.currency[fid] = curr - unit.cost;
    if (!S.factions.units) S.factions.units = {};
    S.factions.units[fid] = (S.factions.units[fid] || 0) + 1;
    log(`${unit.name} recruited.`, "warn");
  }

  function openFactionShop(fid){
    ensureFactions();
    if (!S.factions.aligned || S.factions.aligned !== fid){
      log("No access to that shop.", "warn");
      return;
    }
    const fac = FACTIONS[fid];
    const unit = fac.specialUnit;
    const currName = fac.currencyName || "Tokens";
    const curr = (S.factions.currency && S.factions.currency[fid]) || 0;
    const owned = (S.factions.units && S.factions.units[fid]) || 0;

    // Flavor title
    const titleMap = {
      bos: "Brotherhood Quartermaster",
      ncr: "NCR Logistics Office",
      followers: "Followers Supply Cache",
      raiders: "Raider Fence",
      enclave: "Enclave Armory"
    };
    const title = titleMap[fid] || (fac.name + " Shop");

    const body = `
      <p><span class="tag">${currName}: ${curr}</span> <span class="tag">Owned: ${owned}</span></p>
      <div class="rows" style="gap:12px;">
        <button class="btn" id="shopBuyUnit" ${curr < unit.cost ? "disabled" : ""}>
          <div class="left">
            <div class="name">${unit.name} <span class="tag">x${owned}</span></div>
            <div class="desc">${unit.desc}</div>
          </div>
          <small>${currName.toUpperCase()} ${unit.cost}</small>
        </button>
      </div>
    `;
    showModal(title, body);
    setTimeout(() => {
      const b = document.getElementById("shopBuyUnit");
      if (b){
        b.onclick = () => {
          purchaseSpecialUnit(fid);
          closeModal();
          renderAll();
          queueSave();
        };
      }
    }, 0);
  }


function sponsorCost(nextId){
  // Simple, readable: switching sponsors costs caps, scales gently with your day
  const day = Math.max(1, Math.floor(S.day||1));
  const base = 18 + Math.floor(day * 1.2);
  return base;
}

function canSwapSponsor(){
  ensureFactions();
  const left = Math.max(0, (S.factions.cooldownUntil||0) - now());
  return left <= 0;
}

function sponsorFaction(id){
  ensureFactions();
  if (!FACTIONS[id]) return;

  const rep = S.factions.rep[id] || 0;
  if (rep < 20){ log("Earn at least 20 REP to get a faction sponsor.", "warn"); return; }

  const left = Math.max(0, (S.factions.cooldownUntil||0) - now());
  if (left > 0){
    toast(`Sponsor locked — ${fmtTime(left)} remaining.`, "warn");
    return;
  }

  const prev = S.factions.active;
  if (prev === id){ toast("Already your sponsor.", "warn"); return; }

  // First sponsor is free; swaps cost caps
  if (prev){
    const cost = sponsorCost(id);
    if (S.caps < cost){ log(`Not enough Caps to switch sponsor (need ${cost}).`, "warn"); return; }
    S.caps -= cost;
  }

  S.factions.active = id;
  S.factions.uiSelected = id;

  // Cooldown (mobile-friendly pacing)
  S.factions.cooldownUntil = now() + 10*60*1000;

  // Reset streak when you swap sponsors (keeps choices meaningful)
  S.factions.streakId = null;
  S.factions.streak = 0;

  log(`Sponsor secured: ${FACTIONS[id].name}.`, "warn");
}

function clearActiveFaction(){
  ensureFactions();
  if (!S.factions.active) return;
  const prev = S.factions.active;
  S.factions.active = null;
  S.factions.uiSelected = S.factions.uiSelected || "bos";
  S.factions.streakId = null;
  S.factions.streak = 0;
  log(`You ended your sponsorship with ${FACTIONS[prev]?.name || "a faction"}.`, "warn");
}

  // Apply faction bonuses to production and defense (layered on top of prestige).
  const _prodAfterPrestige = productionPerSec;
  productionPerSec = function(){
    const p = _prodAfterPrestige();
    const b = activeFactionBonus();
    p.scavRate *= b.prod;
    p.foodRate *= b.prod;
    p.waterRate *= b.prod;
    p.techRate *= b.prod;
    p.capsRate *= b.caps;
    p.radGain /= (b.radRes || 1);
    return p;
  };

  const _baseDefensePower = defensePower;
  defensePower = function(){
    const base = _baseDefensePower();
    const b = activeFactionBonus();
    return base + (b.defFlat || 0);
  };

  function canPrestige(){
    return (S.pop >= 25) || (S.raidsWon >= 12) || (S.tech >= 50);
  }

  function prestigeGainEstimate(){
    const score = (S.pop * 1.5) + (S.raidsWon * 3) + (S.tech * 0.6) + (S.turret * 4);
    return Math.max(1, Math.floor(score / 35));
  }

  function doPrestige(){
    if (!canPrestige()){
      log("Not ready to reset yet. Grow pop, win raids, or stockpile tech.", "warn");
      return;
    }
    const gained = prestigeGainEstimate();
    const prev = S.prestige || { level:0, tokens:0 };
    const nextPrestige = { level: (prev.level||0) + 1, tokens: (prev.tokens||0) + gained };

    S = structuredClone(DEFAULT);
    S.prestige = nextPrestige;

    save();
    const el = $("log"); if (el) el.innerHTML = "";
    log(`Wasteland Reset complete. Prestige Level ${S.prestige.level} (+${gained} tokens).`, "warn");
    renderAll();
    showScreen("clicker");
  }

  function ensureQuest(){
    if (!S.quests || !S.quests.target){
      S.quests = { last: 0, done: false, target: null, progress: 0, rewardCaps: 40, rewardTech: 2 };
    }
    const dayMs = 24*60*60*1000;
    const fresh = (Date.now() - (S.quests.last||0)) < dayMs;
    if (!fresh || S.quests.last === 0) rollNewQuest();
  }

  function rollNewQuest(){
    const lvl = S.prestige?.level || 0;
    const pool = [
      { type:"scavenge", label:"Scavenge taps", goal: 35 + Math.floor(lvl*8) },
      { type:"build", label:"Build structures", goal: 3 + Math.floor(lvl*1) },
      { type:"raid", label:"Win raids", goal: 2 + Math.floor(lvl*0.5) },
      { type:"recruit", label:"Recruit settlers", goal: 5 + Math.floor(lvl*1) },
    ];
    const pick = pool[Math.floor(Math.random()*pool.length)];
    S.quests = {
      last: Date.now(),
      done: false,
      target: pick,
      progress: 0,
      rewardCaps: 45 + Math.floor(lvl*10),
      rewardTech: 2 + Math.floor(lvl*0.4),
    };
    log(`Daily quest: ${pick.label} (${S.quests.progress}/${pick.goal}).`, "warn");
  }

  function incQuest(type, amount=1){
    if (!S.quests || !S.quests.target || S.quests.done) return;
    if (S.quests.target.type !== type) return;
    S.quests.progress += amount;
    if (S.quests.progress >= S.quests.target.goal){
      S.quests.done = true;
      S.caps += S.quests.rewardCaps;
      S.tech += S.quests.rewardTech;
      log(`Daily quest complete! +${S.quests.rewardCaps} Caps, +${S.quests.rewardTech} Tech.`, "warn");
    }
  }

  function questStatusText(){
    ensureQuest();
    const q = S.quests;
    if (!q.target) return "No quest";
    return q.done ? "Complete — claimed" : `${q.target.label}: ${q.progress}/${q.target.goal}`;
  }


  // ---------- UI: screen navigation ----------
  const screens = ["clicker","build","battle","tech","factions","log"];
  // Track the currently visible screen so tick() doesn't continuously rebuild hidden UIs.
  // This fixes the "spazzing"/blinking on the Battle screen caused by full re-renders every 250ms.
  const UI = {
    screen: "clicker",
    lastLightRender: 0,
    battleSig: "",
    battleRenderedAt: 0,
    battleDirty: true,
  };
  function showScreen(name){
    UI.screen = name;
    if (name === "battle") UI.battleDirty = true;
    for (const s of screens){
      const el = $("screen-" + s);
      if (el) el.classList.toggle("active", s === name);
    }
    document.querySelectorAll(".tab[data-screen]").forEach(btn => {
      btn.classList.toggle("active", btn.dataset.screen === name);
    });
    // render on switch so costs/buttons are fresh
    renderAll();
  }

  document.querySelectorAll(".tab[data-screen]").forEach(btn => {
    btn.addEventListener("click", () => showScreen(btn.dataset.screen));
  });

  // Top HUD: toggle advanced resource pills
  const pillsBtn = $("btnPillsToggle");
  if (pillsBtn){
    pillsBtn.addEventListener("click", () => {
      ensureUI();
      S.ui.pillsExpanded = !S.ui.pillsExpanded;
      pillsBtn.textContent = S.ui.pillsExpanded ? "Less" : "More";
      renderTopPills();
      queueSave();
    });
  }

  // ---------- UI builders ----------
  function renderTopPills() {
    const el = $("topPills");
    el.innerHTML = "";
    // ensure expansions are initialised
    ensureExpansion();
    ensureUI();

    const pillsBtn = $("btnPillsToggle");
    if (pillsBtn) pillsBtn.textContent = S.ui.pillsExpanded ? "Less" : "More";

    const basic = [
      ["SCRAP", S.scrap],
      ["FOOD", S.food],
      ["WATER", S.water],
      ["TECH", S.tech],
      ["CAPS", S.caps],
      ["POP", `${S.pop}/${housingCap()}`],
      ["RAD", `${Math.round(S.rad)}%`],
    ];
    const advanced = [
      ["MED", S.medData],
      ["BRK", S.breakthroughs],
      ["STR", S.strain]
    ];

    const pills = S.ui.pillsExpanded ? basic.concat(advanced) : basic;
    for (const [k,v] of pills) {
      const p = document.createElement("div");
      p.className = "pill";
      p.innerHTML = `${k}: <b>${typeof v === "number" ? fmt(v) : v}</b>`;
      el.appendChild(p);
    }
  }

  function renderWorkers() {
    const panel = $("workerPanel");
    if (!panel) return;
    panel.innerHTML = "";
    // ensure expansion fields are available
    ensureExpansion();

    // UI state: Economy vs War view (older saves won't have this)
    if (!S.workersTab) S.workersTab = "economy";

    // Tabs row (Economy / War)
    {
      const tabRow = document.createElement("div");
      tabRow.className = "row";
      tabRow.innerHTML = `
        <div class="label">View</div>
        <div class="value" style="display:flex; gap:8px; align-items:center; justify-content:flex-end; flex-wrap:wrap;">
          <button class="miniBtn ${S.workersTab==='economy'?'primary':''}" data-workers-tab="economy">Economy</button>
          <button class="miniBtn ${S.workersTab==='war'?'primary':''}" data-workers-tab="war">War</button>
        </div>
      `;
      panel.appendChild(tabRow);
    }

    const makeAssign = (key, title, desc) => {
      const wrap = document.createElement("div");
      wrap.className = "row";
      wrap.innerHTML = `
        <div style="min-width:0;">
          <div style="font-family:var(--mono); color:var(--accent); font-size:0.88rem;">${title}</div>
          <div style="font-family:var(--sans); color:var(--muted); font-size:0.82rem; line-height:1.25;">${desc}</div>
        </div>
        <div style="display:flex; gap:10px; align-items:center;">
          <button class="closeBtn stepBtn" data-act="minus" data-key="${key}" aria-label="Decrease ${title}">-</button>
          <span style="min-width:32px; text-align:center; font-family:var(--mono);">${S[key]}</span>
          <button class="closeBtn stepBtn" data-act="plus" data-key="${key}" aria-label="Increase ${title}">+</button>
        </div>
      `;
      panel.appendChild(wrap);
    };
    // helper to render locked roles in grey
    const makeLocked = (title, desc) => {
      const wrap = document.createElement("div");
      wrap.className = "row locked";
      wrap.innerHTML = `
        <div style="min-width:0;">
          <div style="font-family:var(--mono); color:var(--muted); font-size:0.88rem;">${title}</div>
          <div style="font-family:var(--sans); color:var(--muted); font-size:0.82rem; line-height:1.25;">${desc}</div>
        </div>
        <div style="min-width:32px; text-align:center; font-family:var(--mono);">0</div>
      `;
      panel.appendChild(wrap);
    };

    // Economy tab (civilian roles)
    if (S.workersTab === 'economy'){
      makeAssign("scav", "Scavengers", "Passive Scrap (and a little Tech with Workshop).");
      makeAssign("farmers", "Farmhands", "Passive Food (better with Farms).");
      makeAssign("purifiers", "Purifier Crew", "Passive Water (better with Purifiers).");
    }

    // War tab (militia + owned faction units)
    if (S.workersTab === 'war'){
      makeAssign("militia", "Militia", "Your baseline fighters. Used in battles.");

      // Purchased faction units appear here once bought (read-only counters)
      ensureFactions();
      const fid = S.factions.aligned;
      const owned = (S.factions.units && fid) ? (S.factions.units[fid] || 0) : 0;
      if (fid && owned > 0){
        const u = FACTIONS[fid]?.specialUnit;
        const wrap = document.createElement("div");
        wrap.className = "row";
        wrap.innerHTML = `
          <div style="min-width:0;">
            <div style="font-family:var(--mono); color:var(--accent); font-size:0.88rem;">${u?.name || 'Faction Unit'}</div>
            <div style="font-family:var(--sans); color:var(--muted); font-size:0.82rem; line-height:1.25;">${u?.desc || 'Special unit acquired from your faction shop.'}</div>
          </div>
          <div style="min-width:42px; text-align:right; font-family:var(--mono);"><span class="tag">x${owned}</span></div>
        `;
        panel.appendChild(wrap);
      }
    }

    // expansion roles (Economy tab)
    if (S.workersTab !== 'economy') return;

    // expansion roles
    // Engineers: unlocked via Workshop tech
    if (S.techs && S.techs.workshop) {
      makeAssign('engineers', 'Engineers', 'Boost all production and salvage extra Tech.');
    } else {
      makeLocked('Engineers', 'Locked (Research Workshop)');
    }
    // Medics: unlocked via Medbay tech
    if (S.techs && S.techs.medbay) {
      makeAssign('medics', 'Medics', 'Generate Medical Data and slow radiation accumulation.');
    } else {
      makeLocked('Medics', 'Locked (Research Field Medbay)');
    }
    // Researchers: unlocked by building a Research Lab
    if ((S.lab || 0) > 0) {
      makeAssign('researchers', 'Researchers', 'Discover Breakthroughs to unlock powerful upgrades.');
    } else {
      makeLocked('Researchers', 'Locked (Build Research Lab)');
    }
    // Scouts: unlocked by Annex or Command Center
    if ((S.annex || 0) > 0 || (S.cmdcenter || 0) > 0) {
      makeAssign('scouts', 'Scouts', 'Improve mission success and uncover points of interest.');
    } else {
      makeLocked('Scouts', 'Locked (Build Workshop Annex or Command Center)');
    }
    // Propagandists: unlocked by Command Center
    if ((S.cmdcenter || 0) > 0) {
      makeAssign('propagandists', 'Propagandists', 'Generate faction reputation over time.');
    } else {
      makeLocked('Propagandists', 'Locked (Build Command Center)');
    }
    // Fixers: unlocked by Logistics Depot
    if ((S.depot || 0) > 0) {
      makeAssign('fixers', 'Fixers', 'Reduce strain and prevent breakdowns.');
    } else {
      makeLocked('Fixers', 'Locked (Build Logistics Depot)');
    }
  }

  function costText(cost) {
    const keyMap = { scrap:"SCRAP", food:"FOOD", water:"WATER", tech:"TECH", caps:"CAPS", medData:"MED", breakthroughs:"BRK" };
    return Object.entries(cost)
      .map(([k,v]) => `${(keyMap[k] || k.toUpperCase())} ${v}`)
      .join(" · ");
  }

  function renderBuildings() {
    const panel = $("buildPanel");
    if (!panel) return;
    panel.innerHTML = "";
    // ensure expansion fields are available
    ensureExpansion();

    const addSection = (title, subtitle) => {
      const s = document.createElement("div");
      s.className = "section";
      s.innerHTML = `<div class="t">${title}</div><div class="s">${subtitle}</div>`;
      panel.appendChild(s);
    };

    const canAfford = (cost) => Object.entries(cost).every(([k,v]) => S[k] >= v);

    // helper to render a building purchase button with optional lock state
    const buyBtn = (name, desc, key, cost, extra="", unlocked=true, lockDesc="") => {
      const btn = document.createElement("button");
      btn.className = "btn";
      btn.dataset.buy = key;
      if (!unlocked) btn.classList.add("locked");
      if (unlocked) {
        btn.innerHTML = `
          <div class="left">
            <div class="name">${name} <span class="tag">x${S[key]}</span></div>
            <div class="desc">${desc}</div>
          </div>
          <small>${costText(cost)}${extra ? "<br/>"+extra : ""}</small>
        `;
        btn.disabled = !canAfford(cost);
      } else {
        btn.innerHTML = `
          <div class="left">
            <div class="name">${name} <span class="tag">x${S[key]}</span></div>
            <div class="desc">${lockDesc}</div>
          </div>
          <small>Locked</small>
        `;
        btn.disabled = true;
      }
      panel.appendChild(btn);
    };

    addSection("Core", "Housing & production");
    // Base buildings
    buyBtn("Tin Shack", "Adds housing for settlers.", "shack",
      { scrap: 18 + S.shack*10, caps: (S.shack < 2 ? 0 : (6 + S.shack*3)) },
      `Cap +4 (now ${housingCap()})`
    );

    buyBtn("Dust Farm", "Boosts Food production.", "farm",
      { scrap: 14 + S.farm*9, water: 6 + S.farm*3 }
    );

    buyBtn("Water Purifier", "Boosts Water production.", "purifier",
      { scrap: 22 + S.purifier*12, tech: Math.floor(S.purifier*0.7) }
    );

    addSection("Defense", "Reduce raid losses");
    buyBtn("Jury-Rigged Turret", "Big defense boost.", "turret",
      { scrap: 30 + S.turret*18, tech: 1 + Math.floor(S.turret*0.8), caps: 10 + S.turret*6 },
      `Defense +2 (now ${fmt(defenseScore())})`
    );

    addSection("Facilities", "Unlock advanced roles");
    // Expansion buildings
    // Workshop Annex: unlocked by Workshop tech
    const annexCost = { scrap: 30 + S.annex*24, tech: 6 + S.annex*2 };
    buyBtn("Workshop Annex", "Adds Engineer slots; improves Tech yield.", "annex", annexCost,
      `Unlocks Engineers`, S.techs && S.techs.workshop, "Requires Workshop tech");

    // Command Center: unlocked by Radio tech
    const cmdCost = { scrap: 40 + S.cmdcenter*28, caps: 40 + S.cmdcenter*12, tech: 8 };
    buyBtn("Command Center", "Issue global directives and hire Propagandists.", "cmdcenter", cmdCost,
      `Unlocks Directives`, S.techs && S.techs.radio, "Requires Radio Beacon");

    // Field Hospital: unlocked by Medbay tech
    const hospCost = { scrap: 48 + S.hospital*30, tech: 10 + S.hospital*3, water: 20 };
    buyBtn("Field Hospital", "Heal settlers and generate Medical Data.", "hospital", hospCost,
      `Unlocks Medics`, S.techs && S.techs.medbay, "Requires Field Medbay");

    // Black Market: unlocked by Radio tech
    const bmCost = { scrap: 70 + S.blackmarket*36, caps: 50 + S.blackmarket*20 };
    buyBtn("Black Market", "Trade resources at risky rates for windfall loot.", "blackmarket", bmCost,
      `Risk & Reward`, S.techs && S.techs.radio, "Requires Radio Beacon");

    // Research Lab: unlocked by Workshop tech
    const labCost = { scrap: 60 + S.lab*36, tech: 20 + S.lab*4, caps: 30 };
    buyBtn("Research Lab", "Unlock breakthrough discoveries.", "lab", labCost,
      `Unlocks Researchers`, S.techs && S.techs.workshop, "Requires Workshop tech");

    // Logistics Depot: unlocked by Caravan tech
    const depCost = { scrap: 55 + S.depot*32, caps: 24 + S.depot*8 };
    buyBtn("Logistics Depot", "Increase storage and reduce resource losses.", "depot", depCost,
      `Unlocks Fixers`, S.techs && S.techs.caravan, "Requires Caravan Route");
  }

  function renderTech() {
    const panel = $("techPanel");
    if (!panel) return;
    panel.innerHTML = "";

    const addSection = (title, subtitle) => {
      const s = document.createElement("div");
      s.className = "section";
      s.innerHTML = `<div class="t">${title}</div><div class="s">${subtitle}</div>`;
      panel.appendChild(s);
    };

    const techs = [
      { key: "workshop", name: "Workshop Bench", desc: "Scavengers trickle Tech; +housing bonus.", cost: { tech: 6, scrap: 40, caps: 20 } },
      { key: "radio", name: "Radio Beacon", desc: "Recruiting cheaper; raids yield more.", cost: { tech: 10, scrap: 60, caps: 35 } },
      { key: "medbay", name: "Field Medbay", desc: "Radiation rises slower; decon stronger.", cost: { tech: 14, scrap: 80, water: 35 } },
      { key: "caravan", name: "Caravan Route", desc: "Passive Caps based on population.", cost: { tech: 18, scrap: 90, food: 60 } },
    ];

    const canAfford = (cost) => Object.entries(cost).every(([k,v]) => S[k] >= v);

    for (const t of techs) {
      if (t.key === "workshop") addSection("Core", "Unlock roles & facilities");
      if (t.key === "medbay") addSection("Survival", "Radiation & healing");
      if (t.key === "caravan") addSection("Economy", "Caps flow");
      const owned = !!S.techs[t.key];
      const btn = document.createElement("button");
      btn.className = "btn";
      btn.dataset.tech = t.key;
      btn.innerHTML = `
        <div class="left">
          <div class="name">${t.name} ${owned ? '<span class="tag">OWNED</span>' : ""}</div>
          <div class="desc">${t.desc}</div>
        </div>
        <small>${owned ? "—" : costText(t.cost)}</small>
      `;
      btn.disabled = owned || !canAfford(t.cost);
      panel.appendChild(btn);
    }
  }

    function renderFactions(){
    // Ensure required structures
    ensureFactions();
    ensureExpansion();
    const sum = $("factionSummary");
    const panel = $("factionPanel");
    if (!sum || !panel) return;
    sum.innerHTML = "";
    panel.innerHTML = "";

    const sponsor = S.factions.active;
    const b = activeFactionBonus();
    const cdLeft = Math.max(0, (S.factions.cooldownUntil||0) - now());
    const cdTxt = cdLeft > 0 ? ` · Swap in ${fmtTime(cdLeft)}` : "";

    // Summary rows
    const rowSponsor = document.createElement("div");
    rowSponsor.className = "row";
    rowSponsor.innerHTML =
      '<div class="label">Sponsor</div>' +
      '<div class="value">' + (sponsor ? (FACTIONS[sponsor]?.name || sponsor) : 'None') + ' ' +
      '<span class="tag">' + (sponsor ? rankName(S.factions.rank[sponsor]||0) : 'Neutral') + '</span>' +
      '<span class="tag">' + (cdLeft>0 ? 'Cooldown' : 'Ready') + '</span>' + '</div>';
    sum.appendChild(rowSponsor);

    // Build a string for current bonus text separately to avoid nested template literals
    let bonusText = '';
    if (sponsor) {
      bonusText = 'Defense +' + fmt(b.defFlat||0) + ' · Prod x' + fmt(b.prod||1) + ' · Caps x' + fmt(b.caps||1) + ' · RAD x' + fmt(1/(b.radRes||1)) + ' · Loot x' + fmt(b.loot||1);
    }
    const rowBonus = document.createElement('div');
    rowBonus.className = 'row';
    rowBonus.innerHTML =
      '<div class="label">Bonuses</div>' +
      '<div class="value">' + (bonusText || '—') + ' <span class="tag">Streak ' + (S.factions.streak||0) + '/5</span></div>';
    sum.appendChild(rowBonus);

    // If permanently aligned with a faction, show its currency in the summary
    if (S.factions.aligned) {
      const currId = S.factions.aligned;
      const currName = FACTIONS[currId]?.currencyName || 'Currency';
      const amt = S.factions.currency ? (S.factions.currency[currId] || 0) : 0;
      const rowCurr = document.createElement('div');
      rowCurr.className = 'row';
      rowCurr.innerHTML = '<div class="label">' + currName + '</div><div class="value">' + amt + '</div>';
      sum.appendChild(rowCurr);
    }

    // Contracts removed — faction loop now feeds the core game via Donations + Battle Paths + Shop.

    // Faction cards list
    // If permanently aligned, only show the chosen faction
    const ids = S.factions.aligned ? [S.factions.aligned] : Object.keys(FACTIONS);
    for (const id of ids){
      const f = FACTIONS[id];
      const rep = clamp(S.factions.rep[id] || 0, 0, 100);
      const rank = clamp(S.factions.rank[id] || rankForRep(rep), 0, 3);
      const isSponsor = (sponsor === id);
      // streak
      const streakActive = (S.factions.streakId === id) ? (S.factions.streak||0) : 0;
      const streakMult = 1 + Math.max(0, streakActive-1) * 0.05;
      // next bonus text
      let nextText = '';
      {
        const currBon = f.bonusesByRank[rank] || { defFlat:0, prod:1, caps:1, radRes:1, loot:1 };
        const nextBon = f.bonusesByRank[rank+1];
        if (nextBon){
          const diffs = [];
          const deltaDef = nextBon.defFlat - currBon.defFlat;
          if (Math.abs(deltaDef) > 0.0001) diffs.push('DEF ' + (deltaDef>=0?'+':'') + fmt(deltaDef));
          const deltaProd = nextBon.prod - currBon.prod;
          if (Math.abs(deltaProd) > 0.0001) diffs.push('PROD ' + (deltaProd>=0?'+':'') + (((deltaProd)*100).toFixed(1)) + '%');
          const deltaCaps = nextBon.caps - currBon.caps;
          if (Math.abs(deltaCaps) > 0.0001) diffs.push('CAPS ' + (deltaCaps>=0?'+':'') + (((deltaCaps)*100).toFixed(1)) + '%');
          const deltaRad = nextBon.radRes - currBon.radRes;
          if (Math.abs(deltaRad) > 0.0001) diffs.push('RADRES ' + (deltaRad>=0?'+':'') + (((deltaRad)*100).toFixed(1)) + '%');
          const deltaLoot = nextBon.loot - currBon.loot;
          if (Math.abs(deltaLoot) > 0.0001) diffs.push('LOOT ' + (deltaLoot>=0?'+':'') + (((deltaLoot)*100).toFixed(1)) + '%');
          nextText = diffs.length ? 'Next: ' + diffs.join(' · ') : '';
        } else {
          nextText = 'Max rank achieved';
        }
      }
      // Donations: scaled costs + short cooldown so it's not infinite spam.
      const dp = donatePlan(id);
      const canDonate = canDonateFaction(id);
      const donateCostLine = dp ? Object.entries(dp.cost).map(([k,v])=>`${k.toUpperCase()} ${v}`).join(' · ') : '';
      const donateText = dp
        ? (dp.cooldownLeft>0 ? `Donate (${fmtTime(dp.cooldownLeft)})` : `Donate (${donateCostLine})`)
        : 'Donate';
      // compute swap text separately to avoid nested template strings
      const swapText = cdLeft>0 ? ('Swap locked' + cdTxt) : 'Swap ready';
      // compute sponsor note if another faction is active
      const sponsorNote = (sponsor && sponsor !== id) ? '<div class="lockHint">You can still run jobs for any faction. Sponsor only affects passive bonuses.</div>' : '';
      // card element
      const card = document.createElement('div');
      card.className = 'facCard';
      // Build inner HTML using concatenation to avoid nested template syntax
      card.innerHTML =
        '<div class="facHead">' +
          '<span class="facName">' + f.name + '</span>' +
          '<span class="tag">' + rankName(rank) + '</span>' +
          (isSponsor ? '<span class="tag">SPONSOR</span>' : '') +
        '</div>' +
        '<div class="bar mini"><div class="barFill" style="width:' + rep + '%"></div></div>' +
        '<div class="facSub">' +
          '<span class="tag">REP ' + Math.round(rep) + '/100</span>' +
          '<span class="tag">' + f.tag + '</span>' +
          '<span class="tag">Streak ' + streakActive + '/5</span>' +
          '<span class="tag">Loot x' + fmt(streakMult) + '</span>' +
          '<span class="tag">' + swapText + '</span>' +
        '</div>' +
        '<div class="facDesc">' + f.desc + '</div>' +
        '<div class="facActions">' +
          (S.factions.aligned ? '' : ('<button class="fbtn2 ' + (isSponsor ? 'danger' : 'primary') + '" data-fact-act="' + (isSponsor ? 'leave' : 'ally') + '" data-fact-id="' + id + '" ' + (((!isSponsor && rep<20) || (!isSponsor && cdLeft>0)) ? 'disabled' : '') + '>' +
            (isSponsor ? 'End Sponsorship' : (rep>=20 ? 'Become Sponsor' : 'Sponsor (REP 20+)')) +
          '</button>')) +
          '<div class="miniRow">' +
            '<button class="miniBtn secondary" data-fact-act="donate" data-fact-id="' + id + '" ' + (canDonate ? '' : 'disabled') + '>' + donateText + '</button>' +
          '</div>' +
        '</div>' +
        sponsorNote;
      // Append card
      panel.appendChild(card);

      // Faction shop button (aligned only)
      if (S.factions.aligned && S.factions.aligned === id) {
        const shopRow = document.createElement("div");
        shopRow.className = "row";
        shopRow.innerHTML = `
          <div class="label">Faction</div>
          <div class="value" style="display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end;">
            <span class="tag">${FACTIONS[id].currencyName}: ${(S.factions.currency && (S.factions.currency[id]||0)) || 0}</span>
            <button class="miniBtn primary" data-fact-act="shop" data-fact-id="${id}">Faction Shop</button>
          </div>
        `;
        panel.appendChild(shopRow);
      }

    }

  }

  function renderStatsAndLog() {
    const rows = $("statRows");
    if (!rows) return;
    const prod = productionPerSec();
    rows.innerHTML = "";

    const data = [
      ["Idle Settlers", S.idle, "Unassigned workers"],
      ["Scavengers", S.scav, "Auto-gather Scrap"],
      ["Farmhands", S.farmers, "Auto-grow Food"],
      ["Purifier Crew", S.purifiers, "Auto-produce Water"],
      ["Militia", S.militia, "Defense + raids"],
      ["Buildings", `Shacks ${S.shack} · Farms ${S.farm} · Purifiers ${S.purifier} · Turrets ${S.turret} · Annex ${S.annex} · Cmd ${S.cmdcenter} · Hosp ${S.hospital} · Market ${S.blackmarket} · Lab ${S.lab} · Depot ${S.depot}`, "Counts"],
      ["Defense Power", fmt(defensePower()), "Higher = safer raids"],
      ["Net/sec", `+${fmt(prod.scavRate)} Scrap · ${fmt(prod.foodRate - prod.foodUse)} Food · ${fmt(prod.waterRate - prod.waterUse)} Water · +${fmt(prod.techRate)} Tech · +${fmt(prod.capsRate)} Caps`, "After consumption"],
      ["Faction", (S.factions && S.factions.active) ? (FACTIONS[S.factions.active]?.name || S.factions.active) : "None", "One active ally"],
      ["Daily Quest", questStatusText(), "Resets every 24h"],
      ["Prestige", `Lv ${S.prestige?.level||0} · Tokens ${S.prestige?.tokens||0}`, "Permanent bonuses"],
    ];

    for (const [label, val, tip] of data) {
      const r = document.createElement("div");
      r.className = "row";
      r.innerHTML = `<div class="label">${label}</div><div class="value">${val} <span class="tag">${tip}</span></div>`;
      rows.appendChild(r);
    }
  }


  // ---------- Battle (new system): Campaign Paths ----------
  // Design: choose a Path (alignment style) then clear tiered missions. Battles resolve instantly
  // using unit stats (ATK/DEF/HP) rather than a "fake" timer.

  const UNIT_DEFS = {
    militia: { name: "Militia", atk: 2, def: 2, hp: 5, tag: "Infantry" },
    // Faction special units (bought in the faction shop)
    bos_unit: { name: "BoS Paladin Knight", atk: 6, def: 5, hp: 10, tag: "Elite" },
    ncr_unit: { name: "NCR Ranger", atk: 5, def: 4, hp: 9, tag: "Elite" },
    followers_unit: { name: "Field Medic", atk: 2, def: 3, hp: 8, tag: "Support" },
    raiders_unit: { name: "Raider Brute", atk: 5, def: 3, hp: 8, tag: "Infantry" },
    enclave_unit: { name: "Enclave Trooper", atk: 6, def: 6, hp: 11, tag: "Elite" },
  };

  const PATHS = {
    lawful: {
      name: "Lawful",
      flavor: "Order. Contracts. Clean victories.",
      factionHint: "NCR",
      tiers: [
        { tier: 1, name: "Clear a roadblock", enemy: { atk: 8, def: 6, hp: 18 }, req: { units: 3 }, reward: { caps: 10, rep: 1 } },
        { tier: 2, name: "Break a smuggler ring", enemy: { atk: 15, def: 12, hp: 32 }, req: { units: 6 }, reward: { caps: 20, rep: 2 } },
        { tier: 3, name: "Secure a checkpoint", enemy: { atk: 26, def: 20, hp: 50 }, req: { units: 10 }, reward: { caps: 35, rep: 3 } },
        { tier: 4, name: "Liberate a settlement", enemy: { atk: 40, def: 30, hp: 80 }, req: { units: 16 }, reward: { caps: 55, rep: 4 } },
        { tier: 5, name: "Establish NCR control", enemy: { atk: 60, def: 46, hp: 120 }, req: { units: 24 }, reward: { caps: 80, rep: 5 } },
      ]
    },
    militaristic: {
      name: "Militaristic",
      flavor: "Steel. Discipline. High-stakes offensives.",
      factionHint: "Brotherhood",
      tiers: [
        { tier: 1, name: "Purge feral ghouls", enemy: { atk: 9, def: 7, hp: 20 }, req: { units: 3 }, reward: { scrap: 10, rep: 1 } },
        { tier: 2, name: "Recover pre-war tech", enemy: { atk: 17, def: 13, hp: 35 }, req: { units: 6 }, reward: { tech: 1, rep: 2 } },
        { tier: 3, name: "Assault a bunker", enemy: { atk: 30, def: 23, hp: 58 }, req: { units: 10 }, reward: { scrap: 25, rep: 3 } },
        { tier: 4, name: "Crush a warband", enemy: { atk: 46, def: 35, hp: 92 }, req: { units: 16 }, reward: { tech: 1, rep: 4 } },
        { tier: 5, name: "Secure a relic site", enemy: { atk: 70, def: 52, hp: 140 }, req: { units: 24 }, reward: { tech: 2, rep: 5 } },
      ]
    },
    ruthless: {
      name: "Ruthless",
      flavor: "Fear. Fire. Taking what you want.",
      factionHint: "Raiders",
      tiers: [
        { tier: 1, name: "Ambush a lone traveler", enemy: { atk: 7, def: 5, hp: 16 }, req: { units: 3 }, reward: { scrap: 12, rep: 1 } },
        { tier: 2, name: "Raid a small camp", enemy: { atk: 14, def: 10, hp: 30 }, req: { units: 6 }, reward: { scrap: 20, rep: 2 } },
        { tier: 3, name: "Sack a fortified settlement", enemy: { atk: 26, def: 18, hp: 56 }, req: { units: 10 }, reward: { scrap: 35, rep: 3 } },
        { tier: 4, name: "Capture a regional hub", enemy: { atk: 42, def: 28, hp: 86 }, req: { units: 16 }, reward: { scrap: 55, rep: 4 } },
        { tier: 5, name: "Establish Raider Dominion", enemy: { atk: 64, def: 44, hp: 130 }, req: { units: 24 }, reward: { scrap: 85, rep: 5 } },
      ]
    },
    humanitarian: {
      name: "Humanitarian",
      flavor: "Aid. Evacuation. Winning without becoming a monster.",
      factionHint: "Followers",
      tiers: [
        { tier: 1, name: "Escort refugees", enemy: { atk: 8, def: 6, hp: 18 }, req: { units: 3 }, reward: { medData: 3, rep: 1 } },
        { tier: 2, name: "Recover medical supplies", enemy: { atk: 15, def: 12, hp: 32 }, req: { units: 6 }, reward: { medData: 6, rep: 2 } },
        { tier: 3, name: "Break a siege", enemy: { atk: 26, def: 20, hp: 50 }, req: { units: 10 }, reward: { medData: 10, rep: 3 } },
        { tier: 4, name: "Stabilize a plague town", enemy: { atk: 40, def: 30, hp: 80 }, req: { units: 16 }, reward: { medData: 16, rep: 4 } },
        { tier: 5, name: "Found a regional clinic", enemy: { atk: 60, def: 46, hp: 120 }, req: { units: 24 }, reward: { medData: 24, rep: 5 } },
      ]
    }
  };

  function ensureBattle(){
    if (!S.battle){
      S.battle = {
        path: null,
        tier: 1,
        deploy: { militia: 0, faction: 0 },
        prog: { lawful: 0, militaristic: 0, ruthless: 0, humanitarian: 0 },
        // Rolling after-action reports (replaces the old "Last Mission" line)
        history: []
      };
    }
    // Back-compat for saves created before history existed
    if (!Array.isArray(S.battle.history)) S.battle.history = [];
  }

  function battleFlavor(pathKey, win){
    const pools = {
      lawful: {
        win: [
          "Rangers secure the perimeter and civilians return to the roads.",
          "The outpost files a clean report. Order restored.",
          "A checkpoint falls into compliant hands. Supplies flow again."
        ],
        lose: [
          "The target slips the net. Paperwork and body bags.",
          "Your unit breaks formation under crossfire. Retreat ordered.",
          "Smugglers vanish into the dunes. The road stays dangerous."
        ]
      },
      militaristic: {
        win: [
          "Power armor advances without hesitation. Resistance collapses.",
          "A decisive strike. Technology secured.",
          "The enemy line shatters under disciplined fire."
        ],
        lose: [
          "Hostiles exploit terrain. The squad falls back to regroup.",
          "The mission stalls — ammunition low, wounded mounting.",
          "Your force is outmaneuvered. Tactical withdrawal."
        ]
      },
      ruthless: {
        win: [
          "Fear does the rest. The camp is stripped bare.",
          "A brutal lesson spreads fast. Tribute follows.",
          "No prisoners. No delays. The haul is yours."
        ],
        lose: [
          "The mark fights back harder than expected. You scatter.",
          "Ambush turns on you. Survivors limp home.",
          "The raid collapses into chaos. Loot abandoned."
        ]
      },
      humanitarian: {
        win: [
          "You stabilize the wounded and secure the area.",
          "A calm extraction. Lives saved, violence minimized.",
          "Your medics hold the line long enough for evacuation."
        ],
        lose: [
          "You pull back to prevent a massacre. Triage begins.",
          "The situation spirals. You retreat to protect the vulnerable.",
          "Supplies run thin. You disengage before it becomes a slaughter."
        ]
      }
    };
    const p = pools[pathKey] || pools.militaristic;
    const arr = win ? p.win : p.lose;
    return arr[Math.floor(Math.random()*arr.length)];
  }

  function addBattleHistory(entry){
    ensureBattle();
    if (!Array.isArray(S.battle.history)) S.battle.history = [];
    S.battle.history.push(entry);
    // cap to keep UI light
    if (S.battle.history.length > 20) S.battle.history = S.battle.history.slice(-20);
  }

  // Legacy compatibility: older saves / code paths referenced timed "ops".
  // The new battle system doesn't use timers, but we keep this as a no-op so nothing crashes.
  function checkOps(){ /* deprecated */ }

  function alignedPath(){
    const a = S.factions?.aligned || null;
    if (a === "ncr") return "lawful";
    if (a === "bos") return "militaristic";
    if (a === "raiders") return "ruthless";
    if (a === "followers") return "humanitarian";
    // enclave doesn't map cleanly to the four; default to militaristic for now
    if (a === "enclave") return "militaristic";
    return null;
  }

  function ownedFactionUnitKey(){
    const a = S.factions?.aligned || null;
    if (!a) return null;
    return `${a}_unit`;
  }

  function ownedFactionUnitCount(){
    const a = S.factions?.aligned || null;
    if (!a) return 0;
    return (S.factions?.units?.[a] || 0) | 0;
  }

  function totalUnitStats(mil, fac){
    const m = UNIT_DEFS.militia;
    const facKey = ownedFactionUnitKey();
    const f = facKey ? (UNIT_DEFS[facKey] || null) : null;
    const atk = mil * m.atk + (f ? fac * f.atk : 0);
    const def = mil * m.def + (f ? fac * f.def : 0);
    const hp  = mil * m.hp  + (f ? fac * f.hp  : 0);
    return { atk, def, hp };
  }

  function missionDef(pathKey, tier){
    const p = PATHS[pathKey];
    return (p && p.tiers) ? (p.tiers.find(t => t.tier === tier) || null) : null;
  }

  function previewRewardLine(pathKey, tier){
    const d = missionDef(pathKey, tier);
    if (!d || !d.reward) return "None";
    const parts = Object.entries(d.reward)
      .filter(([k,v]) => k !== "rep" && v)
      .map(([k,v]) => `+${v} ${k.toUpperCase()}`);
    return parts.length ? parts.join(" · ") : "None";
  }

  // CivCrafter-style: prep in a popup, then run.
  function showMissionPrepModal(){
    ensureBattle();
    ensureExpansion();
    const pKey = S.battle.path;
    if (!pKey){ toast("Choose a battle path first.", "warn"); return; }
    const cleared = S.battle.prog[pKey] || 0;
    const nextTier = clamp(cleared + 1, 1, 5);
    const tier = clamp(S.battle.tier || nextTier, 1, nextTier);
    S.battle.tier = tier;
    const def = missionDef(pKey, tier);
    if (!def){ toast("Mission not found.", "warn"); return; }

    const facKey = ownedFactionUnitKey();
    const facUnit = facKey ? UNIT_DEFS[facKey] : null;
    const maxMil = S.militia|0;
    const maxFac = ownedFactionUnitCount();

    if (!S.battle.deploy) S.battle.deploy = { militia: 0, faction: 0 };
    S.battle.deploy.militia = clamp(S.battle.deploy.militia|0, 0, maxMil);
    S.battle.deploy.faction = clamp(S.battle.deploy.faction|0, 0, maxFac);

    const enemyPower = Math.round(def.enemy.atk + def.enemy.def + (def.enemy.hp*0.6));

    showModal("Prepare Mission", `
      <div class="rows animIn" id="prepWrap">
        <div class="row"><div class="label">Objective</div><div class="value"><b>${escapeHtml(PATHS[pKey].name)}</b> · Tier ${tier}: ${escapeHtml(def.name)} <span class="tag">Next</span></div></div>
        <div class="row"><div class="label">Requirement</div><div class="value">Deploy <b>${def.req.units}</b> units <span class="tag">Militia + Elites</span></div></div>
        <div class="row"><div class="label">Enemy</div><div class="value"><span class="chip warn">Power <b>${enemyPower}</b></span> ${statChipsHTML(def.enemy.atk, def.enemy.def, def.enemy.hp)}</div></div>
        <div class="divider"></div>

        <div class="row">
          <div style="min-width:0;">
            <div class="label">Militia</div>
            <div class="miniHint">ATK ${UNIT_DEFS.militia.atk} · DEF ${UNIT_DEFS.militia.def} · HP ${UNIT_DEFS.militia.hp}</div>
          </div>
          <div style="display:flex; gap:10px; align-items:center;">
            <button class="closeBtn stepBtn" id="prepMilMinus">-</button>
            <span class="tag" id="prepMilVal" style="min-width:52px; text-align:center;">${S.battle.deploy.militia}/${maxMil}</span>
            <button class="closeBtn stepBtn" id="prepMilPlus">+</button>
          </div>
        </div>

        <div class="row">
          <div style="min-width:0;">
            <div class="label">${facUnit ? escapeHtml(facUnit.name) : "Faction Unit"}</div>
            <div class="miniHint">${facUnit ? `ATK ${facUnit.atk} · DEF ${facUnit.def} · HP ${facUnit.hp} · ${escapeHtml(facUnit.tag)}` : "Buy your faction unit in the Faction Shop."}</div>
          </div>
          <div style="display:flex; gap:10px; align-items:center;">
            <button class="closeBtn stepBtn" id="prepFacMinus" ${facUnit ? "" : "disabled"}>-</button>
            <span class="tag" id="prepFacVal" style="min-width:52px; text-align:center;">${S.battle.deploy.faction}/${maxFac}</span>
            <button class="closeBtn stepBtn" id="prepFacPlus" ${facUnit ? "" : "disabled"}>+</button>
          </div>
        </div>

        <div class="row" id="prepPreview"></div>

        <button class="btn" id="prepRun" disabled>
          <div class="left"><div class="name">Run Mission</div><div class="desc">Commit your forces and resolve the battle</div></div>
          <small id="prepHint">Need units</small>
        </button>
      </div>
    `);

    function refreshPrep(){
      const mil = clamp(S.battle.deploy.militia|0, 0, maxMil);
      const fac = clamp(S.battle.deploy.faction|0, 0, maxFac);
      S.battle.deploy.militia = mil; S.battle.deploy.faction = fac;
      if ($("prepMilVal")) $("prepMilVal").textContent = `${mil}/${maxMil}`;
      if ($("prepFacVal")) $("prepFacVal").textContent = `${fac}/${maxFac}`;
      const deployed = mil + fac;
      const you = totalUnitStats(mil, fac);
      const youPower = Math.round(you.atk + you.def + (you.hp*0.6));
      const enPower  = enemyPower;
      const ok = deployed >= def.req.units && deployed > 0;
      const prev = $("prepPreview");
      if (prev){
        prev.innerHTML = `
          <div class="label">Preview</div>
          <div class="value">
            <span class="chip good">Your Power <b>${youPower}</b></span>
            <span class="chip warn">Enemy Power <b>${enPower}</b></span>
            <span class="tag">Deployed ${deployed}/${def.req.units}</span>
          </div>
        `;
      }
      const run = $("prepRun");
      const hint = $("prepHint");
      if (run) run.disabled = !ok;
      if (hint) hint.textContent = ok ? "GO" : `Need ${Math.max(0, def.req.units - deployed)} more`;
    }

    setTimeout(() => {
      const milMinus = $("prepMilMinus");
      const milPlus  = $("prepMilPlus");
      const facMinus = $("prepFacMinus");
      const facPlus  = $("prepFacPlus");
      if (milMinus) milMinus.onclick = () => { S.battle.deploy.militia = (S.battle.deploy.militia|0) - 1; refreshPrep(); queueSave(); };
      if (milPlus)  milPlus.onclick  = () => { S.battle.deploy.militia = (S.battle.deploy.militia|0) + 1; refreshPrep(); queueSave(); };
      if (facMinus) facMinus.onclick = () => { S.battle.deploy.faction = (S.battle.deploy.faction|0) - 1; refreshPrep(); queueSave(); };
      if (facPlus)  facPlus.onclick  = () => { S.battle.deploy.faction = (S.battle.deploy.faction|0) + 1; refreshPrep(); queueSave(); };

      const run = $("prepRun");
      if (run) run.onclick = () => {
        const mil = clamp(S.battle.deploy?.militia|0, 0, maxMil);
        const fac = clamp(S.battle.deploy?.faction|0, 0, maxFac);
        if ((mil + fac) < def.req.units){ toast(`Need ${def.req.units} units deployed.`, "warn"); return; }

        // Start sim overlay, then resolve + outcome popup.
        closeModal();
        const youStats = totalUnitStats(mil, fac);
        playBattleSim({ title: PATHS[pKey].name, subtitle: `Tier ${tier}: ${def.name}`, you: youStats, enemy: def.enemy });

        setTimeout(() => {
          const res = resolveMission(pKey, tier, mil, fac);
          if (!res){ toast("Mission failed to resolve.", "warn"); return; }
          applyMissionResult(pKey, tier, mil, fac, res);

          const rewardLine = res.win
            ? (Object.entries(res.reward||{})
                .filter(([k,v])=>k!=="rep" && v)
                .map(([k,v])=>`+${v} ${k.toUpperCase()}`)
                .join(" · ") || "none")
            : "none";

          const title = `${PATHS[pKey].name} — Tier ${tier}: ${def.name}`;
          const flavor = battleFlavor(pKey, res.win);
          addBattleHistory({ ts: now(), win: res.win, title, flavor, deployed: mil+fac, ratio: res.ratio, milLost: res.milLost, facLost: res.facLost, rewardLine });
          showBattleOutcomePopup({ pathKey: pKey, tier, def, mil, fac, res });

          UI.battleDirty = true;
          renderLight();
          queueSave();
        }, 1300);
      };

      refreshPrep();
    }, 0);
  }

  // Deterministic-ish resolution: no dice for win/loss; casualties scale with how close it was.
  function resolveMission(pathKey, tier, mil, fac){
    const d = missionDef(pathKey, tier);
    if (!d) return null;
    const you = totalUnitStats(mil, fac);
    const e = d.enemy;

    // Power score weights: ATK & DEF matter, HP provides staying power.
    const youScore = (you.atk * 1.05) + (you.def * 1.0) + (you.hp * 0.55);
    const enScore  = (e.atk   * 1.05) + (e.def   * 1.0) + (e.hp   * 0.55);
    const ratio = youScore / Math.max(1, enScore);

    const win = ratio >= 1.0;

    // Losses: if you barely win, you still lose some. If you lose, losses are harsher.
    // Keep simple: only militia die first; faction units are rarer and lose at 1/4 the rate.
    let milLost = 0;
    let facLost = 0;
    const totalUnits = Math.max(1, mil + fac);

    if (win){
      // 8%..36% losses depending on margin (wins should still cost something when close)
      const closeness = clamp(1.25 - ratio, 0, 1.0); // 0 when strong win, up to 1 when barely
      const lossFrac = 0.08 + 0.28 * closeness;
      let losses = Math.round(totalUnits * lossFrac);
      // If it was a very close win, guarantee at least 1 casualty for immersion.
      if (ratio < 1.08) losses = Math.max(1, losses);
      losses = clamp(losses, 0, totalUnits);

      // Allocate: faction losses are rare on wins
      facLost = Math.min(fac, Math.floor(losses * 0.15));
      milLost = Math.min(mil, Math.max(0, losses - facLost));
    } else {
      // 30%..85% losses depending on how badly you lose (defeats should hurt)
      const badness = clamp(1.0 - ratio, 0, 1.0);
      const lossFrac = 0.30 + 0.55 * badness;
      let losses = Math.round(totalUnits * lossFrac);
      // Always at least 1 loss on a defeat when you deployed units.
      losses = Math.max(1, clamp(losses, 1, totalUnits));

      facLost = Math.min(fac, Math.floor(losses * 0.25));
      milLost = Math.min(mil, Math.max(0, losses - facLost));
    }

    // If we calculated losses but none landed on militia (common early-game rounding),
    // push 1 loss onto militia (unless you sent only faction units).
    if ((mil + fac) > 0 && (milLost + facLost) > 0 && milLost === 0 && mil > 0){
      milLost = 1;
      // keep total losses roughly consistent
      if (facLost > 0) facLost = Math.max(0, facLost - 1);
    }

    return { win, you, enemy: e, ratio, milLost, facLost, reward: d.reward };
  }

  function applyMissionResult(pathKey, tier, mil, fac, result){
    // Remove losses from global pools.
    if (result.milLost > 0){
      S.militia = Math.max(0, S.militia - result.milLost);
      S.pop = Math.max(0, S.pop - result.milLost);
    }
    const a = S.factions?.aligned || null;
    if (a && result.facLost > 0){
      if (!S.factions.units) S.factions.units = {};
      S.factions.units[a] = Math.max(0, (S.factions.units[a]||0) - result.facLost);
    }

    // Rewards on win only
    if (result.win){
      const r = result.reward || {};
      if (r.scrap) S.scrap += r.scrap;
      if (r.food) S.food += r.food;
      if (r.water) S.water += r.water;
      if (r.tech) S.tech += r.tech;
      if (r.caps) S.caps += r.caps;
      if (r.medData) S.medData = (S.medData||0) + r.medData;

      // Tier progression
      ensureBattle();
      S.battle.prog[pathKey] = Math.max(S.battle.prog[pathKey]||0, tier);

      // Faction rep drip if aligned & thematic
      if (S.factions?.aligned){
        const map = { lawful:"ncr", militaristic:"bos", ruthless:"raiders", humanitarian:"followers" };
        const fid = map[pathKey] || null;
        if (fid) {
          if (!S.factions.rep) S.factions.rep = { bos:0,ncr:0,followers:0,raiders:0,enclave:0 };
          S.factions.rep[fid] = (S.factions.rep[fid]||0) + (r.rep||1);
        }
      }
    }
  }

  // Battle UI cache (prevents the after-action log from blinking on every render)
  let _battleHistKey = null;

  function renderBattle(){
    ensureBattle();
    ensureExpansion();

    const stats = $("battleStats");
    const pathSelect = $("battlePathSelect");
    const tierList = $("battleTierList");
    const deploy = $("battleDeploy");
    const launchBtn = $("btnLaunchMission");
    const descEl = $("missionDesc");
    const hintEl = $("missionHint");
    const report = $("battleReport");
    if (!stats || !pathSelect || !tierList || !deploy || !launchBtn || !descEl || !hintEl || !report) return;

    const forcedPath = alignedPath();
    if (forcedPath && S.battle.path !== forcedPath) {
      S.battle.path = forcedPath;
      S.battle.tier = 1;
      S.battle.deploy = { militia: 0, faction: 0 };
    }

    const pKey = S.battle.path;
    const p = pKey ? PATHS[pKey] : null;
    const tier = S.battle.tier || 1;

    // Stats summary (CivCrafter-style: compact chips)
    stats.innerHTML = "";
    const facName = S.factions?.aligned ? (FACTIONS[S.factions.aligned]?.name || S.factions.aligned) : "Unaligned";
    const yourFac = ownedFactionUnitCount();
    const cleared = pKey ? (S.battle.prog[pKey]||0) : 0;

    const top = document.createElement("div");
    top.className = "row";
    top.innerHTML = `
      <div class="label">Status</div>
      <div class="value">
        <div class="bPills">
          <span class="chip">${escapeHtml(facName)}</span>
          <span class="chip">Militia <b>${S.militia|0}</b></span>
          <span class="chip">Elites <b>${yourFac}</b></span>
          <span class="chip good">Progress <b>${cleared}/5</b></span>
        </div>
      </div>
    `;
    stats.appendChild(top);

    // Path selector (CivCrafter-like: compact "battle style" strip)
    pathSelect.innerHTML = "";
    const mapFactionToPath = { ncr:"lawful", bos:"militaristic", raiders:"ruthless", followers:"humanitarian", enclave:"militaristic" };
    const aligned = S.factions?.aligned || null;
    const allowed = aligned ? new Set([mapFactionToPath[aligned] || "militaristic"]) : null;

    const pathTitle = document.createElement("div");
    pathTitle.className = "row";
    pathTitle.innerHTML = `<div class="label">Battle Style</div><div class="value">Pick how you fight. <span class="tag">Locks to your faction</span></div>`;
    pathSelect.appendChild(pathTitle);

    const strip = document.createElement("div");
    strip.className = "row";
    strip.innerHTML = `<div class="label">Styles</div><div class="value"><div class="miniBtns" id="pathStrip"></div></div>`;
    pathSelect.appendChild(strip);

    const stripEl = strip.querySelector("#pathStrip");
    for (const key of ["lawful","militaristic","ruthless","humanitarian"]){
      const def = PATHS[key];
      const locked = allowed && !allowed.has(key);
      const btn = document.createElement("button");
      btn.className = "miniBtn" + (S.battle.path === key ? " primary" : "");
      btn.dataset.path = key;
      btn.disabled = !!locked;
      btn.textContent = def.name;
      btn.title = `${def.flavor} (${def.factionHint})`;
      if (stripEl) stripEl.appendChild(btn);
    }

    // CivCrafter-style campaign panel: show a 5-step track + only the next objective to run.
    tierList.innerHTML = "";
    deploy.innerHTML = "";
    // Hide the old inline deploy + launch UI (we run missions from a prep popup now)
    deploy.style.display = "none";
    launchBtn.style.display = "none";

    const mDef = (pKey ? missionDef(pKey, tier) : null);

    if (!p){
      const r = document.createElement("div");
      r.className = "row";
      r.innerHTML = `<div class="label">Campaign</div><div class="value">Choose a battle path to start a campaign. <span class="tag">Pick a style</span></div>`;
      tierList.appendChild(r);
      descEl.textContent = "Choose a battle path";
      hintEl.textContent = "";
    } else {
      const cleared = S.battle.prog[pKey] || 0;
      const nextTier = clamp(cleared + 1, 1, 5);
      // If player had an invalid tier selected (e.g. locked), snap to next.
      if (tier > nextTier) S.battle.tier = nextTier;

      const tDef = missionDef(pKey, S.battle.tier || nextTier);
      const enemyPower = Math.round(tDef.enemy.atk + tDef.enemy.def + (tDef.enemy.hp*0.6));

      // CivCrafter-style: a simple 5-step campaign checklist.
      // Only the next tier has an action button; completed tiers show DONE; future tiers are locked.
      const header = document.createElement("div");
      header.className = "row";
      header.innerHTML = `
        <div class="label">Campaign</div>
        <div class="value">
          <span class="chip">${escapeHtml(PATHS[pKey].name)}</span>
          <span class="chip good">Cleared <b>${cleared}</b>/5</span>
          <div class="miniHint" style="margin-top:6px;">Progress through tiers in order — like a mission track.</div>
        </div>
      `;
      tierList.appendChild(header);

      for (let i=1;i<=5;i++){
        const defI = missionDef(pKey, i);
        const done = i <= cleared;
        const next = i === nextTier;
        const locked = i > nextTier;
        const ePow = Math.round(defI.enemy.atk + defI.enemy.def + (defI.enemy.hp*0.6));
        const row = document.createElement("div");
        row.className = "row";
        row.innerHTML = `
          <div style="min-width:0;">
            <div style="font-family:var(--mono); color:var(--accent);">Tier ${i}: ${escapeHtml(defI.name)}</div>
            <div class="miniHint" style="margin-top:4px;">${escapeHtml(defI.flavor || PATHS[pKey].flavor)}</div>
            <div style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap;">
              <span class="chip">Need <b>${defI.req.units}</b> units</span>
              <span class="chip warn">Enemy <b>${ePow}</b></span>
              <span class="chip">Reward <b>${escapeHtml(previewRewardLine(pKey, i))}</b></span>
            </div>
          </div>
          <div style="display:flex; flex-direction:column; gap:8px; align-items:flex-end;">
            ${done ? `<span class="tag" style="border-color:rgba(60,255,122,.35); color:rgba(182,255,204,.95);">DONE</span>` : (next ? `<button class="miniBtn primary" data-bact="prep" data-tier="${i}" style="min-width:140px;">Run</button>` : `<span class="tag">LOCKED</span>`)}
          </div>
        `;
        tierList.appendChild(row);
      }

      descEl.textContent = `Tier ${tDef.tier}: ${tDef.name}`;
      hintEl.textContent = "Open Prepare to deploy units.";
    }
    // After-action reports (flavorful battle log)
    // NOTE: renderAll() runs frequently; rebuilding this whole section each tick caused a visible blink.
    // We only re-render when the history actually changes.
    const hist = (S.battle.history || []).slice(-6).reverse();
    const histKey = hist.length ? (hist.map(h => h.ts).join(",") + "|" + hist.length) : "empty";
    if (histKey !== _battleHistKey){
      _battleHistKey = histKey;
      report.innerHTML = "";

      if (hist.length){
        const head = document.createElement("div");
        head.className = "row";
        head.innerHTML = `<div class="label">After-Action</div><div class="value">Recent field reports. <span class="tag">${hist.length} recent</span></div>`;
        report.appendChild(head);

        for (const h of hist){
          const row = document.createElement("div");
          row.className = "row";
          const tone = h.win ? "good" : "danger";
          const when = fmtShortTimeAgo(h.ts);
          const losses = (h.milLost||0) || (h.facLost||0)
            ? `Losses: -${h.milLost||0} militia${h.facLost?` · -${h.facLost} elite`:``}`
            : "Losses: none";
          const rew = h.win && h.rewardLine ? h.rewardLine : (h.win ? "Rewards: minimal" : "Rewards: none");
          row.innerHTML = `
            <div class="label">${escapeHtml(when)}</div>
            <div class="value">
              <b>${escapeHtml(h.title)}</b> <span class="tag ${tone}">${h.win?"SUCCESS":"FAILED"}</span><br/>
              ${escapeHtml(h.flavor)}<br/>
              <span class="tag">Deployed ${h.deployed}</span>
              <span class="tag">Ratio x${fmt(h.ratio)}</span>
              <span class="tag">${losses}</span>
              <span class="tag">${escapeHtml(rew)}</span>
            </div>
          `;
          report.appendChild(row);
        }
      } else {
        const r = document.createElement("div");
        r.className = "row";
        r.innerHTML = `<div class="label">After-Action</div><div class="value">No reports yet. Launch a mission to generate your first field log. <span class="tag">Campaign</span></div>`;
        report.appendChild(r);
      }
    }
  }



  function renderActionCosts() {
    const p = purifyCost();
    if ($("purifyCost")) $("purifyCost").innerHTML = `SCRAP ${p.scrap}<br/>+WATER ${p.waterGain}`;

    const r = recruitCost();
    const mod = S.techs.radio ? 0.82 : 1;
    if ($("recruitCost")) $("recruitCost").innerHTML = `FOOD ${Math.floor(r.food*mod)}<br/>WATER ${Math.floor(r.water*mod)}`;

    const d = deconCost();
    if ($("deconCost")) $("deconCost").innerHTML = `WATER ${d.water}<br/>RAD -${d.radDown}%`;

    const tr = tradeCost();
    if ($("tradeCost")) $("tradeCost").innerHTML = `SCRAP ${tr.scrap}<br/>+CAPS ${tr.capsGain}`;
  }

  function renderTapUI(){
    const btn = $("btnScavenge");
    if (!btn) return;
    const t = now();
    const onFire = t < (S.tapFireUntil || 0);
    btn.classList.toggle("onFire", !!onFire);

    // Combo readout lives in the button's <small> so it's obvious without clutter
    const sm = btn.querySelector("small");
    if (!sm) return;
    let combo = (S.tapCombo || 0);
    if (t - (S.tapComboLast || 0) > 900) combo = 0;
    if (onFire){
      sm.innerHTML = `<span class="kbd">tap</span><br/>🔥 OVERDRIVE`;
    } else if (combo >= 6){
      sm.innerHTML = `<span class="kbd">tap</span><br/>Combo x${combo}`;
    } else {
      sm.innerHTML = `<span class="kbd">tap</span><br/>+ loot`;
    }
  }

  
function uiPolishApply(){
  // Add "section" styling to key panels without rewriting templates.
  const ids = ["resourcePanel","buildPanel","techPanel","factionPanel","workerPanel","battlePanel","logPanel"];
  for (const id of ids){
    const el = $(id);
    if (el && !el.classList.contains("section")) el.classList.add("section");
    if (el) el.classList.add("listTight");
  }
}

function renderAll() {
    // Full render is used on screen switches and big UI actions.
    renderTopPills();
    if (UI.screen === "clicker"){
      renderActionCosts();
      renderTapUI();
      renderWorkers();
    } else if (UI.screen === "build"){
      renderBuildings();
    } else if (UI.screen === "tech"){
      renderTech();
    } else if (UI.screen === "factions"){
      renderFactions();
    } else if (UI.screen === "battle"){
      renderBattle();
      UI.battleDirty = false;
    } else if (UI.screen === "log"){
      renderStatsAndLog();
    }
  }

  // Light render used by tick() to avoid rebuilding whole screens every frame.
  function renderLight(){
    renderTopPills();
    if (UI.screen === "clicker"){
      renderActionCosts();
      renderTapUI();
      // Workers are interactive; keep them fresh but only on this screen.
      renderWorkers();
    } else if (UI.screen === "build"){
      renderBuildings();
    } else if (UI.screen === "tech"){
      renderTech();
    } else if (UI.screen === "factions"){
      renderFactions();
    } else if (UI.screen === "battle"){
      // Battle screen: NEVER rebuild every tick (causes blinking). Only render when battle state actually changes.
      const sig = [
        S.battle?.path || "",
        S.battle?.tier || 0,
        JSON.stringify(S.battle?.prog || {}),
        (S.battle?.history || []).length,
        S.militia|0,
        ownedFactionUnitCount(),
      ].join("|");
      if (UI.battleDirty || sig !== UI.battleSig){
        UI.battleSig = sig;
        renderBattle();
        UI.battleDirty = false;
      }
    } else if (UI.screen === "log"){
      renderStatsAndLog();
    }
  }

  // ---------- Core actions ----------
  function scavengeTap(srcEl=null){
    // ---- Tap combo / overdrive ----
    const t = now();
    const gap = t - (S.tapComboLast || 0);
    if (gap <= 900) {
      S.tapCombo = Math.min(40, (S.tapCombo || 0) + 1);
    } else {
      S.tapCombo = 1;
    }
    S.tapComboLast = t;

    // After 20 consecutive taps, trigger a short "on fire" window
    if ((S.tapCombo || 0) >= 20) {
      S.tapFireUntil = Math.max(S.tapFireUntil || 0, t + 5500);
    }
    const onFire = t < (S.tapFireUntil || 0);

    const baseScrap = 3 + Math.floor(S.scav*0.15);
    const baseFood = 1 + (Math.random() < 0.45 ? 1 : 0);
    const water = (Math.random() < 0.18) ? 1 : 0;

    const combo = (S.tapCombo || 0);
    const comboMult = 1 + Math.min(0.25, combo * 0.01) + (onFire ? 0.35 : 0); // up to +25% + fire burst
    const mm = momentumMult();
    const gotScrap = Math.max(1, Math.floor(baseScrap * mm * comboMult));
    const gotFood  = Math.max(0, Math.floor(baseFood  * mm * comboMult));
    const gotWater = Math.max(0, Math.floor(water     * mm * comboMult));

    S.scrap += gotScrap;
    S.food  += gotFood;
    S.water += gotWater;

    addMomentum(1);

    // Tech chance scales "forever" (slowly) with progression and active play.
    // Clamped so it never becomes guaranteed every tap.
    const techChance = clamp(
      (S.techs.workshop ? 0.08 : 0.03)
      + (S.day * 0.0006)
      + (combo * 0.003)
      + (onFire ? 0.06 : 0),
      0,
      0.65
    );
    if (Math.random() < techChance) { S.tech += 1; log(`You found a pre‑war component. +1 TECH.`); }

    S.rad = clamp(S.rad + (Math.random() < 0.25 ? 0.2 : 0), 0, 100);
    popNearEl(srcEl || $("btnScavenge"), `+${gotScrap} Scrap${gotFood?` · +${gotFood} Food`:``}${gotWater?` · +${gotWater} Water`:``}${onFire?` · 🔥`:``}`, "good");
    log(`Scavenged the ruins: +${gotScrap} Scrap, +${gotFood} Food${gotWater?`, +${gotWater} Water`:``}${onFire?` (Overdrive)`:``}.`);
    incQuest("scavenge", 1);
  }

  function purify(srcEl=null){
    const p = purifyCost();
    if (S.scrap < p.scrap) { toast(`Need ${p.scrap} Scrap.`, "warn"); popNearEl(srcEl || $("btnPurify"), `Need ${p.scrap} Scrap`, "warn"); return; }
    S.scrap -= p.scrap;
    S.water += p.waterGain;
    popNearEl(srcEl || $("btnPurify"), `+${p.waterGain} Water`, "good");
    log(`Ran the purifier: -${p.scrap} Scrap, +${p.waterGain} Water.`);
  }

  function decontaminate(srcEl=null){
    const d = deconCost();
    if (S.water < d.water) { toast(`Need ${d.water} Water.`, "warn"); log(`Not enough Water to decontaminate.`, "warn"); return; }
    if (S.rad <= 0.1) { toast(`RAD already low.`, "warn"); log(`Radiation already low.`, "warn"); return; }
    S.water -= d.water;
    S.rad = clamp(S.rad - d.radDown, 0, 100);
    popNearEl(srcEl || $("btnHealRad"), `RAD -${d.radDown}%`, "good");
    log(`Decontamination complete: -${d.water} Water, RAD -${d.radDown}%.`, "warn");
  }

  function tradeScrap(srcEl=null){
    const tr = tradeCost();
    if (S.scrap < tr.scrap) { toast(`Need ${tr.scrap} Scrap.`, "warn"); log(`Not enough Scrap to trade.`, "warn"); return; }
    S.scrap -= tr.scrap;
    S.caps += tr.capsGain;
    popNearEl(srcEl || $("btnTrade"), `+${tr.capsGain} Caps`, "good");
    log(`Traded with a wandering merchant: -${tr.scrap} Scrap, +${tr.capsGain} Caps.`, "warn");
  }


  function recruit(srcEl=null){
    if (S.pop >= housingCap()) { toast(`No housing. Build Tin Shacks.`, "warn"); log(`No room. Build more housing (Tin Shacks).`, "warn"); return; }
    const c = recruitCost();
    const mod = S.techs.radio ? 0.82 : 1;
    const f = Math.floor(c.food*mod);
    const w = Math.floor(c.water*mod);
    if (S.food < f || S.water < w) { toast(`Need Food ${f} + Water ${w}.`, "warn"); return; }
    S.food -= f; S.water -= w;
    S.pop += 1; S.idle += 1;
    popNearEl(srcEl || $("btnRecruit"), `POP +1`, "good");
    log(`A drifter joined your outpost. POP +1.`);
    incQuest("recruit", 1);
  }

  function raid(srcEl=null){
    const plan = raidPlan();
    if (S.militia <= 0) { toast(`Assign Militia first.`, "warn"); log(`No militia. Assign settlers to Militia first.`, "warn"); return; }
    const raidFood = 3 + Math.floor(plan.threat);
    const raidWater = 2 + Math.floor(plan.threat*0.6);
    if (S.food < raidFood || S.water < raidWater) { log(`Not enough supplies to raid (need Food ${raidFood}, Water ${raidWater}).`, "warn"); return; }
    S.food -= raidFood; S.water -= raidWater;

    const roll = Math.random();
    const lootMult = (S.techs.radio ? 1.15 : 1) * (activeFactionBonus().loot || 1) * momentumMult();

    if (roll < plan.chance) {
      S.raidsWon += 1;
      addMomentum(1);
      const s = Math.floor(plan.lootScrap * lootMult);
      const f = Math.floor(plan.lootFood * lootMult);
      const c = Math.floor(plan.lootCaps * lootMult);
      S.scrap += s; S.food += f; S.caps += c;
      if (plan.lootTech) S.tech += 1;
      log(`Raid success. +${s} Scrap, +${f} Food, +${c} Caps${plan.lootTech?`, +1 Tech`:``}.`);
      incQuest("raid", 1);
      if (Math.random() < 0.25) S.rad = clamp(S.rad - 1.5, 0, 100);
    } else {
      const lossChance = clamp(0.25 + (plan.threat - defensePower())*0.10, 0.15, 0.75);
      if (Math.random() < lossChance && S.militia > 0) {
        S.militia -= 1; S.pop -= 1;
        popNearEl(srcEl || $("btnRaid"), `Lost a fighter`, "danger");
        log(`Raid failed. You lost a fighter. POP -1, Militia -1.`, "danger");
      } else {
        popNearEl(srcEl || $("btnRaid"), `Raid failed`, "danger");
        log(`Raid failed. You retreated with bruises and empty pockets.`, "danger");
      }
      S.rad = clamp(S.rad + 2.0, 0, 100);
    }
  }

  function assignWorker(key, delta) {
    if (delta > 0) { if (S.idle <= 0) return; S[key] += 1; S.idle -= 1; }
    else { if (S[key] <= 0) return; S[key] -= 1; S.idle += 1; }
  }

  function buyBuilding(key) {
    const costs = {
      shack: { scrap: 18 + S.shack*10, caps: (S.shack < 2 ? 0 : (6 + S.shack*3)) },
      farm: { scrap: 14 + S.farm*9, water: 6 + S.farm*3 },
      purifier: { scrap: 22 + S.purifier*12, tech: Math.floor(S.purifier*0.7) },
      turret: { scrap: 30 + S.turret*18, tech: 1 + Math.floor(S.turret*0.8), caps: 10 + S.turret*6 },
      annex: { scrap: 30 + S.annex*24, tech: 6 + S.annex*2 },
      cmdcenter: { scrap: 40 + S.cmdcenter*28, caps: 40 + S.cmdcenter*12, tech: 8 },
      hospital: { scrap: 48 + S.hospital*30, tech: 10 + S.hospital*3, water: 20 },
      blackmarket: { scrap: 70 + S.blackmarket*36, caps: 50 + S.blackmarket*20 },
      lab: { scrap: 60 + S.lab*36, tech: 20 + S.lab*4, caps: 30 },
      depot: { scrap: 55 + S.depot*32, caps: 24 + S.depot*8 },
    }[key];

    if (!costs) return;
    for (const [k,v] of Object.entries(costs)) if (S[k] < v) return;
    for (const [k,v] of Object.entries(costs)) S[k] -= v;
    S[key] += 1;

    const msgMap = {
      shack:"Built a Tin Shack. Housing increased.",
      farm:"Planted a Dust Farm. Food output improved.",
      purifier:"Installed a Water Purifier. Water output improved.",
      turret:"Mounted a Jury-Rigged Turret. Defense increased.",
      annex:"Constructed a Workshop Annex. Engineers can now be assigned.",
      cmdcenter:"Erected a Command Center. Issue directives and hire Propagandists.",
      hospital:"Built a Field Hospital. Medics can now be assigned.",
      blackmarket:"Set up a Black Market. Risky trades unlocked.",
      lab:"Established a Research Lab. Researchers can now discover breakthroughs.",
      depot:"Added a Logistics Depot. Storage and Fixers unlocked."
    };
    const msg = msgMap[key];
    if (msg) log(msg);
    incQuest("build", 1);
  }

  function buyTech(key) {
    const techDefs = {
      workshop: { tech: 6, scrap: 40, caps: 20, msg: "Workshop online. Scavengers can now salvage Tech more reliably." },
      radio: { tech: 10, scrap: 60, caps: 35, msg: "Radio Beacon broadcasting. Recruiting is cheaper; raids yield more." },
      medbay: { tech: 14, scrap: 80, water: 35, msg: "Field Medbay set up. Radiation rises slower." },
      caravan: { tech: 18, scrap: 90, food: 60, msg: "Caravan Route established. Caps now trickle in." },
    }[key];
    if (!techDefs || S.techs[key]) return;
    for (const [k,v] of Object.entries(techDefs)) { if (k==="msg") continue; if (S[k] < v) return; }
    for (const [k,v] of Object.entries(techDefs)) { if (k==="msg") continue; S[k] -= v; }
    S.techs[key] = true;
    log(techDefs.msg);
  }

  // ---------- Tick / simulation ----------
  let last = now();
  function tick() {
    // keep momentum and ensure expansion fields are present
    syncMomentum();
    ensureExpansion();
    const t = now();
    const dt = Math.min(1.0, (t - last) / 1000);
    last = t;

    const prod = productionPerSec();
    S.scrap += prod.scavRate * dt;
    S.food += prod.foodRate * dt;
    S.water += prod.waterRate * dt;
    S.tech += prod.techRate * dt;
    S.caps += prod.capsRate * dt;

    S.food -= prod.foodUse * dt;
    S.water -= prod.waterUse * dt;

    S.scrap = Math.max(0, S.scrap);
    S.food = Math.max(0, S.food);
    S.water = Math.max(0, S.water);
    S.tech = Math.max(0, S.tech);
    S.caps = Math.max(0, S.caps);

    S.rad = clamp(S.rad + prod.radGain * dt, 0, 100);

    // expansion: generate MED and BRK resources and adjust strain
    if (S.medics) {
      S.medData += S.medics * dt * 0.05;
    }
    if (S.researchers) {
      S.breakthroughs += S.researchers * dt * 0.02;
    }
    // Strain rises slowly when directives are active (e.g. when Command Center built) and falls with Fixers
    if (S.cmdcenter > 0) {
      S.strain += dt * 0.01;
    }
    if (S.fixers) {
      S.strain = Math.max(0, S.strain - dt * 0.05 * S.fixers);
    }
    // propagandists slowly add faction rep for the active sponsor
    if (S.propagandists && S.factions && S.factions.active) {
      const facId = S.factions.active;
      if (S.factions.rep && facId) {
        S.factions.rep[facId] = clamp((S.factions.rep[facId] || 0) + S.propagandists * dt * 0.02, 0, 100);
      }
    }

    if (S.rad > 75 && Math.random() < 0.0035 * dt * (S.rad - 74)) {
      const lossF = 2 + Math.floor(Math.random()*4);
      const lossW = 1 + Math.floor(Math.random()*3);
      S.food = Math.max(0, S.food - lossF);
      S.water = Math.max(0, S.water - lossW);
      log(`Radiation sickness flares. -${lossF} Food, -${lossW} Water.`, "warn");
    }

    const starving = (S.food <= 0.1);
    const thirsty = (S.water <= 0.1);
    if ((starving || thirsty) && Math.random() < 0.0025 * dt * (1 + S.pop*0.05)) {
      if (S.pop > 0) {
        S.pop -= 1;
        let removed = false;
        for (const k of ["militia","purifiers","farmers","scav"]) {
          if (S[k] > 0) { S[k] -= 1; removed = true; break; }
        }
        if (!removed) S.idle = Math.max(0, S.idle - 1);
        log(`A settler left due to ${thirsty ? "thirst" : "hunger"}. POP -1.`, "danger");
      }
    }

    S.day += dt * 0.02;

    // Contracts removed
    checkOps();

    if (Math.random() < 0.01) save();

    // Light UI update: never rebuild every screen every 250ms.
    // Use the shared renderLight() which is battle-safe (no blinking).
    renderLight();
  }

  // ---------- Save/Load/Offline ----------
  function save() {
    S.t = now();
    localStorage.setItem(KEY, JSON.stringify(S));
    return true;
  }

  // ---------- Robust autosave (mobile-friendly) ----------
  let _dirty = false;
  let _saveTimer = null;

  function queueSave(){
    _dirty = true;
    if (_saveTimer) return;
    _saveTimer = setTimeout(() => flushSave(), 1500);
  }

  function flushSave(){
    if (_saveTimer){ clearTimeout(_saveTimer); _saveTimer = null; }
    if (!_dirty) return;
    try { save(); } catch {}
    _dirty = false;
  }

  // iOS Safari sometimes only persists storage after a user gesture
  document.addEventListener("pointerdown", () => {
    try { localStorage.setItem("bf_initialized", "1"); } catch {}
  }, { once:true });

  document.addEventListener("visibilitychange", () => {
    if (document.visibilityState === "hidden") flushSave();
  });
  window.addEventListener("pagehide", flushSave);
  window.addEventListener("beforeunload", flushSave);


  function migrateSave(data){
    if (!data || !data.version) return null;

    // v3 -> v5: add prestige/quests/factions/contract while keeping existing resources/buildings/etc.
    if (data.version === 3){
      const merged = structuredClone(DEFAULT);
      for (const k of Object.keys(merged)) {
        if (data[k] !== undefined) merged[k] = data[k];
      }
      // Ensure nested structures exist
      merged.factions = merged.factions || structuredClone(DEFAULT.factions);
      merged.factions.rep = Object.assign(structuredClone(DEFAULT.factions.rep), (data.factions && data.factions.rep) || {});
      merged.factions.rank = Object.assign(structuredClone(DEFAULT.factions.rank), (data.factions && data.factions.rank) || {});
      merged.factions.active = (data.factions && data.factions.active) || null;

      merged.contract = structuredClone(DEFAULT.contract);
      merged.version = 5;
      return merged;
    }

    // v4 -> v5: introduce contract loop
    if (data.version === 4){
      const merged = structuredClone(DEFAULT);
      for (const k of Object.keys(merged)) {
        if (data[k] !== undefined) merged[k] = data[k];
      }
      merged.factions = merged.factions || structuredClone(DEFAULT.factions);
      merged.factions.rep = Object.assign(structuredClone(DEFAULT.factions.rep), (data.factions && data.factions.rep) || {});
      merged.factions.rank = Object.assign(structuredClone(DEFAULT.factions.rank), (data.factions && data.factions.rank) || {});
      merged.factions.active = (data.factions && data.factions.active) || null;

      merged.contract = (data.contract) ? Object.assign(structuredClone(DEFAULT.contract), data.contract) : structuredClone(DEFAULT.contract);
      merged.version = 5;
      return merged;
    }

    // v5 -> v6: add battle operations state
    if (data.version === 5){
      const merged = structuredClone(DEFAULT);
      for (const k of Object.keys(merged)) {
        if (data[k] !== undefined) merged[k] = data[k];
      }
      merged.ops = (data.ops) ? Object.assign(structuredClone(DEFAULT.ops), data.ops) : structuredClone(DEFAULT.ops);
      merged.version = 6;
      return merged;
    }

    if (data.version === 6) return data;
    return null;

  }

  function load() {
    try {
      const candidates = [KEY, "wasteland_outpost_save_v3"];
      for (const k of candidates){
        const raw = localStorage.getItem(k);
        if (!raw) continue;
        const data = JSON.parse(raw);
        const migrated = migrateSave(data);
        if (!migrated) continue;
        // Write into the new key so future loads are fast
        localStorage.setItem(KEY, JSON.stringify(migrated));
        return migrated;
      }
      return null;
    } catch { return null; }
  }

    function applyOfflineProgress(showPopup=false) {
    const t0 = S.t || now();
    const elapsed = clamp((now() - t0) / 1000, 0, 60 * 60 * 4);
    if (elapsed < 2) return null;

    const before = { scrap:S.scrap, food:S.food, water:S.water, tech:S.tech, caps:S.caps, rad:S.rad, day:S.day };

    const steps = 120;
    const dt = elapsed / steps;
    for (let i=0;i<steps;i++){
      const prod = productionPerSec();
      S.scrap += prod.scavRate * dt;
      S.food += prod.foodRate * dt;
      S.water += prod.waterRate * dt;
      S.tech += prod.techRate * dt;
      S.caps += prod.capsRate * dt;
      S.food -= prod.foodUse * dt;
      S.water -= prod.waterUse * dt;
      S.scrap = Math.max(0,S.scrap);
      S.food = Math.max(0,S.food);
      S.water = Math.max(0,S.water);
      S.tech = Math.max(0,S.tech);
      S.caps = Math.max(0,S.caps);
      S.rad = clamp(S.rad + productionPerSec().radGain * dt, 0, 100);
      S.day += dt * 0.02;
    }

    const gains = {
      elapsed,
      scrap: Math.max(0, S.scrap - before.scrap),
      food:  Math.max(0, S.food  - before.food),
      water: Math.max(0, S.water - before.water),
      tech:  Math.max(0, S.tech  - before.tech),
      caps:  Math.max(0, S.caps  - before.caps),
      rad:   S.rad - before.rad,
    };

    // Keep old log line for desktop/dev, but also optionally show a mobile-friendly popup.
    log(`You were away for ${Math.floor(elapsed/60)}m. The outpost kept running.`, "warn");
    checkOps();

    if (showPopup){
      const mins = Math.floor(elapsed/60);
      const secs = Math.floor(elapsed % 60);
      const timeStr = mins > 0 ? `${mins}m ${secs}s` : `${secs}s`;
      const parts = [];
      if (gains.scrap >= 0.5) parts.push(`<span class="chip">SCRAP <b>+${fmt(gains.scrap)}</b></span>`);
      if (gains.food  >= 0.5) parts.push(`<span class="chip">FOOD <b>+${fmt(gains.food)}</b></span>`);
      if (gains.water >= 0.5) parts.push(`<span class="chip">WATER <b>+${fmt(gains.water)}</b></span>`);
      if (gains.tech  >= 0.25) parts.push(`<span class="chip">TECH <b>+${fmt(gains.tech)}</b></span>`);
      if (gains.caps  >= 0.25) parts.push(`<span class="chip">CAPS <b>+${fmt(gains.caps)}</b></span>`);
      // Rad is a penalty; show only if it moved meaningfully.
      if (Math.abs(gains.rad) >= 0.25) parts.push(`<span class="chip warn">RAD <b>${gains.rad>0?'+':''}${fmt(gains.rad)}%</b></span>`);

      showModal("While you were away…", `
        <div class="rows" style="gap:12px;">
          <div class="row">
            <div class="label">Time Away</div>
            <div class="value">${escapeHtml(timeStr)} <span class="tag">Offline earnings</span></div>
          </div>

          <div class="row">
            <div class="label">Gains</div>
            <div class="value">
              <div class="bPills" style="justify-content:flex-end;">
                ${parts.length ? parts.join("") : `<span class="tag">No meaningful gains</span>`}
              </div>
            </div>
          </div>

          <button class="btn" id="btnOfflineOk">
            <div class="left">
              <div class="name">Back to the Wasteland</div>
              <div class="desc">Continue where you left off</div>
            </div>
            <small>OK</small>
          </button>
        </div>
      `);

      setTimeout(() => {
        const b = $("btnOfflineOk");
        if (b) b.onclick = () => closeModal();
      }, 0);
    }

    return gains;
  }

  
  // ---------- Mobile-friendly offline earnings ----------
  // When the app/tab goes to background, remember the timestamp.
  // When it comes back, apply offline progress and show a summary popup.
  document.addEventListener("visibilitychange", () => {
    if (document.hidden){
      // mark last active moment
      S.t = now();
      queueSave();
    } else {
      // returning to the game
      const gains = applyOfflineProgress(true);
      if (gains) { renderAll(); queueSave(); }
    }
  });
  window.addEventListener("focus", () => {
    // Some mobile webviews don't fire visibilitychange reliably.
    const gains = applyOfflineProgress(true);
    if (gains) { renderAll(); queueSave(); }
  });

// ---------- Event wiring ----------
  bindTap($("btnScavenge"), (e) => { flashBtn(e.currentTarget); haptic(8); scavengeTap(e.currentTarget); renderAll(); });
  bindTap($("btnPurify"), (e) => { flashBtn(e.currentTarget); haptic(8); purify(e.currentTarget); renderAll(); });
  bindTap($("btnRecruit"), (e) => { flashBtn(e.currentTarget); haptic(8); recruit(e.currentTarget); renderAll(); });
  bindTap($("btnHealRad"), (e) => { flashBtn(e.currentTarget); haptic(8); decontaminate(e.currentTarget); renderAll(); });
  bindTap($("btnTrade"), (e) => { flashBtn(e.currentTarget); haptic(8); tradeScrap(e.currentTarget); renderAll(); });

  // Battle: Campaign Paths wiring
  const pathEl = $("battlePathSelect");
  if (pathEl){
    pathEl.addEventListener("click", (e) => {
      const btn = e.target.closest("button[data-path]");
      if (!btn || btn.disabled) return;
      ensureBattle();
      S.battle.path = btn.dataset.path;
      S.battle.tier = 1;
      S.battle.deploy = { militia: 0, faction: 0 };
      UI.battleDirty = true;
      renderLight();
      queueSave();
    });
  }

  const tierEl = $("battleTierList");
  if (tierEl){
    tierEl.addEventListener("click", (e) => {
      const prep = e.target.closest("button[data-bact='prep']");
      if (prep){
        flashBtn(prep); haptic(10);
        // Prep buttons in the checklist carry the tier they belong to.
        const ti = parseInt(prep.dataset.tier || "", 10);
        if (isFinite(ti) && ti >= 1 && ti <= 5){
          ensureBattle();
          S.battle.tier = ti;
          UI.battleDirty = true;
        }
        showMissionPrepModal();
        return;
      }

      const btn = e.target.closest("button[data-tier]");
      if (!btn || btn.disabled) return;
      ensureBattle();
      const want = parseInt(btn.dataset.tier, 10) || 1;
      // Only allow selecting up to the next available tier (CivCrafter feel)
      const pKey = S.battle.path;
      const cleared = pKey ? (S.battle.prog[pKey] || 0) : 0;
      const next = clamp(cleared + 1, 1, 5);
      S.battle.tier = clamp(want, 1, next);
      UI.battleDirty = true;
      renderLight();
      queueSave();
    });
  }

  const depEl = $("battleDeploy");
  if (depEl){
    depEl.addEventListener("click", (e) => {
      const btn = e.target.closest("button[data-deploy]");
      if (!btn) return;
      ensureBattle();
      const k = btn.dataset.deploy;
      const act = btn.dataset.act;
      if (!k || !act) return;
      const delta = act === "plus" ? 1 : -1;
      if (!S.battle.deploy) S.battle.deploy = { militia: 0, faction: 0 };
      S.battle.deploy[k] = (S.battle.deploy[k]||0) + delta;
      UI.battleDirty = true;
      renderLight();
      queueSave();
    });
  }

  bindTap($("btnLaunchMission"), (e) => {
    flashBtn(e.currentTarget); haptic(12);
    ensureBattle();
    const p = S.battle.path;
    const t = S.battle.tier || 1;
    const mil = clamp(S.battle.deploy?.militia|0, 0, S.militia|0);
    const fac = clamp(S.battle.deploy?.faction|0, 0, ownedFactionUnitCount());
    const def = p ? missionDef(p, t) : null;
    if (!p || !def){ toast("Choose a path and tier first.", "warn"); return; }
    if ((mil + fac) < def.req.units){ toast(`Need ${def.req.units} units deployed.`, "warn"); return; }

    // Smooth battle initiation: show a short simulation overlay, then apply deterministic result
    const youStats = totalUnitStats(mil, fac);
    playBattleSim({
      title: PATHS[p].name,
      subtitle: `Tier ${t}: ${def.name}`,
      you: youStats,
      enemy: def.enemy
    });

    const launch = e.currentTarget;
    if (launch) launch.disabled = true;

    setTimeout(() => {
      const res = resolveMission(p, t, mil, fac);
      if (!res){ toast("Mission failed to resolve.", "warn"); if (launch) launch.disabled = false; return; }
      applyMissionResult(p, t, mil, fac, res);

      const rewardLine = res.win
        ? (Object.entries(res.reward||{})
            .filter(([k,v])=>k!=="rep" && v)
            .map(([k,v])=>`+${v} ${k.toUpperCase()}`)
            .join(" · ") || "none")
        : "none";

      const title = `${PATHS[p].name} — Tier ${t}: ${def.name}`;
      const flavor = battleFlavor(p, res.win);

      addBattleHistory({
        ts: now(),
        win: res.win,
        title,
        flavor,
        deployed: (mil + fac),
        ratio: res.ratio,
        milLost: res.milLost||0,
        facLost: res.facLost||0,
        rewardLine: res.win ? `Rewards: ${rewardLine}` : "Rewards: none"
      });

      const lostTxt = (res.milLost||0) || (res.facLost||0)
        ? `Losses: -${res.milLost||0} militia${res.facLost?` · -${res.facLost} elite`:``}`
        : "Losses: none";
      log(`${title}. ${res.win?"SUCCESS":"FAILED"}. ${lostTxt}.`, res.win ? "" : "danger");

      // Reset deployment after mission
      S.battle.deploy = { militia: 0, faction: 0 };

      // Close the sim overlay and show a proper outcome popup.
      try { if (simModal && simModal.open) simModal.close(); } catch {}
      showBattleOutcomePopup({ pathKey: p, tier: t, def, mil, fac, res });

      // Re-enable launching
      if (launch) launch.disabled = false;

      renderAll();
      queueSave();
    }, 1150);
  });

  $("workerPanel").addEventListener("click", (e) => {
    const btn = e.target.closest("button");
    if (!btn) return;

    // Switch Economy/War view
    const tab = btn.dataset.workersTab;
    if (tab) {
      S.workersTab = tab;
      renderAll();
      queueSave();
      return;
    }

    const key = btn.dataset.key;
    const act = btn.dataset.act;
    if (!key || !act) return;
    assignWorker(key, act === "plus" ? +1 : -1);
    renderAll();
  
    queueSave();
});

  $("buildPanel").addEventListener("click", (e) => {
    const btn = e.target.closest("button");
    if (!btn) return;
    const key = btn.dataset.buy;
    if (!key) return;
    buyBuilding(key);
    renderAll();
  
    queueSave();
});

  $("techPanel").addEventListener("click", (e) => {
    const btn = e.target.closest("button");
    if (!btn) return;
    const key = btn.dataset.tech;
    if (!key) return;
    buyTech(key);
    renderAll();
  
    queueSave();
});

$("factionSummary").addEventListener("click", (e) => {
  const btn = e.target.closest("button");
  if (!btn) return;
  const act = btn.dataset.factAct;
  if (!act) return;

  const id = btn.dataset.factId;
  if (!id) return;

  if (act === "pick") {
    // Toggle expand/collapse when tapping the same faction again
    S.factions.uiSelected = (S.factions.uiSelected === id) ? null : id;
    renderAll();
    queueSave();
    return;
  }
  if (act === "donate") donateToFaction(id);
  if (act === "ally") sponsorFaction(id);
  if (act === "leave") clearActiveFaction();
  if (act === "shop") openFactionShop(id);

  renderAll();
  queueSave();
});

  
$("factionPanel").addEventListener("click", (e) => {
  const btn = e.target.closest("button");
  if (!btn) return;
  const id = btn.dataset.factId;
  const act = btn.dataset.factAct;
  if (!id || !act) return;

  if (act === "pick") {
    // Toggle expand/collapse when tapping the same faction again
    S.factions.uiSelected = (S.factions.uiSelected === id) ? null : id;
    renderAll();
    queueSave();
    return;
  }
  if (act === "donate") donateToFaction(id);
  if (act === "ally") sponsorFaction(id);
  if (act === "leave") clearActiveFaction();
  if (act === "shop") openFactionShop(id);


  renderAll();
  queueSave();
});




  // ---------- Menu modal (save/export/import/reset/help) ----------
  const modal = $("modal");
  $("modalClose").addEventListener("click", () => closeModal());
  $("btnMenu").addEventListener("click", () => openMenu());

  function openMenu(){
    showModal("Menu", `
      <div class="rows" style="gap:12px;">
        <button class="btn" id="mSave">
          <div class="left"><div class="name">Save</div><div class="desc">Write progress to this device</div></div>
          <small>Local</small>
        </button>
        <button class="btn" id="mExport">
          <div class="left"><div class="name">Export Save</div><div class="desc">Copy a save string</div></div>
          <small>Clipboard</small>
        </button>
        <button class="btn" id="mImport">
          <div class="left"><div class="name">Import Save</div><div class="desc">Paste a save string</div></div>
          <small>Restore</small>
        </button>
        <button class="btn" id="mReset">
          <div class="left"><div class="name">Reset</div><div class="desc">Start over</div></div>
          <small style="color:var(--danger);">Wipes</small>
        </button>
        <button class="btn" id="mHelp">
          <div class="left"><div class="name">Help</div><div class="desc">How to play</div></div>
          <small>Tips</small>
        </button>

        <button class="btn" id="mPrestige">
          <div class="left"><div class="name">Wasteland Reset (Prestige)</div><div class="desc">Reset for permanent bonuses</div></div>
          <small>Lv ${S.prestige?.level||0}</small>
        </button>
      </div>
    `);

    setTimeout(() => {
      $("mSave").onclick = () => { save(); log("Saved.", "warn"); closeModal(); };
      $("mExport").onclick = () => exportSave();
      $("mImport").onclick = () => importSave();
      $("mReset").onclick = () => confirmReset();
      $("mHelp").onclick = () => showHelp();
      $("mPrestige").onclick = () => showPrestige();
    }, 0);
  }

  async function exportSave(){
    save();
    const raw = localStorage.getItem(KEY) || "";
    try {
      await navigator.clipboard.writeText(raw);
      log("Export copied to clipboard.", "warn");
      closeModal();
    } catch {
      showModal("Export Save", `<p>Copy this save string:</p><p><span class="kbd" style="display:block; white-space:pre-wrap; word-break:break-all; padding:12px;">${escapeHtml(raw)}</span></p>`);
    }
  }

  function importSave(){
    showModal("Import Save", `
      <p>Paste a save string below and press <span class="kbd">Import</span>.</p>
      <textarea id="importBox" style="width:100%; min-height:160px; border-radius:16px; border:1px solid rgba(31,58,42,.85); background:rgba(0,0,0,.25); color:var(--text); padding:12px; font-family:var(--mono); font-size:0.82rem;"></textarea>
      <div style="display:flex; gap:12px; margin-top:12px; flex-wrap:wrap;">
        <button class="tab" id="doImport" style="justify-content:center;">Import</button>
        <button class="tab" id="cancelImport" style="justify-content:center;">Cancel</button>
      </div>
    `);
    setTimeout(() => {
      $("doImport").onclick = () => {
        const txt = $("importBox").value.trim();
        try{
          const data = JSON.parse(txt);
          const migrated = migrateSave(data);
          if (!migrated) throw new Error("Bad save");
          S = migrated;
          save();
          log("Imported save.", "warn");
          closeModal();
          renderAll();
        } catch {
          log("Import failed (invalid save).", "danger");
        }
      };
      $("cancelImport").onclick = () => closeModal();
    }, 0);
  }

  function confirmReset(){
    showModal("Reset Game", `
      <p>This will wipe your current outpost. This can't be undone.</p>
      <div style="display:flex; gap:12px; margin-top:12px; flex-wrap:wrap;">
        <button class="tab" id="doReset" style="justify-content:center; border-color: rgba(255,107,107,.55);">Reset</button>
        <button class="tab" id="cancelReset" style="justify-content:center;">Cancel</button>
      </div>
    `);
    setTimeout(() => {
      $("doReset").onclick = () => {
        S = structuredClone(DEFAULT);
        save();
        // clear log area
        const el = $("log"); if (el) el.innerHTML = "";
        log("Reset complete.", "warn");
        closeModal();
        renderAll();
        showScreen("clicker");
      };
      $("cancelReset").onclick = () => closeModal();
    }, 0);
  }


  function showPrestige(){
    const ready = canPrestige();
    const est = prestigeGainEstimate();
    const lvl = S.prestige?.level || 0;
    const tok = S.prestige?.tokens || 0;
    const b = prestigeBonus();
    showModal("Wasteland Reset (Prestige)", `
      <p><b>Prestige Level:</b> ${lvl} · <b>Tokens:</b> ${tok}</p>
      <p><b>Current bonuses:</b> +${Math.round((b.prod-1)*100)}% production, +${Math.round((b.caps-1)*100)}% caps, lower radiation gain.</p>
      <p><b>Reset requirement:</b> POP ≥ 25, or Raids Won ≥ 12, or TECH ≥ 50.</p>
      <p><b>You would gain:</b> ~${est} tokens.</p>
      <button class="btn" id="doPrestigeNow" ${ready ? "" : "disabled"}>
        <div class="left"><div class="name">Reset Now</div><div class="desc">${ready ? "Start a new run with bonuses" : "Not ready yet"}</div></div>
        <small>${ready ? "GO" : "LOCKED"}</small>
      </button>
    `);
    setTimeout(() => {
      const b = document.getElementById("doPrestigeNow");
      if (b) b.onclick = () => { doPrestige(); closeModal(); };
    }, 0);
  }

  function showHelp(){
    showModal("How to Play", `
      <p><b>Resources</b>: tap <span class="kbd">Scavenge</span>, then assign settlers to automate.</p>
      <p><b>Build</b>: Shacks raise housing, Farms & Purifiers raise production, Turrets raise defense.</p>
      <p><b>Battle</b>: run time-based operations (Patrol/Raid/Assault). Choose a squad size; militia sent out won’t defend until they return.</p>
      <p><b>Radiation</b>: grows with time/pop. Use <span class="kbd">Decontaminate</span> (stronger with Medbay).</p>
      <p><b>Tip</b>: Early game is usually Water‑limited—build a Purifier and assign Purifier Crew.</p>
    `);
  }

  function showModal(title, html) {
    $("modalTitle").textContent = title;
    $("modalBody").innerHTML = html;
    modal.showModal();
  }

  // Battle simulation modal (used for Battle Paths launch)
  const simModal = $("simModal");
  const simBody = $("simBody");
  const simTitle = $("simTitle");
  const simClose = $("simClose");
  if (simClose) simClose.addEventListener("click", () => {
    try { simModal.close(); } catch {}
  });

  function openSim(title, html){
    if (!simModal || !simBody || !simTitle || !simClose) return;
    simTitle.textContent = title || "Simulating Battle";
    simBody.innerHTML = html;
    simClose.disabled = true; // enabled when done
    try { simModal.showModal(); } catch {}
  }

  function finishSim(){
    if (!simModal || !simClose) return;
    simClose.disabled = false;
    // Leave the sim modal open; we'll show a separate outcome popup when resolution completes.
  }

  function playBattleSim({ title, subtitle, you, enemy }){
    const html = `
      <div class="simBox">
        <div class="simHeader">
          <div>
            <div class="title">${escapeHtml(title||"Battle")}</div>
            <div class="simSub">${escapeHtml(subtitle||"")}</div>
          </div>
          <div class="pipWrap" aria-label="Simulating">
            <div class="pip"></div><div class="pip"></div><div class="pip"></div><div class="pip"></div>
          </div>
        </div>

        <div class="row" style="margin:0; padding:0; border:none; background:none;">
          <div style="flex:1; min-width:0;">
            <div class="label">Your Force</div>
            <div class="value">${statChipsHTML(you.atk, you.def, you.hp)}</div>
          </div>
        </div>
        <div class="row" style="margin:0; padding:0; border:none; background:none;">
          <div style="flex:1; min-width:0;">
            <div class="label">Enemy Force</div>
            <div class="value">${statChipsHTML(enemy.atk, enemy.def, enemy.hp)}</div>
          </div>
        </div>

        <div class="simAnimRow">
          <div class="miniHint">Resolving engagement…</div>
          <div class="tag">Calculating</div>
        </div>
        <div class="simBarOuter" aria-label="Battle progress"><div class="simBarInner" id="simBar"></div></div>
        <div class="simLog" id="simLog">Scouts report movement beyond the ridge…</div>
      </div>
    `;
    openSim("Simulating Battle", html);

    const bar = $("simBar");
    const logEl = $("simLog");

    const lines = [
      "Scouts report movement beyond the ridge…",
      "You advance cautiously through the dust.",
      "Contact. Lines engage.",
      "Armor holds. Fire intensifies.",
      "Outcome stabilizing…"
    ];
    let i = 0;
    let pct = 0;
    const iv = setInterval(() => {
      pct = Math.min(100, pct + (8 + Math.floor(Math.random()*12)));
      if (bar) bar.style.width = pct + "%";
      if (logEl && i < lines.length && pct >= (i+1) * 18) {
        logEl.textContent = lines[i];
        i++;
      }
      if (pct >= 100) {
        clearInterval(iv);
        finishSim();
      }
    }, 140);
  }

  // Outcome popup (shown after the sim finishes)
  function showBattleOutcomePopup({ pathKey, tier, def, mil, fac, res }){
    const title = res.win ? "Outcome — SUCCESS" : "Outcome — FAILED";

    const yourAfter = {
      mil: Math.max(0, (mil|0) - (res.milLost|0)),
      fac: Math.max(0, (fac|0) - (res.facLost|0))
    };

    const lossLine = (res.milLost||0) || (res.facLost||0)
      ? `<div class="row"><div class="label">Losses</div><div class="value">-${res.milLost||0} militia${(res.facLost||0)?` · -${res.facLost||0} faction unit(s)`:``} <span class="tag">Permanent</span></div></div>`
      : `<div class="row"><div class="label">Losses</div><div class="value">None <span class="tag">Clean win</span></div></div>`;

    const rewardPairs = Object.entries(res.reward || {})
      .filter(([k,v]) => k !== "rep" && v)
      .map(([k,v]) => `+${v} ${k.toUpperCase()}`);

    const rewardLine = res.win
      ? `<div class="row"><div class="label">Rewards</div><div class="value">${rewardPairs.length ? rewardPairs.join(" · ") : "None"} <span class="tag">Loot</span></div></div>`
      : `<div class="row"><div class="label">Rewards</div><div class="value">None <span class="tag">Retreat</span></div></div>`;

    const repGain = res.win ? ((res.reward && res.reward.rep) ? res.reward.rep : 1) : 0;
    const repLine = (res.win && repGain)
      ? `<div class="row"><div class="label">Reputation</div><div class="value">+${repGain} REP <span class="tag">If aligned</span></div></div>`
      : ``;

    const youBefore = totalUnitStats(mil|0, fac|0);
    const youAfterStats = totalUnitStats(yourAfter.mil, yourAfter.fac);

    showModal(title, `
      <div class="rows">
        <div class="row"><div class="label">Mission</div><div class="value">${escapeHtml(PATHS[pathKey]?.name || "Path")} · Tier ${tier}: ${escapeHtml(def?.name || "")}</div></div>
        <div class="row"><div class="label">Your Force</div><div class="value">${statChipsHTML(youBefore.atk, youBefore.def, youBefore.hp)} <span class="tag">Deployed</span></div></div>
        <div class="row"><div class="label">Enemy Force</div><div class="value">${statChipsHTML((def?.enemy?.atk)||0, (def?.enemy?.def)||0, (def?.enemy?.hp)||0)} <span class="tag">Opposition</span></div></div>
        <div class="row"><div class="label">Aftermath</div><div class="value">${statChipsHTML(youAfterStats.atk, youAfterStats.def, youAfterStats.hp)} <span class="tag">Survivors</span></div></div>
        ${lossLine}
        ${rewardLine}
        ${repLine}
      </div>

      <div style="display:flex; gap:12px; margin-top:12px; flex-wrap:wrap;">
        <button class="btn" id="outcomeContinue">
          <div class="left"><div class="name">Continue</div><div class="desc">Back to Battle Paths</div></div>
          <small>OK</small>
        </button>
      </div>
    `);

    setTimeout(() => {
      const b = $("outcomeContinue");
      if (b) b.onclick = () => { closeModal(); };
    }, 0);
  }
  function closeModal() { if (modal.open) modal.close(); }
  function escapeHtml(s){
    return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }

  // ---------- Init ----------
  ensureQuest();
  ensureFactions();
  ensureContract();
  applyOfflineProgress(true);
  renderAll();
  log("Outpost initialized. The wasteland waits…");
  log("Early tip: Use Trade Scrap to get Caps for your first Tin Shacks (housing) and Turrets.", "warn");
  log("New: Daily Quest & Prestige! Check Log for quest progress; use Menu → Wasteland Reset when you qualify.", "warn");
  log("New: Factions tab — donate supplies (scaled costs), build REP, align permanently at 50, then spend faction tokens in the shop.", "warn");
  setInterval(tick, 250);

})();
</script>

  <script>
    // --- Ads integration hooks (safe no-op in browser) ---
    // Mobile wrappers (Cordova/Capacitor/Android WebView/iOS WKWebView) can override these.
    window.Ads = window.Ads || {};
    (function(){
      const slots = {
        top: document.getElementById('adBannerTop'),
        bottom: document.getElementById('adBannerBottom'),
        nativeBattle: document.getElementById('adNativeBattle')
      };

      function setSlotVisible(el, on){
        if(!el) return;
        el.style.display = on ? 'flex' : 'none';
      }

      // Banner helpers
      window.Ads.showBanner = function(position='bottom'){
        if(position === 'top'){ setSlotVisible(slots.top, true); setSlotVisible(slots.bottom, false); }
        else { setSlotVisible(slots.bottom, true); setSlotVisible(slots.top, false); }
        document.dispatchEvent(new CustomEvent('ads:banner:show', {detail:{position}}));
      };
      window.Ads.hideBanner = function(){
        setSlotVisible(slots.top, false);
        setSlotVisible(slots.bottom, false);
        document.dispatchEvent(new CustomEvent('ads:banner:hide'));
      };

      // Interstitial / Rewarded: call into native if available, otherwise simulate.
      // Your native layer can listen for these events and then call Ads._onInterstitialClosed(), etc.
      window.Ads.showInterstitial = function(placement='generic'){
        document.dispatchEvent(new CustomEvent('ads:interstitial:request', {detail:{placement}}));
        // Web fallback: instantly close (no-op)
        window.setTimeout(()=>window.Ads._onInterstitialClosed(placement), 50);
      };
      window.Ads.showRewarded = function(placement='reward'){
        document.dispatchEvent(new CustomEvent('ads:rewarded:request', {detail:{placement}}));
        // Web fallback: instantly grant
        window.setTimeout(()=>window.Ads._onRewarded(placement, true), 50);
      };

      // Callbacks for native layer
      window.Ads._onInterstitialClosed = function(placement){
        document.dispatchEvent(new CustomEvent('ads:interstitial:closed', {detail:{placement}}));
      };
      window.Ads._onRewarded = function(placement, granted){
        document.dispatchEvent(new CustomEvent('ads:rewarded:closed', {detail:{placement, granted: !!granted}}));
      };

      // Default behavior in-browser: show bottom banner placeholder
      window.Ads.showBanner('bottom');
    })();
  </script>

</body>
</html>
