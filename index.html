<!doctype html>
<html lang="en">
<head>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="Wasteland Outpost">
  <!-- iOS Home Screen icon -->
  <link rel="apple-touch-icon" sizes="180x180" href="icons/icon-180.png">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Wasteland Outpost — Idle Settlement Builder</title>
  <style>
    :root{
      --adbar-h: 60px;
      --bg:#0b0f0c;
      --panel:#101a14;
      --panel2:#0d1511;
      --text:#d7f7da;
      --muted:#92c79b;
      --accent:#3cff7a;
      --warn:#ffcc66;
      --danger:#ff6b6b;
      --line:#1f3a2a;
      --shadow: 0 12px 30px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    *{ box-sizing:border-box; }
    html{
      -webkit-text-size-adjust: 100%;
      text-size-adjust: 100%;
      font-size: 18px;
    }
    @supports (font-size: clamp(16px, 2vw, 20px)) {
      html{ font-size: clamp(18px, 1.8vw + 10px, 22px); }
    }
    body{
      margin:0;
      background: radial-gradient(1200px 700px at 20% 0%, rgba(60,255,122,.10), transparent 55%),
                  radial-gradient(900px 600px at 95% 20%, rgba(255,204,102,.08), transparent 55%),
                  linear-gradient(180deg, #070a08, var(--bg));
      color:var(--text);
      font-family:var(--sans);
      min-height:100vh;
      padding-bottom: calc(92px + env(safe-area-inset-bottom));
    }

    /* Top HUD */
    header{
      padding: calc(18px + env(safe-area-inset-top)) 16px 10px;
      position:sticky;
      top:0;
      background: linear-gradient(180deg, rgba(11,15,12,.92), rgba(11,15,12,.65));
      backdrop-filter: blur(6px);
      border-bottom:1px solid rgba(31,58,42,.7);
      z-index:10;
    }
    .toprow{
      display:flex;
      gap:12px;
      align-items:flex-end;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .title{
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .title h1{
      margin:0;
      font-family:var(--mono);
      letter-spacing:.5px;
      font-size: 1.15rem;
      color:var(--accent);
      text-shadow: 0 0 14px rgba(60,255,122,.18);
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      font-size:0.78rem;
      line-height:1.35;
    }
    .pillbar{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .pill{
      border:1px solid rgba(31,58,42,.9);
      background: linear-gradient(180deg, rgba(16,26,20,.85), rgba(13,21,17,.85));
      border-radius:999px;
      padding:10px 12px;
      box-shadow: var(--shadow);
      font-family:var(--mono);
      font-size:0.78rem;
      color:var(--text);
      display:flex;
      gap:8px;
      align-items:center;
      white-space:nowrap;
    }
    .pill b{ color:var(--accent); font-weight:700; }

    /* Layout */
    .wrap{
      padding: 16px 16px calc(96px + var(--adbar-h) + env(safe-area-inset-bottom));
      max-width:900px;
      margin:0 auto;
      display:flex;
      flex-direction:column;
      gap:14px;
    }

    /* Cards */
    .card{
      background: linear-gradient(180deg, rgba(16,26,20,.92), rgba(13,21,17,.92));
      border:1px solid rgba(31,58,42,.9);
      border-radius:var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .cardHeader{
      padding: 16px 16px 10px;
      border-bottom:1px solid rgba(31,58,42,.45);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .cardHeader h2{
      margin:0;
      font-family:var(--mono);
      font-size:0.9rem;
      letter-spacing:.4px;
      color:var(--text);
    }
    .cardBody{ padding: 12px 16px 16px; }

    /* Buttons & rows */
    .grid{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:12px;
    }
    @media (max-width: 520px){
      .grid{ grid-template-columns:1fr; }
      .pillbar{ justify-content:flex-start; }
    }
    .btn{
      -webkit-tap-highlight-color: transparent;
      border:1px solid rgba(60,255,122,.35);
      background: linear-gradient(180deg, rgba(60,255,122,.18), rgba(60,255,122,.06));
      color:var(--text);
      border-radius:16px;
      padding:14px 14px;
      font-family:var(--mono);
      cursor:pointer;
      box-shadow: 0 10px 24px rgba(0,0,0,.22);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      transition: transform .08s ease, border-color .2s ease, background .2s ease;
      user-select:none;
      min-height:64px;
      touch-action: manipulation;
      width:100%;
      text-align:left;
    }
    .btn:active{ transform: translateY(1px) scale(.99); }
    .btn[disabled]{ opacity:.55; cursor:not-allowed; transform:none; }
    .btn small{
      color:var(--muted);
      font-size:0.78rem;
      font-family:var(--sans);
      line-height:1.15;
      text-align:right;
      white-space:nowrap;
    }
    .btn .left{ display:flex; flex-direction:column; gap:4px; }
    .btn .name{ font-size:0.95rem; color:var(--accent); }
    .btn .desc{ font-family:var(--sans); font-size:0.85rem; line-height:1.25; color:var(--text); opacity:.92; }

    .rows{ display:flex; flex-direction:column; gap:10px; }
    .row{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      padding:12px 14px;
      border-radius:16px;
      border:1px solid rgba(31,58,42,.85);
      background: linear-gradient(180deg, rgba(13,21,17,.85), rgba(10,16,13,.85));
      font-family:var(--mono);
      font-size:0.8rem;
      line-height:1.25;
    }
    .row .label{ color:var(--muted); }
    .row .value{ color:var(--text); }
    .tag{
      font-family:var(--mono);
      font-size:0.72rem;
      padding:4px 10px;
      border-radius:999px;
      border:1px solid rgba(31,58,42,.9);
      color:var(--muted);
      background: rgba(0,0,0,.15);
    }
    .divider{ height:1px; background: rgba(31,58,42,.8); margin:14px 0; }

    /* Log */
    .log{
      max-height:380px;
      overflow:auto;
      border-radius:16px;
      border:1px solid rgba(31,58,42,.85);
      background: linear-gradient(180deg, rgba(10,16,13,.78), rgba(7,10,8,.78));
      padding:12px;
      font-family:var(--mono);
      font-size:0.78rem;
      line-height:1.45;
      -webkit-overflow-scrolling: touch;
    }
    .log p{ margin:0 0 10px; color:var(--text); }
    .log p span{ color:var(--muted); }

    /* Bottom tab bar */
    .tabbar{
      position:fixed;
      left:0; right:0; bottom:var(--adbar-h);
      padding: 10px 12px calc(10px + env(safe-area-inset-bottom));
      background: linear-gradient(180deg, rgba(11,15,12,.0), rgba(11,15,12,.92) 40%, rgba(11,15,12,.98));
      border-top:1px solid rgba(31,58,42,.75);
      display:flex;
      flex-wrap:nowrap;
      overflow-x:auto;
      overflow-y:hidden;
      justify-content:flex-start;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior-x: contain;
      gap:10px;
      justify-content:center;
      z-index:12;
      backdrop-filter: blur(6px);
    }
    .tabbar::-webkit-scrollbar{ display:none; }
    .tabbar{ scrollbar-width:none; }

    .tab{
      border:1px solid rgba(31,58,42,.85);
      background: linear-gradient(180deg, rgba(16,26,20,.9), rgba(13,21,17,.9));
      border-radius:16px;
      padding:12px 12px;
      flex: 0 0 auto;
      white-space: nowrap;
      font-family:var(--mono);
      color:var(--text);
      cursor:pointer;
      font-size:0.82rem;
      min-height:48px;
      touch-action: manipulation;
      display:flex;
      align-items:center;
      gap:8px;
    }
    .tab.active{
      border-color: rgba(60,255,122,.55);
      box-shadow: 0 0 0 1px rgba(60,255,122,.12), 0 10px 24px rgba(0,0,0,.24);
    }
    .tab .dot{
      width:8px; height:8px; border-radius:999px;
      background: rgba(146,199,155,.65);
    }
    .tab.active .dot{ background: var(--accent); }

    /* Screens */
    .screen{ display:none; }
    .screen.active{ display:block; }

    /* Factions */
    .bar{
      height:12px;
      border-radius:999px;
      border:1px solid rgba(31,58,42,.85);
      background: rgba(0,0,0,.25);
      overflow:hidden;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
    }
    .barFill{
      height:100%;
      width:0%;
      background: linear-gradient(90deg, rgba(60,255,122,.15), rgba(60,255,122,.9));
    }
    .factionMeta{
      display:flex;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      margin-top:10px;
    }
    .miniBtns{ display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; }
    .miniBtn{
      border:1px solid rgba(31,58,42,.85);
      background: rgba(0,0,0,.16);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      cursor:pointer;
      font-family:var(--mono);
      font-size:0.78rem;
      min-height:44px;
      touch-action: manipulation;
    }
    .miniBtn.primary{
      border-color: rgba(60,255,122,.45);
      background: linear-gradient(180deg, rgba(60,255,122,.16), rgba(60,255,122,.06));
    }
    .miniBtn.danger{
      border-color: rgba(255,107,107,.55);
    }
    .miniBtn[disabled]{ opacity:.55; cursor:not-allowed; }

    .chip{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(31,58,42,.85);
      background: rgba(0,0,0,.18);
      font-family:var(--mono);
      font-size:0.72rem;
      color:var(--text);
      white-space:nowrap;
    }
    .chip.good{ border-color: rgba(60,255,122,.45); }
    .chip.warn{ border-color: rgba(255,204,102,.55); color: var(--warn); }
    .chip.danger{ border-color: rgba(255,107,107,.55); color: var(--danger); }
    .pulse{
      animation:pulseGlow 1.2s ease-in-out infinite;
    }
    @keyframes pulseGlow{
      0%,100%{ box-shadow: 0 0 0 rgba(60,255,122,.0); }
      50%{ box-shadow: 0 0 18px rgba(60,255,122,.18); }
    }
    .bar.small{ height:8px; }

    /* Modal */
    dialog{
      width:min(720px, calc(100vw - 24px));
      border:none;
      border-radius:22px;
      background: linear-gradient(180deg, rgba(16,26,20,.98), rgba(10,16,13,.98));
      color:var(--text);
      box-shadow: 0 20px 60px rgba(0,0,0,.55);
      border:1px solid rgba(31,58,42,.9);
      padding:0;
      max-height: 92vh;
      overflow: hidden;
    }
    dialog::backdrop{ background: rgba(0,0,0,.55); backdrop-filter: blur(2px); }
    .modalHeader{
      padding:14px 14px 10px;
      border-bottom:1px solid rgba(31,58,42,.8);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .modalHeader h3{ margin:0; font-family:var(--mono); font-size:0.95rem; color:var(--accent); }
    .modalBody{padding:12px 14px 14px;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      max-height: calc(92vh - 56px);
    }

    /* Mobile menu usability */
    .modalBody .rows{ overflow: visible; }
    .modalBody .btn{ min-height:48px; }
    .modalHeader{ position: sticky; top: 0; z-index: 5; background: linear-gradient(180deg, rgba(16,26,20,.98), rgba(10,16,13,.98)); }
    .modalBody p{ margin:0 0 10px; color:var(--text); opacity:.92; font-size:0.88rem; line-height:1.35; }
    .closeBtn{
      border:1px solid rgba(31,58,42,.85);
      background: rgba(0,0,0,.18);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      cursor:pointer;
      font-family:var(--mono);
      font-size:0.8rem;
      touch-action: manipulation;
      min-height:44px;
      min-width:44px;
    }
    .kbd{
      font-family:var(--mono);
      padding:2px 8px;
      border-radius:10px;
      border:1px solid rgba(31,58,42,.85);
      background: rgba(0,0,0,.2);
      color:var(--muted);
      font-size:0.75rem;
    }
  
    /* --- Factions: clearer button hierarchy + hard-lock UI --- */
    .fActions{ margin-top:10px; display:flex; flex-direction:column; gap:10px; }
    .fbtn{
      width:100%;
      min-height:54px;
      border-radius:14px;
      padding:12px 14px;
      font-family:var(--mono);
      color: var(--text);
      font-weight: 900;
      text-transform: uppercase;
      letter-spacing: .7px;
      -webkit-appearance: none;
      appearance: none;
      touch-action:manipulation;
      border:1px solid rgba(44, 112, 68, .55);
      background:linear-gradient(180deg, rgba(8,16,12,.9), rgba(6,10,8,.92));
      box-shadow: 0 10px 24px rgba(0,0,0,.28);
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      cursor:pointer;
    }
    .fbtnPrimary{
      border-color: rgba(60,255,122,.65);
      background: linear-gradient(180deg, rgba(60,255,122,.22), rgba(60,255,122,.08));
      box-shadow: 0 0 0 1px rgba(60,255,122,.18), 0 12px 30px rgba(0,0,0,.34);
    }
    .fbtnDanger{
      border-color: rgba(255,107,107,.65);
      background: linear-gradient(180deg, rgba(255,107,107,.20), rgba(255,107,107,.06));
      box-shadow: 0 0 0 1px rgba(255,107,107,.16), 0 12px 30px rgba(0,0,0,.34);
    }
    .fbtnSecondary{
      min-height:48px;
      border-color: rgba(31,58,42,.95);
      color: var(--muted);
      font-weight: 800;
      background: linear-gradient(180deg, rgba(16,26,20,.78), rgba(13,21,17,.78));
      opacity: .98;
      box-shadow:none;
    }
    .actionRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
    }
    /* In the 3-button row we want a clear horizontal hierarchy, not full-width stacked buttons */
    .actionRow .fbtn{ width:auto; }
    .actionRow > .fbtn{ flex: 1 1 120px; }
    .fbtn[disabled]{
      opacity:.42;
      filter:saturate(.6);
      cursor:not-allowed;
    }

    /* Make it obvious these are clickable (iOS needs this sometimes) */
    .fbtn:active{ transform: translateY(1px) scale(.99); }
    .lockHint{
      margin-top:-2px;
      font-family:var(--mono);
      font-size:.72rem;
      color:var(--warn);
      opacity:.95;
    }


/* --- Factions 2.0: clean mobile list + detail card --- */
.bar.mini{ height:8px; opacity:.95; }
.fList{
  display:flex;
  flex-direction:column;
  gap:10px;
  margin-top:6px;
}
.fPick{
  width:100%;
  text-align:left;
  border-radius:16px;
  padding:12px 12px 10px;
  border:1px solid rgba(31,58,42,.85);
  background: rgba(0,0,0,.14);
  color:var(--text);
  cursor:pointer;
  touch-action:manipulation;
}
.fPick.on{
  border-color: rgba(60,255,122,.55);
  background: linear-gradient(180deg, rgba(60,255,122,.10), rgba(0,0,0,.10));
  box-shadow: 0 0 0 1px rgba(60,255,122,.12);
}
.fPickTop{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  margin-bottom:8px;
  flex-wrap:wrap;
}
.fPickName{
  font-family:var(--mono);
  color:var(--accent);
  font-size:.9rem;
  min-width: 0;
  flex: 1 1 auto;
}
.fDetail{
  margin-top:12px;
  padding:12px;
  border-radius:20px;
  border:1px solid rgba(31,58,42,.9);
  background: linear-gradient(180deg, rgba(16,26,20,.55), rgba(10,16,13,.55));
  box-shadow: 0 12px 28px rgba(0,0,0,.28);
}
.fActions2{
  display:flex;
  flex-direction:column;
  gap:12px;
  margin-top:12px;
}
.fSmall{ display:flex; flex-direction:column; gap:8px; }
.fbtn2{
  width:100%;
  min-height:54px;
  border-radius:16px;
  padding:12px 14px;
  font-family:var(--mono);
  color:var(--text);
  font-weight:900;
  letter-spacing:.6px;
  text-transform:uppercase;
  border:1px solid rgba(44,112,68,.55);
  background:linear-gradient(180deg, rgba(8,16,12,.9), rgba(6,10,8,.92));
  box-shadow: 0 10px 24px rgba(0,0,0,.28);
  cursor:pointer;
  touch-action:manipulation;
}
.fbtn2.primary{
  border-color: rgba(60,255,122,.65);
  background: linear-gradient(180deg, rgba(60,255,122,.22), rgba(60,255,122,.08));
  box-shadow: 0 0 0 1px rgba(60,255,122,.18), 0 12px 30px rgba(0,0,0,.34);
}
.fbtn2.secondary{
  min-height:48px;
  border-color: rgba(31,58,42,.95);
  color: var(--muted);
  font-weight: 800;
  text-transform:none;
  letter-spacing: 0;
  background: linear-gradient(180deg, rgba(16,26,20,.78), rgba(13,21,17,.78));
  box-shadow:none;
}
.fbtn2.danger{
  border-color: rgba(255,107,107,.65);
  background: linear-gradient(180deg, rgba(255,107,107,.20), rgba(255,107,107,.06));
  box-shadow: 0 0 0 1px rgba(255,107,107,.16), 0 12px 30px rgba(0,0,0,.34);
}
.fbtn2[disabled]{ opacity:.42; filter:saturate(.6); cursor:not-allowed; }
.fPick:active, .fbtn2:active{ transform: translateY(1px) scale(.99); }

/* --- Redesigned Faction cards --- */
.facCard{
  border-radius:20px;
  border:1px solid rgba(31,58,42,.85);
  background: linear-gradient(180deg, rgba(16,26,20,.55), rgba(10,16,13,.55));
  box-shadow: 0 12px 28px rgba(0,0,0,.28);
  padding:16px;
  margin-bottom:16px;
}
.facHead{
  display:flex;
  align-items:center;
  flex-wrap:wrap;
  gap:8px;
  font-family:var(--mono);
  font-size:0.92rem;
  color:var(--accent);
  margin-bottom:6px;
}
.facHead .tag{
  padding:2px 6px;
  border-radius:8px;
  background: rgba(60,255,122,.12);
  color: var(--accent);
  font-size:0.72rem;
}
.bar.mini{
  width:100%;
  height:6px;
  border-radius:4px;
  background: rgba(31,58,42,.55);
  margin:4px 0;
  overflow:hidden;
}
.bar.mini .barFill{
  height:100%;
  border-radius:4px;
  background: linear-gradient(90deg, rgba(60,255,122,.50), rgba(60,255,122,.18));
}
.facSub{
  display:flex;
  flex-wrap:wrap;
  gap:6px;
  margin:4px 0;
}
.facSub .tag{
  padding:2px 4px;
  border-radius:6px;
  background: rgba(31,58,42,.6);
  color: var(--muted);
  font-size:0.68rem;
  white-space:nowrap;
}
.facDesc{
  font-family: var(--sans);
  font-size:0.80rem;
  color: var(--muted);
  margin-top:4px;
}
.facNext{
  font-family: var(--mono);
  font-size:0.76rem;
  color: var(--accent);
  margin-top:4px;
}
.facActions{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  margin-top:10px;
}
.facActions .fbtn2{
  flex:1 1 100%;
  font-size:0.76rem;
  letter-spacing:0.5px;
  text-transform:uppercase;
  color: var(--accent);
  border-color: rgba(60,255,122,.55);
  background: linear-gradient(180deg, rgba(60,255,122,.12), rgba(60,255,122,.04));
}
.facActions .miniRow{
  display:flex;
  flex-wrap:wrap;
  gap:6px;
  margin-top:8px;
}
.facActions .miniRow .miniBtn{
  flex:1 1 calc(33% - 4px);
}
.lockHint{
  font-family: var(--sans);
  font-size:0.68rem;
  color: var(--muted);
  margin-top:6px;
}

  
    /* ---------- Tap feedback ---------- */
    .btn.tapFlash, .fbtn.tapFlash, .miniBtn.tapFlash, .closeBtn.tapFlash, .tab.tapFlash{
      transform: translateY(1px) scale(.99);
      filter: brightness(1.08);
    }

    /* Floating gain text */
    .popGain{
      position: fixed;
      z-index: 9999;
      pointer-events: none;
      font-family: var(--mono);
      font-size: .88rem;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      opacity: 0;
      transform: translate(-50%, 0) scale(.96);
      animation: popFly 820ms ease-out forwards;
    }
    .popGain.good{ border-color: rgba(42,214,148,.35); }
    .popGain.warn{ border-color: rgba(255,204,102,.35); }
    .popGain.danger{ border-color: rgba(255,107,107,.35); }

    @keyframes popFly{
      0%   { opacity: 0; transform: translate(-50%, 10px) scale(.96); }
      20%  { opacity: 1; }
      100% { opacity: 0; transform: translate(-50%, -36px) scale(1.02); }
    }

    /* Toasts */
    #toastHost{
      position: fixed;
      left: 50%;
      bottom: 76px;
      transform: translateX(-50%);
      width: min(520px, calc(100vw - 24px));
      z-index: 10000;
      display: flex;
      flex-direction: column;
      gap: 10px;
      pointer-events: none;
    }
    .toast{
      pointer-events: none;
      font-family: var(--sans);
      font-size: .92rem;
      line-height: 1.25;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(15,18,22,.88);
      border: 1px solid rgba(255,255,255,.12);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      opacity: 0;
      transform: translateY(8px);
      animation: toastIn 180ms ease-out forwards, toastOut 220ms ease-in forwards;
      animation-delay: 0ms, var(--toastLife, 1800ms);
    }
    .toast.good{ border-color: rgba(42,214,148,.35); }
    .toast.warn{ border-color: rgba(255,204,102,.35); }
    .toast.danger{ border-color: rgba(255,107,107,.35); }

    @keyframes toastIn{
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes toastOut{
      to { opacity: 0; transform: translateY(8px); }
    }

  
    /* Battle ops */
    .barOuter{
      width:100%;
      height:12px;
      border-radius:999px;
      border:1px solid rgba(31,58,42,.9);
      background: linear-gradient(180deg, rgba(10,16,13,.9), rgba(7,10,8,.9));
      overflow:hidden;
    }
    .barInner{
      height:100%;
      width:0%;
      background: linear-gradient(90deg, rgba(60,255,122,.9), rgba(255,204,102,.55));
      box-shadow: 0 0 18px rgba(60,255,122,.18);
      border-radius:999px;
      transition: width .25s ease;
    }
    .miniHint{ color: var(--muted); font-family: var(--sans); font-size: .82rem; line-height:1.3; }

    /* --- Battle Paths: clearer stat chips + sim overlay --- */
    .statLine{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; justify-content:flex-end; }
    .statChip{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(31,58,42,75);
      background: rgba(0,0,0,18);
      font-family: var(--mono);
      font-size: 0.78rem;
      color: var(--text);
      white-space: nowrap;
    }
    .statChip b{ font-weight: 900; letter-spacing: .04em; }

/* --- Mobile/ads-friendly layout helpers --- */
    .adtop{ position:sticky; top:0; z-index:11; }
    .adbar{
      position:fixed;
      left:0; right:0; bottom:0;
      height: calc(var(--adbar-h) + env(safe-area-inset-bottom));
      padding: 8px 12px calc(8px + env(safe-area-inset-bottom));
      background: rgba(11,15,12,.92);
      border-top:1px solid rgba(31,58,42,.65);
      display:flex;
      justify-content:center;
      align-items:center;
      z-index:13;
      backdrop-filter: blur(6px);
    }
    .ad-slot{
      width:min(100%, 480px);
      height: var(--adbar-h);
      border-radius: 14px;
      border:1px dashed rgba(182,255,204,.35);
      background: rgba(0,0,0,.18);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 12px;
      letter-spacing:.08em;
      text-transform: uppercase;
      color: rgba(219,255,232,.65);
      user-select:none;
      -webkit-user-select:none;
    }
    .ad-slot:empty::before{ content:"AD SPACE"; }
    .ad-slot.native{
      width:100%;
      height: 92px;
      margin: 10px 0 2px;
    }

    /* Mobile-first tweaks */
    @media (max-width: 640px){
      header .toprow{ gap:10px; }
      header .title h1{ font-size: 20px; letter-spacing:.12em; }
      .wrap{ max-width: 560px; padding-left:12px; padding-right:12px; }
      .btn{ padding: 14px 14px; }
      .tabbar{ gap:8px; padding-left:10px; padding-right:10px; }
      .tab{ min-width: 92px; }
    }

    /* Factions: inline expand/collapse inside each faction card (mobile-friendly) */
    .fCard{ border:1px solid rgba(31,58,42,.7); border-radius:16px; background: rgba(7,12,10,.55); overflow:hidden; }
    .fCard + .fCard{ margin-top: 10px; }
    .fPick{ width:100%; text-align:left; border:0; background: transparent; padding:12px; }
    .fPick.on{ background: rgba(34, 85, 58, .18); }
    .fInline{ display:none; padding: 0 12px 12px; }
    .fCard.expanded .fInline{ display:block; }
    .fInline .tag{ margin-right:6px; }
    .fInline .fActions2{ margin-top:10px; }
    .fInline .fbtn2{ width:100%; }


.chip{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.25);font-size:12px}
.stepBtn{min-width:44px;min-height:44px;border-radius:12px;border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.06);color:inherit;font-weight:800;font-size:20px;line-height:1}
.stepBtn:active{transform:translateY(1px)}
.card.mini{padding:12px;border-radius:14px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.04)}
</style>
</head>
<body>
  <header>
    <div class="toprow">
      <div class="title">
        <h1>WASTELAND OUTPOST</h1>
        <p class="subtitle">A Fallout‑inspired idle settlement builder (original).</p>
      </div>
      <div class="pillbar" id="topPills"></div>
    </div>
  </header>


  <div class="adtop" id="adtop" aria-label="Advertisement">
    <div class="ad-slot banner" id="adBannerTop" data-ad-slot="banner-top"></div>
  </div>

  <main class="wrap">

    <!-- CLICKER / RESOURCES -->
    <section class="screen active" id="screen-clicker">
      <div class="card">
        <div class="cardHeader"><h2>Scavenge</h2><span class="tag">Tap & automate</span></div>
        <div class="cardBody">
          <div class="grid">
            <button class="btn" id="btnScavenge">
              <div class="left">
                <div class="name">Scavenge</div>
                <div class="desc">Tap for Scrap + Food (+ a chance of Tech)</div>
              </div>
              <small><span class="kbd">tap</span><br/>+ loot</small>
            </button>

            <button class="btn" id="btnPurify">
              <div class="left">
                <div class="name">Purify Water</div>
                <div class="desc">Convert Scrap into Clean Water</div>
              </div>
              <small id="purifyCost"></small>
            </button>

            <button class="btn" id="btnRecruit">
              <div class="left">
                <div class="name">Recruit Drifter</div>
                <div class="desc">Spend Food + Water to grow population</div>
              </div>
              <small id="recruitCost"></small>
            </button>

            
            <button class="btn" id="btnTrade">
              <div class="left">
                <div class="name">Trade Scrap</div>
                <div class="desc">Swap Scrap for Caps (early economy)</div>
              </div>
              <small id="tradeCost"></small>
            </button>

            <button class="btn" id="btnHealRad">
              <div class="left">
                <div class="name">Decontaminate</div>
                <div class="desc">Spend Water to reduce Radiation</div>
              </div>
              <small id="deconCost"></small>
            </button>
          </div>

          <div class="divider"></div>
          <div class="rows" id="workerPanel"></div>
        </div>
      </div>
    </section>

    <!-- BUILDINGS -->
    <section class="screen" id="screen-build">
      <div class="card">
        <div class="cardHeader"><h2>Build</h2><span class="tag">Housing · Economy · Defense</span></div>
        <div class="cardBody">
          <div class="rows" id="buildPanel"></div>
        </div>
      </div>
    </section>

    
        <!-- BATTLE -->
    <section class="screen" id="screen-battle">
      <div class="ad-slot native" id="adNativeBattle" data-ad-slot="native-battle"></div>
      <div class="card">
        <div class="cardHeader">
          <h2>Battle</h2>
          <span class="tag" id="battleHeaderTag">Locked</span>
        </div>
        <div class="cardBody" id="battlePanel"></div>
      </div>
    </section>

<!-- TECH -->
    <section class="screen" id="screen-tech">
      <div class="card">
        <div class="cardHeader"><h2>Tech</h2><span class="tag">Upgrades</span></div>
        <div class="cardBody">
          <div class="rows" id="techPanel"></div>
        </div>
      </div>
    </section>


    <!-- FACTIONS -->
    <section class="screen" id="screen-factions">
      <div class="card">
        <div class="cardHeader"><h2>Factions</h2><span class="tag">Allies · Reputation</span></div>
        <div class="cardBody">
          <div class="rows" id="factionSummary"></div>
          <div class="divider"></div>
          <div class="rows" id="factionPanel"></div>
        </div>
      </div>
    </section>

    <!-- LOG / STATS -->
    <section class="screen" id="screen-log">
      <div class="card">
        <div class="cardHeader"><h2>Outpost</h2><span class="tag">Stats & Log</span></div>
        <div class="cardBody">
          <div class="rows" id="statRows"></div>
          <div class="divider"></div>
          <div class="log" id="log"></div>
        </div>
      </div>
    </section>

  </main>
  <div class="adbar" id="adbar" aria-label="Advertisement">
    <div class="ad-slot banner" id="adBannerBottom" data-ad-slot="banner-bottom"></div>
  </div>

  <nav class="tabbar" aria-label="Menus">
    <button class="tab active" data-screen="clicker"><span class="dot"></span>Resources</button>
    <button class="tab" data-screen="build"><span class="dot"></span>Build</button>
<button class="tab" data-screen="tech"><span class="dot"></span>Tech</button>
    <button class="tab" data-screen="battle"><span class="dot"></span>Battle</button>
    <button class="tab" data-screen="factions"><span class="dot"></span>Factions</button>
    <button class="tab" data-screen="log"><span class="dot"></span>Log</button>
    <button class="tab" id="btnMenu"><span class="dot"></span>Menu</button>
  </nav>

  <dialog id="modal">
    <div class="modalHeader">
      <h3 id="modalTitle">Menu</h3>
      <button class="closeBtn" id="modalClose">Close</button>
    </div>
    <div class="modalBody" id="modalBody"></div>
  </dialog>

<!-- Faction details are rendered inline inside each faction card -->

  <div id="toastHost" aria-live="polite" aria-atomic="true"></div>

<script>
(() => {
  // ---------- Utilities ----------
  const $ = (id) => document.getElementById(id);
  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
  const fmt = (n) => {
    if (!isFinite(n)) return "∞";
    if (Math.abs(n) < 1000) return (Math.round(n * 10) / 10).toString();
    const units = ["K","M","B","T"];
    let u = -1;
    let x = n;
    while (Math.abs(x) >= 1000 && u < units.length - 1) { x /= 1000; u++; }
    return (Math.round(x * 10) / 10) + units[u];
  };

  // Simple stat UI helper (used in Battle Paths)
  function statChipsHTML(atk, def, hp){
    return `
      <span class="statLine">
        <span class="statChip" title="Attack"><b>ATK</b> ${atk}</span>
        <span class="statChip" title="Defense"><b>DEF</b> ${def}</span>
        <span class="statChip" title="Health"><b>HP</b> ${hp}</span>
      </span>
    `;
  }
  const now = () => Date.now();


  // ---------- Micro feedback (toasts + floating text + haptics) ----------
  function haptic(ms=10){
    try{ if (navigator.vibrate) navigator.vibrate(ms); } catch {}
  }

  function toast(msg, tone=""){
    const host = $("toastHost");
    if (!host) return;
    const t = document.createElement("div");
    t.className = "toast" + (tone ? " " + tone : "");
    t.style.setProperty("--toastLife", "1700ms");
    t.textContent = msg;
    host.appendChild(t);
    // cleanup after animations
    setTimeout(() => { try{ t.remove(); } catch {} }, 2100);
  }

  function popNearEl(el, text, tone="good"){
    if (!el) return;
    const r = el.getBoundingClientRect();
    const x = r.left + (r.width/2);
    const y = r.top + Math.min(r.height*0.25, 18);
    const p = document.createElement("div");
    p.className = "popGain" + (tone ? " " + tone : "");
    p.textContent = text;
    p.style.left = x + "px";
    p.style.top  = y + "px";
    document.body.appendChild(p);
    setTimeout(() => { try{ p.remove(); } catch {} }, 900);
  }

  function flashBtn(el){
    if (!el) return;
    el.classList.add("tapFlash");
    setTimeout(() => el.classList.remove("tapFlash"), 120);
  }

  // Prefer pointerdown for mobile responsiveness; guard against double-fire (pointerdown + click)
  function bindTap(el, handler){
    let last = 0;
    const fire = (ev) => {
      const t = now();
      if (t - last < 240) return;
      last = t;
      handler(ev);
      queueSave();
};
    el.addEventListener("pointerdown", (ev) => {
      if (ev.pointerType === "mouse" && ev.button !== 0) return;
      fire(ev);
    }, { passive:true });
    el.addEventListener("click", fire);
  }


  // ---------- CivCrafter Momentum ----------
  function syncMomentum(){
    // Decay 1 momentum every 6s of inactivity
    const t = now();
    if (!S.momentumLastTick) S.momentumLastTick = t;
    const dt = t - S.momentumLastTick;
    const steps = Math.floor(dt / 6000);
    if (steps > 0){
      S.momentum = Math.max(0, (S.momentum || 0) - steps);
      S.momentumLastTick += steps * 6000;
    }
  }

  function addMomentum(n=1){
    syncMomentum();
    S.momentum = clamp((S.momentum || 0) + n, 0, 10);
    S.momentumLastTick = now();
  }

  function momentumMult(){
    syncMomentum();
    return 1 + ((S.momentum || 0) * 0.01); // +0% .. +10%
  }

  function repMilestone10(rep){
    return clamp(Math.floor((rep || 0) / 10), 0, 10);
  }


  const rewardText = (rw) => {
    if (!rw) return "—";
    const parts = [];
    for (const k of ["scrap","food","water","tech","caps"]){
      const v = rw[k] || 0;
      if (v > 0) parts.push(`${k.toUpperCase()} ${Math.floor(v)}`);
    }
    return parts.length ? parts.join(" · ") : "—";
  };

  function log(msg, tone="") {
    const el = $("log");
    if (!el) return;
    const p = document.createElement("p");
    const ts = new Date().toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"});
    p.innerHTML = `<span>[${ts}]</span> ${msg}`;
    if (tone === "warn") p.style.color = "var(--warn)";
    if (tone === "danger") p.style.color = "var(--danger)";
    el.prepend(p);
    while (el.children.length > 70) el.removeChild(el.lastChild);
  }

  // ---------- Game State ----------
  const DEFAULT = {
    // Version remains 6; expansion fields are migrated dynamically via ensureExpansion
    version: 6,
    t: now(),
    scrap: 20,
    food: 15,
    water: 10,
    tech: 0,
    caps: 25,
    rad: 0,
    pop: 3,
    idle: 3,
    scav: 0,
    farmers: 0,
    purifiers: 0,
    militia: 0,
    // Expansion roles (initialize to 0)
    engineers: 0,
    medics: 0,
    researchers: 0,
    scouts: 0,
    propagandists: 0,
    fixers: 0,
    shack: 0,
    farm: 0,
    purifier: 0,
    turret: 0,
    // Expansion buildings
    annex: 0,
    cmdcenter: 0,
    hospital: 0,
    blackmarket: 0,
    lab: 0,
    depot: 0,
    techs: { workshop:false, radio:false, medbay:false, caravan:false },
    day: 1,
    raidsWon: 0,


    // Combat / Raids
    combatUnlocked: false,
    trophies: 0,
    raidMarks: 0,
    combatUnits: { riflemen:0, snipers:0, power:0, mutants:0, robots:0, mercs:0 },
    raidHistory: [],
    raidTarget: null,
    lastRaidAt: 0,

    // Expansion resources
    medData: 0,
    breakthroughs: 0,
    strain: 0,

    // CivCrafter: session momentum
    momentum: 0,
    momentumLastTick: 0,

    // Expansion: meta-progression
    prestige: { level: 0, tokens: 0 },
    // Expansion: daily quest
    quests: { last: 0, done: false, target: null, progress: 0, rewardCaps: 40, rewardTech: 2 },

    
    // Expansion: factions
    factions: {
      active: null,              // sponsored faction (one at a time)
      cooldownUntil: 0,          // timestamp; prevents rapid swapping
      uiSelected: "bos",         // which faction card is open in the UI
      streakId: null,            // last faction you completed a contract for
      streak: 0,                 // 0..5 (adds small bonus to keep you looping)
      units: {},              // purchased faction special units by faction id
      // reputation and rank tables per faction
      rep: { bos: 0, ncr: 0, followers: 0, raiders: 0, enclave: 0 },
      rank: { bos: 0, ncr: 0, followers: 0, raiders: 0, enclave: 0 },
      // permanent alignment with one faction (locks out others)
      aligned: null,
      // track if we've shown the alignment offer for each faction
      alignmentOffered: {},
      // faction‑specific currency earned from donations and missions
      currency: { bos: 0, ncr: 0, followers: 0, raiders: 0, enclave: 0 },
    },

    // Expansion: faction contract (one at a time; feels like CivCrafter "send a party")
    contract: {
      active: false,
      faction: null,
      name: null,
      tier: 0,           // 0 quick, 1 deep
      started: 0,
      end: 0,
      busy: 0,           // settlers committed
      repGain: 0,
      reward: null,      // {scrap, food, water, tech, caps}
      ready: false
    },
  

    // Battle: operations (send militia out; they don't defend while away)
    ops: {
      selected: "patrol", // "patrol" | "raid" | "assault"
      active: null,       // { type, started, end, busy, threat, chance, supplies:{food,water}, rewards:{scrap,food,caps,techChance}, ready }
      lastReport: null    // string
    },
};

  // Save key bumped because layout & version changed
  const KEY = "wasteland_outpost_save_v5";

  let S = load() || structuredClone(DEFAULT);

  // ---------- Balancing ----------
  function housingCap() {
    return 3 + S.shack * 4 + (S.techs.workshop ? 3 : 0);
  }

  function opsBusyMilitia(){
    const a = S.ops && S.ops.active;
    if (!a) return 0;
    if (a.ready) return 0;
    return Math.max(0, a.busy|0);
  }
  function availableMilitia(){
    return Math.max(0, (S.militia|0) - opsBusyMilitia());
  }

  function defensePower(){
    return availableMilitia() * 1.0 + S.turret * 2.2 + (S.techs.medbay ? 0.4 : 0);}
  function productionPerSec() {
    // global multipliers from Engineers
    const engMult = 1 + (S.engineers || 0) * 0.02;
    // base rates
    let scavRate = (0.6 + S.shack*0.03) * S.scav * engMult;
    let foodRate = (0.45 + S.farm*0.12) * S.farmers * engMult;
    let waterRate = (0.35 + S.purifier*0.18) * S.purifiers * engMult;
    // tech comes from scavengers (workshop) and engineers
    let techRate = (S.techs.workshop ? 0.05 : 0) * S.scav + (S.engineers || 0) * 0.1;
    let capsRate = (S.techs.caravan ? 0.08 : 0) * (S.pop);
    // rad gain slowed by medics
    let radGain = Math.max(0, (S.pop * 0.002 + S.day * 0.0007) * (S.techs.medbay ? 0.55 : 1));
    if (S.medics) {
      radGain *= Math.max(0.1, 1 - 0.05 * S.medics);
    }
    const foodUse = S.pop * 0.10;
    const waterUse = S.pop * 0.08;
    return { scavRate, foodRate, waterRate, techRate, capsRate, foodUse, waterUse, radGain };
  }
  function recruitCost() {
    const baseF = 10 + Math.floor(S.pop * 1.6);
    const baseW = 7 + Math.floor(S.pop * 1.2);
    return { food: baseF, water: baseW };
  }
  function purifyCost() {
    const scrap = 6 + Math.floor(S.purifier * 2.5);
    return { scrap, waterGain: 5 + Math.floor(S.purifier * 0.9) };
  }
  function deconCost() {
    // Water -> reduce rad; medbay makes it more efficient
    const w = 6 + Math.floor(S.pop * 0.6);
    let radDown = (S.techs.medbay ? 14 : 10);
    // Followers can help you scrub RAD harder
    if (S.factions && S.factions.active === "followers") {
      const r = (S.factions.rank && S.factions.rank.followers) ? S.factions.rank.followers : 0;
      radDown += r * 3;
    }
    return { water: w, radDown };
  }

  function tradeCost() {
    // Early-game: trade scrap to get caps so you can build housing/defense.
    // Scales gently so it stays useful but not broken.
    const scrap = 16 + Math.floor((S.shack + S.turret) * 4) + Math.floor(S.pop * 1.5);
    const capsGain = 10 + Math.floor(S.day * 0.6);
    return { scrap, capsGain };
  }
  function raidPlan() {
    const threat = 2.2 + S.day * 0.35 + (S.raidsWon * 0.7) + (S.pop * 0.08);
    const your = defensePower();
    const chance = clamp(0.15 + (your - threat) * 0.18, 0.05, 0.9);
    const lootScrap = Math.floor(12 + threat * 8);
    const lootFood = Math.floor(6 + threat * 3);
    const lootTech = Math.random() < 0.25 ? 1 : 0;
    const lootCaps = Math.floor(4 + threat * 4);
    return { threat, your, chance, lootScrap, lootFood, lootTech, lootCaps };
  }

  // ===================== Expansion: Prestige + Daily Quest =====================

  function prestigeBonus(){
    const lvl = S.prestige?.level || 0;
    return { prod: 1 + lvl * 0.12, caps: 1 + lvl * 0.20, radRes: 1 + lvl * 0.08 };
  }

  const _baseProductionPerSec = productionPerSec;
  productionPerSec = function(){
    const p = _baseProductionPerSec();
    const b = prestigeBonus();
    p.scavRate *= b.prod;
    p.foodRate *= b.prod;
    p.waterRate *= b.prod;
    p.techRate *= b.prod;
    p.capsRate *= b.caps;
    p.radGain /= b.radRes;
    return p;
  };

  // ===================== Expansion: Factions =====================

  const FACTIONS = {
    bos: {
      name: "Brotherhood of Steel",
      tag: "Tech · Defense",
      desc: "Donate components. Get patrols and turret upgrades.",
      currencyName: "Tech Relic",
      bonusesByRank: [
        { defFlat: 0, prod: 1, caps: 1, radRes: 1, loot: 1 },
        { defFlat: 0.8, prod: 1.00, caps: 1.00, radRes: 1.02, loot: 1.00 },
        { defFlat: 1.6, prod: 1.02, caps: 1.00, radRes: 1.05, loot: 1.00 },
        { defFlat: 2.6, prod: 1.04, caps: 1.02, radRes: 1.08, loot: 1.00 },
      ],
      donate: { tech: 2, scrap: 20, repGain: 6 },
      specialUnit: { name: "Paladin Knight", desc: "Heavily armored fighters.", cost: 5 },
    },
    ncr: {
      name: "NCR",
      tag: "Order · Economy",
      desc: "Fund a local outpost. Get caps flow and stability.",
      currencyName: "Authority",
      bonusesByRank: [
        { defFlat: 0, prod: 1, caps: 1, radRes: 1, loot: 1 },
        { defFlat: 0.3, prod: 1.00, caps: 1.08, radRes: 1.02, loot: 1.00 },
        { defFlat: 0.6, prod: 1.01, caps: 1.14, radRes: 1.04, loot: 1.00 },
        { defFlat: 1.0, prod: 1.02, caps: 1.20, radRes: 1.06, loot: 1.00 },
      ],
      donate: { caps: 18, scrap: 12, repGain: 6 },
      specialUnit: { name: "Ranger", desc: "Elite marksmen and scouts.", cost: 5 },
    },
    followers: {
      name: "Followers of the Apocalypse",
      tag: "Aid · Radiation",
      desc: "Stock their clinics. Get better decon and slower rad.",
      currencyName: "Influence",
      bonusesByRank: [
        { defFlat: 0, prod: 1, caps: 1, radRes: 1, loot: 1 },
        { defFlat: 0.0, prod: 1.01, caps: 1.00, radRes: 1.10, loot: 1.00 },
        { defFlat: 0.0, prod: 1.02, caps: 1.00, radRes: 1.18, loot: 1.00 },
        { defFlat: 0.2, prod: 1.03, caps: 1.00, radRes: 1.26, loot: 1.00 },
      ],
      donate: { water: 18, food: 14, repGain: 6 },
      specialUnit: { name: "Field Medic", desc: "Support unit that reduces losses.", cost: 4 },
    },
    raiders: {
      name: "Raiders",
      tag: "Loot · Risk",
      desc: "Pay tribute. Get bigger raid hauls (but it gets messy).",
      currencyName: "Fear",
      bonusesByRank: [
        { defFlat: 0, prod: 1, caps: 1, radRes: 1, loot: 1 },
        { defFlat: 0.0, prod: 1.00, caps: 1.00, radRes: 0.98, loot: 1.10 },
        { defFlat: 0.0, prod: 1.00, caps: 1.00, radRes: 0.95, loot: 1.20 },
        { defFlat: 0.0, prod: 1.01, caps: 1.00, radRes: 0.92, loot: 1.30 },
      ],
      donate: { caps: 14, food: 10, repGain: 6 },
      specialUnit: { name: "Berserker", desc: "Brutal shock troops.", cost: 4 },
    },
    enclave: {
      name: "Enclave",
      tag: "Science · Power",
      desc: "Trade data. Get tech salvage and production boosts.",
      currencyName: "Clearance",
      bonusesByRank: [
        { defFlat: 0, prod: 1, caps: 1, radRes: 1, loot: 1 },
        { defFlat: 0.4, prod: 1.04, caps: 1.00, radRes: 1.02, loot: 1.00 },
        { defFlat: 0.8, prod: 1.07, caps: 1.00, radRes: 1.04, loot: 1.00 },
        { defFlat: 1.2, prod: 1.10, caps: 1.02, radRes: 1.06, loot: 1.00 },
      ],
      donate: { tech: 2, caps: 16, repGain: 6 },
      specialUnit: { name: "Power Trooper", desc: "Advanced power armor troopers.", cost: 6 },
    },
  };

  const RANKS = [
    { name:"Neutral", min: 0 },
    { name:"Trusted", min: 20 },
    { name:"Ally", min: 50 },
    { name:"Champion", min: 80 },
  ];

  
function ensureFactions(){
  // Back/forward compatible init
  if (!S.factions) S.factions = structuredClone(DEFAULT.factions);

  // Legacy keys
  if (S.factions.active === undefined) S.factions.active = null;
  if (S.factions.rep === undefined) S.factions.rep = structuredClone(DEFAULT.factions.rep);
  if (S.factions.rank === undefined) S.factions.rank = structuredClone(DEFAULT.factions.rank);

  // New keys (clean mobile faction UI + addictive streak loop)
  if (S.factions.cooldownUntil === undefined) S.factions.cooldownUntil = 0;
  if (S.factions.uiSelected === undefined) S.factions.uiSelected = (S.factions.active || "bos");
  if (S.factions.streakId === undefined) S.factions.streakId = null;
  if (S.factions.streak === undefined) S.factions.streak = 0;
  if (S.factions.units === undefined) S.factions.units = {};
  // Donation pacing (prevents infinite spam and makes choices meaningful)
  if (S.factions.donateCount === undefined) S.factions.donateCount = {};
  if (S.factions.lastDonateAt === undefined) S.factions.lastDonateAt = {};

  // Ensure all factions exist (safe if new factions are added later)
  for (const id of Object.keys(FACTIONS)){
    if (S.factions.rep[id] === undefined) S.factions.rep[id] = 0;
    if (S.factions.rank[id] === undefined) S.factions.rank[id] = 0;
    if (S.factions.units[id] === undefined) S.factions.units[id] = 0;
    // ensure currency field exists per faction
    if (!S.factions.currency) S.factions.currency = {};
    if (S.factions.currency[id] === undefined) S.factions.currency[id] = 0;
    if (S.factions.donateCount[id] === undefined) S.factions.donateCount[id] = 0;
    if (S.factions.lastDonateAt[id] === undefined) S.factions.lastDonateAt[id] = 0;
  }
  // new alignment state
  if (S.factions.aligned === undefined) S.factions.aligned = null;
  if (S.factions.alignmentOffered === undefined) S.factions.alignmentOffered = {};
  // Clamp
  if (S.factions.streak < 0) S.factions.streak = 0;
  if (S.factions.streak > 5) S.factions.streak = 5;
}

// Ensure expansion-related fields exist on the save state. Without this, referencing
// new roles/buildings/resources will throw errors if loaded from an older save.
function ensureExpansion(){
  // Default values for new properties introduced in the expansion
  const defaults = {
    annex: 0,
    cmdcenter: 0,
    hospital: 0,
    blackmarket: 0,
    lab: 0,
    depot: 0,
    engineers: 0,
    medics: 0,
    researchers: 0,
    scouts: 0,
    propagandists: 0,
    fixers: 0,
    medData: 0,
    breakthroughs: 0,
    strain: 0,

    // Combat / Raids (Fallout automated battles)
    combatUnlocked: false,
    trophies: 0,
    raidMarks: 0,
    combatUnits: { riflemen:0, snipers:0, power:0, mutants:0, robots:0, mercs:0 },
    raidHistory: [],
    raidTarget: null,
    lastRaidAt: 0,
  };
  for (const k of Object.keys(defaults)) {
    if (S[k] === undefined || S[k] === null) {
      S[k] = defaults[k];
    }
  }
}

  function ensureContract(){
    if (!S.contract) S.contract = structuredClone(DEFAULT.contract);
    if (S.contract.active === undefined) S.contract.active = false;
    if (S.contract.busy === undefined) S.contract.busy = 0;
    if (S.contract.ready === undefined) S.contract.ready = false;
  }

  function contractActive(){ ensureContract(); return !!S.contract.active; }
  function contractReady(){ ensureContract(); return !!S.contract.ready; }
  function contractTimeLeft(){ ensureContract(); return Math.max(0, (S.contract.end || 0) - now()); }
  function fmtTime(ms){
    const s = Math.ceil(ms/1000);
    const m = Math.floor(s/60);
    const r = s%60;
    return m>0 ? `${m}m ${r}s` : `${r}s`;
  }

  function fmtShortTimeAgo(ts){
    const d = Math.max(0, now() - (ts||0));
    const s = Math.floor(d/1000);
    if (s < 60) return `${s}s ago`;
    const m = Math.floor(s/60);
    if (m < 60) return `${m}m ago`;
    const h = Math.floor(m/60);
    if (h < 48) return `${h}h ago`;
    const days = Math.floor(h/24);
    return `${days}d ago`;
  }

  function contractDefForFaction(id, tier){
    // CivCrafter-like: short addictive loops with scaling rewards.
    const rep = clamp(S.factions.rep[id] || 0, 0, 100);
    const rank = clamp(S.factions.rank[id] || rankForRep(rep), 0, 3);
    const day = Math.max(1, Math.floor(S.day));
    const base = 10 + day*2 + rank*6;
    const mult = tier===1 ? 2.4 : 1.0;
    const dur = tier===1 ? 6*60*1000 : 90*1000;
    const repGain = tier===1 ? (6 + rank*2) : (3 + rank);

    // Rewards flavored by faction.
    let reward = { scrap: Math.floor(base*mult), food: 0, water: 0, tech: 0, caps: 0 };
    if (id === "bos") { reward.tech = (tier===1 ? 2 : 1) + (Math.random()<0.25?1:0); reward.caps = Math.floor(6*mult); }
    if (id === "ncr") { reward.caps = Math.floor((12 + day)*mult); reward.food = Math.floor(6*mult); }
    if (id === "followers") { reward.water = Math.floor(10*mult); reward.food = Math.floor(8*mult); reward.tech = (Math.random()<0.2?1:0); }
    if (id === "raiders") { reward.caps = Math.floor(10*mult); reward.food = Math.floor(10*mult); reward.scrap = Math.floor(base*mult*1.25); }
    if (id === "enclave") { reward.tech = (tier===1 ? 3 : 1) + (Math.random()<0.35?1:0); reward.scrap = Math.floor(base*mult*0.9); reward.caps = Math.floor(6*mult); }

    // Rare "Relic" drop chance -> extra TECH
    const relicChance = tier===1 ? 0.18 : 0.07;
    return { dur, repGain, reward, relicChance, rank };
  }

  function canStartContract(){
    ensureContract();
    if (S.contract.active || S.contract.ready) return false;
    // Can start if we have at least one idle settler available
    return (S.idle || 0) >= 1;
  }

  function startContract(id, tier){
    ensureFactions(); ensureContract();
    if (!FACTIONS[id]) return;
    const rep = clamp(S.factions.rep[id] || 0, 0, 100);
    if (tier === 1 && rep < 20){ log("Deep expeditions require REP 20+. Do a few Quick Runs or donate supplies.", "warn"); return; }
    // determine costs for militia and supplies (quick missions use 0 militia)
    const costMilitia = (tier === 1 ? 1 : 0);
    const costFood    = (tier === 1 ? 8 : 4);
    const costWater   = (tier === 1 ? 4 : 2);
    // Check resource availability
    if ((S.militia || 0) < costMilitia){ log(`Not enough Militia to send (${costMilitia} required).`, "warn"); return; }
    if ((S.food || 0) < costFood){ log(`Not enough Food to send (${costFood} required).`, "warn"); return; }
    if ((S.water || 0) < costWater){ log(`Not enough Water to send (${costWater} required).`, "warn"); return; }
    // Deduct costs up front; always deduct 1 idle settler
    S.idle   -= 1;
    if (costMilitia > 0) S.militia -= costMilitia;
    S.food   -= costFood;
    S.water  -= costWater;
    const def = contractDefForFaction(id, tier);
    S.contract.active  = true;
    S.contract.faction = id;
    S.contract.tier    = tier;
    S.contract.started = now();
    S.contract.end     = now() + def.dur;
    // busy stores militia committed; they'll return later (minus casualties)
    S.contract.busy    = costMilitia;
    S.contract.repGain = def.repGain;
    S.contract.reward  = def.reward;
    S.contract.ready   = false;
    S.contract.relicChance = def.relicChance;

    const label = tier===1 ? "Deep Expedition" : "Quick Run";
    const fName = FACTIONS[id].name;
    log(`${label} dispatched for ${fName}. Used ${costMilitia} Militia, ${costFood} Food, ${costWater} Water. ETA ${fmtTime(def.dur)}.`, "warn");
  }

  
function finishContract(){
  ensureContract(); ensureFactions();
  if (!S.contract.active) return;

  // Return the idle settler that was sent on the mission
  S.idle += 1;
  // Return the committed militia (may suffer casualties). We treat 'busy' as number of militia used.
  const committed = S.contract.busy || 0;
  let casualties = 0;
  // Casualty chance: higher for deep expeditions
  const tier = S.contract.tier || 0;
  for (let i=0; i<committed; i++){
    const deathChance = (tier === 1 ? 0.4 : 0.2);
    if (Math.random() < deathChance) casualties++;
  }
  const returning = Math.max(0, committed - casualties);
  if (committed > 0) S.militia += returning;
  if (casualties > 0){
    log(`${casualties} militia were lost during the mission.`, "danger");
  }

  const id = S.contract.faction;
  const baseReward = S.contract.reward || {};

  // ===== Streak (addictive micro-loop): keep running jobs for the same faction =====
  if (id){
    if (S.factions.streakId === id) {
      S.factions.streak = clamp((S.factions.streak||0) + 1, 0, 5);
    } else {
      S.factions.streakId = id;
      S.factions.streak = 1;
    }
  } else {
    S.factions.streakId = null;
    S.factions.streak = 0;
  }

  const streak = (S.factions.streakId === id) ? (S.factions.streak||0) : 0;
  const streakMult = 1 + Math.max(0, streak - 1) * 0.05; // up to +20%
  const reward = {};
  for (const k of ["scrap","food","water","tech","caps"]){
    reward[k] = Math.floor((baseReward[k] || 0) * streakMult);
    S[k] += reward[k];
  }

  // REP gain (small extra per streak step after the first)
  let repGain = (S.contract.repGain || 0) + Math.max(0, streak - 1);
  if (id && S.factions.rep[id] !== undefined){
    const before = S.factions.rep[id] || 0;
    addRep(id, repGain);
    const after = S.factions.rep[id] || 0;
    // If we didn't move (already capped) keep rank synced
    S.factions.rank[id] = rankForRep(after);
  }

  // Relic drop
  if (Math.random() < (S.contract.relicChance || 0)) {
    const extra = 1 + (S.contract.tier===1 ? 1 : 0);
    S.tech += extra;
    log(`Relic recovered! +${extra} TECH.`, "warn");
  }

  // Award faction currency based on mission tier (quick=1, deep=2)
  if (id && S.factions && S.factions.currency){
    const currencyGain = (S.contract.tier === 1 ? 2 : 1);
    S.factions.currency[id] = (S.factions.currency[id] || 0) + currencyGain;
    log(`Mission reward: +${currencyGain} ${FACTIONS[id].currencyName}.`, "warn");
  }

  // Flavor
  const bits = [];
  if (reward.scrap) bits.push(`+${reward.scrap} Scrap`);
  if (reward.food) bits.push(`+${reward.food} Food`);
  if (reward.water) bits.push(`+${reward.water} Water`);
  if (reward.tech) bits.push(`+${reward.tech} Tech`);
  if (reward.caps) bits.push(`+${reward.caps} Caps`);
  const streakBit = streak >= 2 ? ` · Streak x${fmt(streakMult)} (+${Math.max(0,streak-1)} REP)` : ``;
  log(`Contract complete (${FACTIONS[id]?.name || "Faction"}). ${bits.join(", ")}. +${repGain} REP${streakBit}.`, "warn");

  S.contract.active = false;
  S.contract.ready = false;
  S.contract.faction = null;
  S.contract.name = null;
  S.contract.reward = null;
  S.contract.busy = 0;
  S.contract.repGain = 0;
  S.contract.end = 0;
}

  function checkContract(){
    ensureContract();
    if (!S.contract.active) return;
    if (!S.contract.ready && now() >= (S.contract.end || 0)) {
      S.contract.ready = true;
      log("A runner returns at the gates. Contract ready to collect.", "warn");
    }
  }

  function collectContract(){
    ensureContract();
    // Robust: allow collection even if the "ready" flag didn't update (e.g. timers paused in background on mobile)
    if (!S.contract.active) return;

    // If time has elapsed, mark ready now
    if (!S.contract.ready && now() >= (S.contract.end || 0)) {
      S.contract.ready = true;
    }

    if (!S.contract.ready) {
      toast(`Not ready yet — ${fmtTime(contractTimeLeft())} left.`, "warn");
      return;
    }
    finishContract();
  }

  function rankForRep(rep){
    if (rep >= 80) return 3;
    if (rep >= 50) return 2;
    if (rep >= 20) return 1;
    return 0;
  }

  function rankName(r){
    return (RANKS[r] && RANKS[r].name) || "Neutral";
  }

  function activeFactionBonus(){
    ensureFactions();
    const id = S.factions.active;
    if (!id || !FACTIONS[id]) return { defFlat:0, prod:1, caps:1, radRes:1, loot:1 };

    const rep = clamp(S.factions.rep[id] || 0, 0, 100);
    const r = clamp(S.factions.rank[id] || 0, 0, 3);

    const base = FACTIONS[id].bonusesByRank[r] || { defFlat:0, prod:1, caps:1, radRes:1, loot:1 };

    // CivCrafter: frequent micro-progress (every 10 REP)
    const m10 = repMilestone10(rep); // 0..10
    const micro = 1 + (m10 * 0.006); // up to +6%

    return {
      defFlat: base.defFlat || 0,
      prod: (base.prod || 1) * micro,
      caps: (base.caps || 1) * micro,
      radRes: (base.radRes || 1),
      loot: (base.loot || 1) * micro
    };
  }

function addRep(id, amount){
    ensureFactions();
    if (!FACTIONS[id]) return;
    const before = S.factions.rep[id] || 0;
    const after = clamp(before + amount, 0, 100);
    S.factions.rep[id] = after;
    const rb = rankForRep(before);
    const ra = rankForRep(after);
    if (ra > rb){
      S.factions.rank[id] = ra;
      log(`${FACTIONS[id].name} reputation reached ${rankName(ra)} (${Math.round(after)}/100).`, "warn");
    } else {
      S.factions.rank[id] = Math.max(S.factions.rank[id] || 0, ra);
    }

    // Check if this reputation gain should trigger an alignment offer
    maybeOfferAlignment(id);
  }

  // Offer permanent alignment when certain reputation thresholds are crossed
  function maybeOfferAlignment(id){
    ensureFactions();
    // if already aligned, do nothing
    if (S.factions.aligned) return;
    // ensure this faction exists
    if (!FACTIONS[id]) return;
    const rep = S.factions.rep[id] || 0;
    // only offer once per faction at threshold >=50
    if (rep < 50) return;
    if (S.factions.alignmentOffered && S.factions.alignmentOffered[id]) return;
    // mark as offered so we don't repeat
    if (!S.factions.alignmentOffered) S.factions.alignmentOffered = {};
    S.factions.alignmentOffered[id] = true;
    // simple confirmation prompt; if accepted, align permanently
    const name = FACTIONS[id].name || id;
    const ok = window.confirm(`${name} has offered to formally align with your settlement.\nThis choice is permanent and all other factions will disappear. Accept?`);
    if (ok) {
      alignFaction(id);
    }
  }

  // Permanently align with a faction; hide others and set as sponsor
  function alignFaction(id){
    ensureFactions();
    if (!FACTIONS[id]) return;
    S.factions.aligned = id;
    // set as sponsor if none or different
    if (!S.factions.active || S.factions.active !== id) S.factions.active = id;
    // reset rep and rank of other factions to zero to avoid UI confusion
    for (const k of Object.keys(FACTIONS)){
      if (k !== id) {
        S.factions.rep[k] = 0;
        S.factions.rank[k] = 0;
        S.factions.currency[k] = 0;
      }
    }
    // update UI
    log(`Your settlement has pledged allegiance to the ${FACTIONS[id].name}. Other factions are no longer available.`, "warn");
    renderAll();
    queueSave();
  }

  function canDonateFaction(id){
    const p = donatePlan(id);
    if (!p) return false;
    if (p.cooldownLeft > 0) return false;
    return Object.entries(p.cost).every(([k,v]) => (S[k] || 0) >= v);
  }

  function donatePlan(id){
    ensureFactions();
    const base = FACTIONS[id]?.donate;
    if (!base) return null;

    // Donation costs scale to prevent infinite spam + make late-game contributions meaningful.
    const n = (S.factions.donateCount && (S.factions.donateCount[id]||0)) || 0;
    const day = Math.max(1, Math.floor(S.day||1));
    const mult = 1 + (n * 0.18) + (day * 0.015);

    const cost = {};
    for (const [k,v] of Object.entries(base)){
      if (k === "repGain") continue;
      cost[k] = Math.max(1, Math.ceil(v * mult));
    }

    const cooldownMs = 6500;
    const last = (S.factions.lastDonateAt && (S.factions.lastDonateAt[id]||0)) || 0;
    const cooldownLeft = Math.max(0, (last + cooldownMs) - now());

    return {
      cost,
      baseRepGain: base.repGain || 1,
      tokenGain: 1,
      mult,
      cooldownLeft
    };
  }

  function donateToFaction(id){
    const p = donatePlan(id);
    if (!p) return;
    if (p.cooldownLeft > 0){ toast(`Donation teams re-stocking — ${fmtTime(p.cooldownLeft)}.`, "warn"); return; }
    if (!canDonateFaction(id)) { log("Not enough supplies to donate.", "warn"); return; }

    for (const [k,v] of Object.entries(p.cost)){
      S[k] -= v;
    }

    // Track scaling + cooldown
    S.factions.donateCount[id] = (S.factions.donateCount[id]||0) + 1;
    S.factions.lastDonateAt[id] = now();

    const mm = momentumMult();
    const repGain = Math.max(1, Math.floor((p.baseRepGain || 1) * mm));
    addRep(id, repGain);
    addMomentum(1);
    // Award one unit of faction currency per donation
    if (S.factions && S.factions.currency) {
      S.factions.currency[id] = (S.factions.currency[id] || 0) + (p.tokenGain||1);
    }
    log(`Donation delivered to ${FACTIONS[id].name}. +${repGain} REP. +${p.tokenGain||1} ${FACTIONS[id].currencyName}.` + (mm>1?` (Momentum +${Math.round((mm-1)*100)}%)`:``), "warn");
  }

  

  function canBuyFactionUnit(fid){
    ensureFactions();
    if (!S.factions.aligned || S.factions.aligned !== fid) return false;
    const unit = FACTIONS[fid]?.specialUnit;
    if (!unit) return false;
    const curr = (S.factions.currency && S.factions.currency[fid]) || 0;
    return curr >= (unit.cost || 0);
  }

  function purchaseSpecialUnit(fid){
    ensureFactions();
    if (!S.factions.aligned || S.factions.aligned !== fid){
      log("You can only buy units from your aligned faction.", "warn");
      return;
    }
    const unit = FACTIONS[fid]?.specialUnit;
    if (!unit){ log("No shop items available.", "warn"); return; }
    if (!S.factions.currency) S.factions.currency = {};
    const curr = S.factions.currency[fid] || 0;
    if (curr < unit.cost){
      log(`Not enough ${FACTIONS[fid].currencyName} (need ${unit.cost}).`, "warn");
      return;
    }
    S.factions.currency[fid] = curr - unit.cost;
    if (!S.factions.units) S.factions.units = {};
    S.factions.units[fid] = (S.factions.units[fid] || 0) + 1;
    log(`${unit.name} recruited.`, "warn");
  }

  function openFactionShop(fid){
    ensureFactions();
    if (!S.factions.aligned || S.factions.aligned !== fid){
      log("No access to that shop.", "warn");
      return;
    }
    const fac = FACTIONS[fid];
    const unit = fac.specialUnit;
    const currName = fac.currencyName || "Tokens";
    const curr = (S.factions.currency && S.factions.currency[fid]) || 0;
    const owned = (S.factions.units && S.factions.units[fid]) || 0;

    // Flavor title
    const titleMap = {
      bos: "Brotherhood Quartermaster",
      ncr: "NCR Logistics Office",
      followers: "Followers Supply Cache",
      raiders: "Raider Fence",
      enclave: "Enclave Armory"
    };
    const title = titleMap[fid] || (fac.name + " Shop");

    const body = `
      <p><span class="tag">${currName}: ${curr}</span> <span class="tag">Owned: ${owned}</span></p>
      <div class="rows" style="gap:12px;">
        <button class="btn" id="shopBuyUnit" ${curr < unit.cost ? "disabled" : ""}>
          <div class="left">
            <div class="name">${unit.name} <span class="tag">x${owned}</span></div>
            <div class="desc">${unit.desc}</div>
          </div>
          <small>${currName.toUpperCase()} ${unit.cost}</small>
        </button>
      </div>
    `;
    showModal(title, body);
    setTimeout(() => {
      const b = document.getElementById("shopBuyUnit");
      if (b){
        b.onclick = () => {
          purchaseSpecialUnit(fid);
          closeModal();
          renderAll();
          queueSave();
        };
      }
    }, 0);
  }


function sponsorCost(nextId){
  // Simple, readable: switching sponsors costs caps, scales gently with your day
  const day = Math.max(1, Math.floor(S.day||1));
  const base = 18 + Math.floor(day * 1.2);
  return base;
}

function canSwapSponsor(){
  ensureFactions();
  const left = Math.max(0, (S.factions.cooldownUntil||0) - now());
  return left <= 0;
}

function sponsorFaction(id){
  ensureFactions();
  if (!FACTIONS[id]) return;

  const rep = S.factions.rep[id] || 0;
  if (rep < 20){ log("Earn at least 20 REP to get a faction sponsor.", "warn"); return; }

  const left = Math.max(0, (S.factions.cooldownUntil||0) - now());
  if (left > 0){
    toast(`Sponsor locked — ${fmtTime(left)} remaining.`, "warn");
    return;
  }

  const prev = S.factions.active;
  if (prev === id){ toast("Already your sponsor.", "warn"); return; }

  // First sponsor is free; swaps cost caps
  if (prev){
    const cost = sponsorCost(id);
    if (S.caps < cost){ log(`Not enough Caps to switch sponsor (need ${cost}).`, "warn"); return; }
    S.caps -= cost;
  }

  S.factions.active = id;
  S.factions.uiSelected = id;

  // Cooldown (mobile-friendly pacing)
  S.factions.cooldownUntil = now() + 10*60*1000;

  // Reset streak when you swap sponsors (keeps choices meaningful)
  S.factions.streakId = null;
  S.factions.streak = 0;

  log(`Sponsor secured: ${FACTIONS[id].name}.`, "warn");
}

function clearActiveFaction(){
  ensureFactions();
  if (!S.factions.active) return;
  const prev = S.factions.active;
  S.factions.active = null;
  S.factions.uiSelected = S.factions.uiSelected || "bos";
  S.factions.streakId = null;
  S.factions.streak = 0;
  log(`You ended your sponsorship with ${FACTIONS[prev]?.name || "a faction"}.`, "warn");
}

  // Apply faction bonuses to production and defense (layered on top of prestige).
  const _prodAfterPrestige = productionPerSec;
  productionPerSec = function(){
    const p = _prodAfterPrestige();
    const b = activeFactionBonus();
    p.scavRate *= b.prod;
    p.foodRate *= b.prod;
    p.waterRate *= b.prod;
    p.techRate *= b.prod;
    p.capsRate *= b.caps;
    p.radGain /= (b.radRes || 1);
    return p;
  };

  const _baseDefensePower = defensePower;
  defensePower = function(){
    const base = _baseDefensePower();
    const b = activeFactionBonus();
    return base + (b.defFlat || 0);
  };

  function canPrestige(){
    return (S.pop >= 25) || (S.raidsWon >= 12) || (S.tech >= 50);
  }

  function prestigeGainEstimate(){
    const score = (S.pop * 1.5) + (S.raidsWon * 3) + (S.tech * 0.6) + (S.turret * 4);
    return Math.max(1, Math.floor(score / 35));
  }

  function doPrestige(){
    if (!canPrestige()){
      log("Not ready to reset yet. Grow pop, win raids, or stockpile tech.", "warn");
      return;
    }
    const gained = prestigeGainEstimate();
    const prev = S.prestige || { level:0, tokens:0 };
    const nextPrestige = { level: (prev.level||0) + 1, tokens: (prev.tokens||0) + gained };

    S = structuredClone(DEFAULT);
    S.prestige = nextPrestige;

    save();
    const el = $("log"); if (el) el.innerHTML = "";
    log(`Wasteland Reset complete. Prestige Level ${S.prestige.level} (+${gained} tokens).`, "warn");
    renderAll();
    showScreen("clicker");
  }

  function ensureQuest(){
    if (!S.quests || !S.quests.target){
      S.quests = { last: 0, done: false, target: null, progress: 0, rewardCaps: 40, rewardTech: 2 };
    }
    const dayMs = 24*60*60*1000;
    const fresh = (Date.now() - (S.quests.last||0)) < dayMs;
    if (!fresh || S.quests.last === 0) rollNewQuest();
  }

  function rollNewQuest(){
    const lvl = S.prestige?.level || 0;
    const pool = [
      { type:"scavenge", label:"Scavenge taps", goal: 35 + Math.floor(lvl*8) },
      { type:"build", label:"Build structures", goal: 3 + Math.floor(lvl*1) },
      { type:"raid", label:"Win raids", goal: 2 + Math.floor(lvl*0.5) },
      { type:"recruit", label:"Recruit settlers", goal: 5 + Math.floor(lvl*1) },
    ];
    const pick = pool[Math.floor(Math.random()*pool.length)];
    S.quests = {
      last: Date.now(),
      done: false,
      target: pick,
      progress: 0,
      rewardCaps: 45 + Math.floor(lvl*10),
      rewardTech: 2 + Math.floor(lvl*0.4),
    };
    log(`Daily quest: ${pick.label} (${S.quests.progress}/${pick.goal}).`, "warn");
  }

  function incQuest(type, amount=1){
    if (!S.quests || !S.quests.target || S.quests.done) return;
    if (S.quests.target.type !== type) return;
    S.quests.progress += amount;
    if (S.quests.progress >= S.quests.target.goal){
      S.quests.done = true;
      S.caps += S.quests.rewardCaps;
      S.tech += S.quests.rewardTech;
      log(`Daily quest complete! +${S.quests.rewardCaps} Caps, +${S.quests.rewardTech} Tech.`, "warn");
    }
  }

  function questStatusText(){
    ensureQuest();
    const q = S.quests;
    if (!q.target) return "No quest";
    return q.done ? "Complete — claimed" : `${q.target.label}: ${q.progress}/${q.target.goal}`;
  }// ---------- Combat / Raid system (automated, Fallout-themed) ----------
const COMBAT_UNITS = {
  riflemen: { name:"Wasteland Riflemen", tag:"Balanced", atk:3, def:3, hp:8, cost:{ scrap:25, food:5, caps:10 } },
  snipers:  { name:"Snipers", tag:"Ranged", atk:5, def:2, hp:6, cost:{ scrap:30, food:4, caps:18 } },
  power:    { name:"Power Armor Troopers", tag:"Heavy", atk:9, def:8, hp:18, cost:{ scrap:60, tech:2, caps:40 } },
  mutants:  { name:"Super Mutants", tag:"Brute", atk:10, def:5, hp:22, cost:{ food:18, caps:25 } },
  robots:   { name:"Sentry Bots", tag:"Robot", atk:14, def:10, hp:26, cost:{ scrap:90, tech:4, caps:65 } },
  mercs:    { name:"Mercenaries", tag:"Skirmish", atk:4, def:4, hp:10, cost:{ caps:30, food:6 } },
};

// Base combat stats for population assigned to militia. These fighters are conscripted settlers
// who provide a small but reliable boost in battle. Militia do not require recruitment
// costs, but must be assigned from your idle population. Modify these values to tune
// overall combat balance.
const MILITIA_STATS = { atk: 1, def: 1, hp: 6 };

// Combat stats for faction special units. When aligned with a faction and purchasing
// its unique unit from the shop, these troops will join your forces automatically
// in raids. The keys map to the faction IDs defined in FACTIONS. Tweak these numbers
// to reflect each faction’s play style: heavy Brotherhood knights, nimble NCR rangers,
// support medics, brutal raiders and powerful enclave troopers.
const FACTION_UNIT_STATS = {
  bos:      { atk: 6, def: 5, hp: 12 },  // Brotherhood of Steel – Paladin Knights
  ncr:      { atk: 7, def: 4, hp: 10 },  // NCR – Rangers
  followers:{ atk: 3, def: 4, hp: 10 },  // Followers of the Apocalypse – Field Medics
  raiders:  { atk: 8, def: 3, hp: 11 },  // Raiders – Berserkers
  enclave:  { atk:10, def: 6, hp: 14 },  // Enclave – Power Troopers
};

// Matchmaking & progression tiers (Fallout-themed)
const RAID_TIERS = [
  { name:"Abandoned Camp", pop:0, basePower:8,  steal:{ scrap:[8,18], food:[3,8], water:[2,6], caps:[2,8] }, marks:1 },
  { name:"Scavenger Outpost", pop:20, basePower:20, steal:{ scrap:[15,35], food:[6,14], water:[5,12], caps:[8,18] }, marks:1 },
  { name:"Survivor Settlement", pop:60, basePower:45, steal:{ scrap:[30,70], food:[10,22], water:[10,22], caps:[15,35], tech:[0,1] }, marks:2 },
  { name:"Fortified Town", pop:200, basePower:90, steal:{ scrap:[55,120], food:[18,40], water:[18,40], caps:[30,70], tech:[0,2] }, marks:3 },
  { name:"Trade Hub", pop:2000, basePower:180, steal:{ scrap:[110,240], food:[35,80], water:[35,80], caps:[65,140], tech:[1,3] }, marks:4 },
  { name:"Wasteland City", pop:5000, basePower:260, steal:{ scrap:[160,340], food:[55,120], water:[55,120], caps:[90,190], tech:[1,4] }, marks:5 },
  { name:"Faction Stronghold", pop:10000, basePower:360, steal:{ scrap:[220,460], food:[75,160], water:[75,160], caps:[120,240], tech:[2,5] }, marks:6 },
  { name:"Regional Power Zone", pop:50000, basePower:520, steal:{ scrap:[320,700], food:[110,240], water:[110,240], caps:[170,360], tech:[3,7] }, marks:7 },
  { name:"State-Level Territory", pop:100000, basePower:680, steal:{ scrap:[420,900], food:[150,320], water:[150,320], caps:[230,480], tech:[4,8] }, marks:8 },
  { name:"Nationwide Faction", pop:150000, basePower:820, steal:{ scrap:[520,1100], food:[190,380], water:[190,380], caps:[280,560], tech:[5,10] }, marks:9 },
  { name:"Wasteland Dominion", pop:200000, basePower:980, steal:{ scrap:[640,1350], food:[220,450], water:[220,450], caps:[340,680], tech:[6,12] }, marks:10 },
  { name:"Post-War Empire", pop:500000, basePower:1400, steal:{ scrap:[900,2000], food:[320,700], water:[320,700], caps:[480,980], tech:[8,16] }, marks:12 },
];

const BATTLE_UNLOCK_COST = { scrap:120, tech:4, caps:80 };

function combatUnlocked(){ return !!S.combatUnlocked; }
function hasAnyCombatUnit(){
  // Returns true if any recruitable combat units, militia or faction troops are available.
  ensureExpansion();
  const combatCount = Object.values(S.combatUnits || {}).reduce((a,b) => a + (b || 0), 0);
  const militiaCount = S.militia || 0;
  let factionCount = 0;
  if (S.factions && S.factions.aligned){
    const fid = S.factions.aligned;
    factionCount = (S.factions.units && S.factions.units[fid]) || 0;
  }
  return (combatCount + militiaCount + factionCount) > 0;
}

function unitCostStr(cost){
  const parts = [];
  for (const k of ["scrap","food","water","tech","caps"]){
    if (cost[k]) parts.push(`${k.toUpperCase()} ${fmt(cost[k])}`);
  }
  return parts.join(" · ");
}
function canAfford(cost){
  for (const [k,v] of Object.entries(cost)){
    if ((S[k]||0) < v) return false;
  }
  return true;
}
function payCost(cost){
  for (const [k,v] of Object.entries(cost)){
    S[k] -= v;
  }
}

function totalArmyStats(){
  // Sum up attack, defense and hit points from all military forces: recruited combat units,
  // conscripted militia and faction special units. This function also applies a modest
  // synergy multiplier when both front‑line (melee/heavy) and ranged units are present,
  // and a robot bonus if sentry bots are deployed. Faction and militia units do not
  // contribute to these bonuses but still increase raw stats.
  const u = S.combatUnits || {};
  let atk=0, def=0, hp=0;
  // Combat units
  for (const [id,qty] of Object.entries(u)){
    const q = qty||0;
    const d = COMBAT_UNITS[id];
    if (!d || q<=0) continue;
    atk += d.atk*q;
    def += d.def*q;
    hp  += d.hp*q;
  }
  // Militia
  const mil = S.militia || 0;
  if (mil > 0){
    atk += MILITIA_STATS.atk * mil;
    def += MILITIA_STATS.def * mil;
    hp  += MILITIA_STATS.hp  * mil;
  }
  // Faction units (only aligned faction counts)
  if (S.factions && S.factions.aligned){
    const fid = S.factions.aligned;
    const count = (S.factions.units && S.factions.units[fid]) || 0;
    if (count > 0){
      const stats = FACTION_UNIT_STATS[fid];
      if (stats){
        atk += stats.atk * count;
        def += stats.def * count;
        hp  += stats.hp  * count;
      }
    }
  }
  // Determine composition for synergy bonuses. Only recruited combat units are
  // considered for front/ranged/robot synergy to preserve distinct roles.
  const hasFront = (u.riflemen||0) + (u.power||0) + (u.mutants||0) + (u.mercs||0) > 0;
  const hasRanged = (u.snipers||0) > 0;
  let mult = 1.0;
  if (hasFront && hasRanged) mult += 0.06;
  if ((u.robots||0) > 0) mult += 0.04;
  return { atk: Math.round(atk*mult), def: Math.round(def*mult), hp: Math.round(hp*mult), mult };
}
function totalArmyPower(){
  const s = totalArmyStats();
  return Math.round(s.atk*0.45 + s.def*0.35 + s.hp*0.20);
}

function playerTierIndex(){
  const p = Math.max(0, S.pop || 0);
  let idx = 0;
  for (let i=0; i<RAID_TIERS.length; i++){
    if (p >= RAID_TIERS[i].pop) idx = i;
  }
  return idx;
}

function rollRaidTarget(){
  const pIdx = playerTierIndex();
  const minIdx = Math.max(0, pIdx-1);
  const maxIdx = Math.min(RAID_TIERS.length-1, pIdx+1);
  const idx = randInt(minIdx, maxIdx+1);
  const tier = RAID_TIERS[idx];
  const variance = 0.90 + Math.random()*0.20;
  const defPower = Math.round(tier.basePower * variance);

  const nameBits = ["Red Rock","Dusty","Sunken","Rust","Molerat","Ghoul","Iron","Coyote","Barter","Badlands","Shady","Juniper","Blackwater"];
  const settlementName = `${choice(nameBits)} ${tier.name}`;

  S.raidTarget = { idx, name:settlementName, tierName:tier.name, defPower, pop:tier.pop, marks:tier.marks, steal:tier.steal };
}

function unlockCombat(){
  if (S.combatUnlocked) return;
  if (!canAfford(BATTLE_UNLOCK_COST)){
    log(`Need ${unitCostStr(BATTLE_UNLOCK_COST)} to establish a Command Terminal.`, "warn");
    return;
  }
  payCost(BATTLE_UNLOCK_COST);
  S.combatUnlocked = true;
  log("Command Terminal online. Raids unlocked.", "warn");
  renderAll(); queueSave();
}

function recruitUnit(id, delta){
  ensureExpansion();
  const d = COMBAT_UNITS[id];
  if (!d) return;
  if (delta > 0){
    if (!canAfford(d.cost)){
      log(`Not enough resources to recruit ${d.name}.`, "warn");
      return;
    }
    payCost(d.cost);
    S.combatUnits[id] = (S.combatUnits[id]||0) + 1;
  } else {
    S.combatUnits[id] = Math.max(0, (S.combatUnits[id]||0) - 1);
  }
  renderAll(); queueSave();
}

function sampleSteal(range){
  const lo = range[0], hi = range[1];
  if (hi <= lo) return lo;
  return randInt(lo, hi+1);
}

function formatLosses(losses){
  // Human‑friendly summary of unit losses. Handles combat units, militia and faction
  // troops. Unknown keys fall back to their raw name. This ensures raid history
  // displays coherent labels when casualties include militia or faction units.
  const parts = [];
  for (const [k,v] of Object.entries(losses)){
    if (!v) continue;
    let name;
    if (k === "militia") name = "Militia";
    else if (k === "faction") name = "Faction Units";
    else name = COMBAT_UNITS[k]?.name || k;
    parts.push(`${name} -${v}`);
  }
  return parts.length ? parts.join(", ") : "None";
}

function addRaidHistory(entry){
  S.raidHistory = S.raidHistory || [];
  S.raidHistory.unshift(entry);
  if (S.raidHistory.length > 12) S.raidHistory.length = 12;
}

function simulateRaid(){
  if (!combatUnlocked()){
    log("Combat is locked. Build a Command Terminal first.", "warn");
    return;
  }
  if (!hasAnyCombatUnit()){
    log("Recruit at least one combat unit to launch a raid.", "warn");
    return;
  }
  if (!S.raidTarget) rollRaidTarget();

  const nowT = now();
  if ((nowT - (S.lastRaidAt||0)) < 1500) return; // anti spam
  S.lastRaidAt = nowT;

  const atkStats = totalArmyStats();
  const atkPower = totalArmyPower();
  const tgt = S.raidTarget;
  const defPower = tgt.defPower;
  const win = atkPower > defPower;

  // small optional variance (tiny) to avoid ties feeling weird
  const tiny = 0.98 + Math.random()*0.04;
  const effectiveAtk = Math.round(atkPower * tiny);

  const finalWin = effectiveAtk > defPower;

  let marksGained = tgt.marks;
  if (tgt.idx <= 1) marksGained = 1; // anti-farm rule

  let loot = { scrap:0, food:0, water:0, tech:0, caps:0 };
  let losses = {};

  if (finalWin){
    // Determine loss rate based on how close the fight was. Closer wins cause more
    // casualties. Include militia and faction units in the casualty roll, using
    // the same proportional formula as recruited combat units. Militia deaths
    // reduce population; faction losses reduce the special unit pool.
    const closeness = clamp(defPower / Math.max(1, effectiveAtk), 0.0, 0.99);
    const lossRate = 0.03 + closeness * 0.10;
    // Combat units casualties
    for (const k of Object.keys(COMBAT_UNITS)){
      const q = S.combatUnits[k] || 0;
      if (!q) continue;
      const die = Math.min(q, Math.max(0, Math.round(q * lossRate * (0.7 + Math.random() * 0.6))));
      if (die > 0){
        S.combatUnits[k] -= die;
        losses[k] = (losses[k] || 0) + die;
      }
    }
    // Militia casualties
    const mCount = S.militia || 0;
    if (mCount > 0){
      const mDie = Math.min(mCount, Math.max(0, Math.round(mCount * lossRate * (0.7 + Math.random() * 0.6))));
      if (mDie > 0){
        S.militia = Math.max(0, S.militia - mDie);
        S.pop = Math.max(0, S.pop - mDie);
        losses.militia = (losses.militia || 0) + mDie;
      }
    }
    // Faction unit casualties
    if (S.factions && S.factions.aligned){
      const fid = S.factions.aligned;
      const fCount = (S.factions.units && S.factions.units[fid]) || 0;
      if (fCount > 0){
        const fDie = Math.min(fCount, Math.max(0, Math.round(fCount * lossRate * (0.7 + Math.random() * 0.6))));
        if (fDie > 0){
          S.factions.units[fid] = Math.max(0, fCount - fDie);
          losses.faction = (losses.faction || 0) + fDie;
        }
      }
    }
    // reward scales with tier + win margin
    for (const [rk, range] of Object.entries(tgt.steal)){
      const base = sampleSteal(range);
      const bonus = 1 + Math.min(0.35, Math.max(0, (effectiveAtk - defPower) / Math.max(1, defPower)) * 0.25);
      const amt = Math.round(base * bonus);
      loot[rk] = (loot[rk] || 0) + amt;
      S[rk] = (S[rk] || 0) + amt;
    }

    S.trophies = (S.trophies || 0) + 1;
    S.raidMarks = (S.raidMarks || 0) + marksGained;
    S.raidsWon = (S.raidsWon || 0) + 1;

    addRaidHistory({
      t: nowT,
      title: `Raid Victory: ${tgt.name}`,
      result: "WIN",
      atkPower: effectiveAtk,
      defPower,
      loot,
      losses,
      marks: marksGained,
      trophies: 1,
    });

    log(`Raid SUCCESS — seized loot from ${tgt.name}. +${marksGained} Raid Marks.`, "warn");
    rollRaidTarget(); // new opponent after win
  } else {
    // Losses are heavier on a failed raid. Guarantee at least one casualty for each
    // unit type present. Apply losses to militia and faction units as well.
    const ratio = clamp(defPower / Math.max(1, effectiveAtk), 0.5, 3.0);
    const lossRate = 0.20 + ratio * 0.10;
    // Combat unit casualties
    for (const k of Object.keys(COMBAT_UNITS)){
      const q = S.combatUnits[k] || 0;
      if (!q) continue;
      const die = Math.min(q, Math.max(1, Math.round(q * lossRate * (0.8 + Math.random() * 0.5))));
      S.combatUnits[k] -= die;
      losses[k] = (losses[k] || 0) + die;
    }
    // Militia casualties
    const mCountFail = S.militia || 0;
    if (mCountFail > 0){
      const mDie = Math.min(mCountFail, Math.max(1, Math.round(mCountFail * lossRate * (0.8 + Math.random() * 0.5))));
      S.militia = Math.max(0, S.militia - mDie);
      S.pop = Math.max(0, S.pop - mDie);
      losses.militia = (losses.militia || 0) + mDie;
    }
    // Faction unit casualties
    if (S.factions && S.factions.aligned){
      const fid = S.factions.aligned;
      const fCountFail = (S.factions.units && S.factions.units[fid]) || 0;
      if (fCountFail > 0){
        const fDie = Math.min(fCountFail, Math.max(1, Math.round(fCountFail * lossRate * (0.8 + Math.random() * 0.5))));
        S.factions.units[fid] = Math.max(0, fCountFail - fDie);
        losses.faction = (losses.faction || 0) + fDie;
      }
    }

    addRaidHistory({
      t: nowT,
      title: `Raid Failed: ${tgt.name}`,
      result: "LOSS",
      atkPower: effectiveAtk,
      defPower,
      loot,
      losses,
      marks: 0,
      trophies: 0,
    });

    log(`Raid FAILED — ${tgt.name} repelled your forces.`, "warn");
    // target remains (lets player retry or reroll)
  }

  renderAll(); queueSave();
}


// Main battle renderer for the automated raids system.  This function
// constructs the simple army overview, target preview, raid button and
// history.  It replaces the old Campaign Paths interface.
// Legacy battle renderer for the Campaign Paths system (unused).  It
// remains for reference only and is no longer called by renderAll().
function renderBattle(){
  ensureExpansion();
  const panel = $("battlePanel");
  if (!panel) return;

  const alignedFaction = (S.factions && S.factions.aligned) ? S.factions.aligned : null;
  const factionName = alignedFaction ? (FACTIONS[alignedFaction]?.name || "Faction") : "Independent";
  const hdr = $("battleHeaderTag");
  if (hdr){
    hdr.textContent = combatUnlocked() ? factionName : "Locked";
  }

  const armyStats = totalArmyStats();
  const armyPower = totalArmyPower();

  // Simple risk label based on your power vs estimated enemy power
  const riskChip = (enemyPower) => {
    const ratio = armyPower / Math.max(1, enemyPower);
    if (ratio >= 1.20) return `<span class="chip good">🟢 Favorable</span>`;
    if (ratio >= 0.90) return `<span class="chip warn">🟠 Risky</span>`;
    return `<span class="chip danger">🔴 Dangerous</span>`;
  };

  const headerRow = `
    <div class="row">
      <div class="label">Combat Status</div>
      <div class="value" style="display:flex; gap:8px; align-items:center; justify-content:flex-end; flex-wrap:wrap;">
        <span class="chip">🏆 Trophies <b>${fmt(S.trophies||0)}</b></span>
        <span class="chip">💀 Raid Marks <b>${fmt(S.raidMarks||0)}</b></span>
        <span class="chip">⚔️ Strength <b>${fmt(armyPower)}</b></span>
      </div>
    </div>
  `;

  // Locked view (unlock + recruit)
  if (!combatUnlocked()){
    // Build locked view: show unlock requirements, cost and a simple force assignment screen
    const militiaQtyLocked = S.militia || 0;
    const idleLocked = S.idle || 0;
    const militiaRowLocked = `
        <div class="row" style="align-items:flex-start">
          <div style="min-width:0">
            <div class="value" style="font-family:var(--mono); color:var(--accent)">Militia</div>
            <div class="label">Assign settlers · ATK ${MILITIA_STATS.atk} · DEF ${MILITIA_STATS.def} · HP ${MILITIA_STATS.hp}</div>
          </div>
          <div class="value" style="display:flex; gap:8px; align-items:center; justify-content:flex-end; flex-wrap:wrap;">
            <span class="tag">x${militiaQtyLocked}</span>
            <button class="stepBtn" data-bact="militia-dec" ${militiaQtyLocked>0?"":"disabled"} aria-label="Decrease Militia">−</button>
            <button class="stepBtn" data-bact="militia-inc" ${idleLocked>0?"":"disabled"} aria-label="Increase Militia">+</button>
          </div>
        </div>
    `;
    const unitRowsLocked = Object.entries(COMBAT_UNITS).map(([id,d]) => {
      const qty = (S.combatUnits?.[id]||0);
      return `
        <div class="row" style="align-items:flex-start">
          <div style="min-width:0">
            <div class="value" style="font-family:var(--mono); color:var(--accent)">${d.name} <span class="tag">${d.tag}</span></div>
            <div class="label">${unitCostStr(d.cost)}</div>
          </div>
          <div class="value" style="display:flex; gap:8px; align-items:center; justify-content:flex-end; flex-wrap:wrap;">
            <span class="tag">x${qty}</span>
            <button class="stepBtn" data-bact="dec" data-unit="${id}" ${qty>0?"":"disabled"} aria-label="Decrease ${d.name}">−</button>
            <button class="stepBtn" data-bact="inc" data-unit="${id}" ${canAfford(d.cost)?"":"disabled"} aria-label="Increase ${d.name}">+</button>
          </div>
        </div>
      `;
    }).join("");
    panel.innerHTML = `
      ${headerRow}

      <div class="divider"></div>

      <div class="row">
        <div style="min-width:0">
          <div class="label">Locked</div>
          <div class="value">Establish a <b>Command Terminal</b> and field at least <b>1 fighting unit</b>.</div>
        </div>
      </div>

      <div class="row">
        <div>
          <div class="label">Unlock Cost</div>
          <div class="value"><span class="tag">${unitCostStr(BATTLE_UNLOCK_COST)}</span></div>
        </div>
        <div style="display:flex;justify-content:flex-end;align-items:center">
          <button class="btn" data-bact="unlock" ${canAfford(BATTLE_UNLOCK_COST)? "" : "disabled"}>
            <div class="left">
              <div class="name">Establish Command Terminal</div>
              <div class="desc">Unlock raids & battle targets</div>
            </div>
            <small>${canAfford(BATTLE_UNLOCK_COST) ? "UNLOCK" : "LOCKED"}</small>
          </button>
        </div>
      </div>

      <div class="divider"></div>

      <div class="row">
        <div class="label">Your Forces</div>
        <div class="value">Recruit or assign fighters. Raids unlock after the terminal.</div>
      </div>

      <div class="rows" style="gap:10px; margin-top:8px">
        ${militiaRowLocked}
        ${unitRowsLocked}
      </div>
    `;
    return;
  }

  // Unlocked view
  if (S.uiBattleShowHistory === undefined) S.uiBattleShowHistory = false;

  // Stage 1: Army overview (always visible). Show militia, recruited units and any
  // faction special troops in one list. Militia can be adjusted directly from
  // this screen via plus/minus buttons; faction units are read‑only (purchased
  // through the faction shop).
  const militiaQty = S.militia || 0;
  const idlePop = S.idle || 0;
  const militiaRow = `
      <div class="row" style="align-items:flex-start">
        <div style="min-width:0">
          <div class="value" style="font-family:var(--mono); color:var(--accent)">Militia</div>
          <div class="label">Baseline fighters · ATK ${MILITIA_STATS.atk} · DEF ${MILITIA_STATS.def} · HP ${MILITIA_STATS.hp}</div>
        </div>
        <div class="value" style="display:flex; gap:8px; align-items:center; justify-content:flex-end; flex-wrap:wrap;">
          <span class="tag">x${militiaQty}</span>
          <button class="stepBtn" data-bact="militia-dec" ${militiaQty>0?"":"disabled"} aria-label="Decrease Militia">−</button>
          <button class="stepBtn" data-bact="militia-inc" ${idlePop>0?"":"disabled"} aria-label="Increase Militia">+</button>
        </div>
      </div>
  `;

  const combatRows = Object.entries(COMBAT_UNITS).map(([id,d]) => {
    const qty = (S.combatUnits?.[id]||0);
    return `
      <div class="row" style="align-items:flex-start">
        <div style="min-width:0">
          <div class="value" style="font-family:var(--mono); color:var(--accent)">${d.name}</div>
          <div class="label">${d.tag} · ATK ${d.atk} · DEF ${d.def} · HP ${d.hp}</div>
        </div>
        <div class="value" style="display:flex; gap:8px; align-items:center; justify-content:flex-end; flex-wrap:wrap;">
          <span class="tag">x${qty}</span>
          <button class="stepBtn" data-bact="dec" data-unit="${id}" ${qty>0?"":"disabled"} aria-label="Decrease ${d.name}">−</button>
          <button class="stepBtn" data-bact="inc" data-unit="${id}" ${canAfford(d.cost)?"":"disabled"} aria-label="Increase ${d.name}">+</button>
        </div>
      </div>
    `;
  }).join("");

  // Faction unit row (only if aligned and owns units)
  let factionRow = "";
  if (S.factions && S.factions.aligned){
    const fid = S.factions.aligned;
    const count = (S.factions.units && S.factions.units[fid]) || 0;
    if (count > 0){
      const spec = FACTIONS[fid]?.specialUnit;
      const stats = FACTION_UNIT_STATS[fid];
      factionRow = `
        <div class="row" style="align-items:flex-start">
          <div style="min-width:0">
            <div class="value" style="font-family:var(--mono); color:var(--accent)">${spec?.name || 'Faction Unit'}</div>
            <div class="label">${spec?.desc || 'Special unit'} · ATK ${stats?.atk || 0} · DEF ${stats?.def || 0} · HP ${stats?.hp || 0}</div>
          </div>
          <div class="value" style="display:flex; gap:8px; align-items:center; justify-content:flex-end; flex-wrap:wrap;">
            <span class="tag">x${count}</span>
          </div>
        </div>
      `;
    }
  }

  const armyList = `
    <div class="row">
      <div class="label">Your Forces</div>
      <div class="value"><span class="tag">Composition matters</span></div>
    </div>
    <div class="rows" style="gap:10px; margin-top:8px">
      ${militiaRow}
      ${combatRows}
      ${factionRow}
    </div>
  `;

  // Stage 2/3: Find target -> preview -> raid
  const hasTarget = !!S.raidTarget;
  const tgt = S.raidTarget;

  let targetBlock = `
    <div class="row">
      <div class="label">Raid Target</div>
      <div class="value">Matchmaking by population tier. Automated resolution.</div>
    </div>
  `;

  if (!hasTarget){
    targetBlock += `
      <button class="btn" data-bact="find" ${hasAnyCombatUnit()? "" : "disabled"}>
        <div class="left">
          <div class="name">Find Raid Target</div>
          <div class="desc">${hasAnyCombatUnit() ? "Roll a nearby settlement to attack" : "Recruit at least 1 unit to raid"}</div>
        </div>
        <small>${hasAnyCombatUnit() ? "SCAN" : "NO UNITS"}</small>
      </button>
      <div class="miniHint" style="margin-top:10px">
        Tip: your <b>Strength</b> is based on unit totals + small composition bonuses.
      </div>
    `;
  } else {
    const marksShown = (tgt.idx<=1)?1:tgt.marks;
    targetBlock += `
      <div class="card mini" style="margin-top:10px">
        <div class="row" style="margin:0">
          <div style="min-width:0">
            <div class="value" style="font-family:var(--mono); color:var(--accent)">${tgt.name}</div>
            <div class="label">${tgt.tierName} · Pop ≥ ${fmt(tgt.pop)}</div>
          </div>
          <div class="value" style="display:flex; gap:8px; align-items:center; justify-content:flex-end; flex-wrap:wrap;">
            <span class="chip">Enemy ~${fmt(tgt.defPower)}</span>
            ${riskChip(tgt.defPower)}
            <span class="chip">💀 ${fmt(marksShown)} Marks</span>
          </div>
        </div>
      </div>

      <div class="row">
        <div class="label">Preview</div>
        <div class="value">
          You: <b>${fmt(armyPower)}</b> vs Enemy: <b>~${fmt(tgt.defPower)}</b>
          <span class="tag">Variance small</span>
        </div>
      </div>

      <div style="display:flex;gap:10px;margin-top:10px; flex-wrap:wrap">
        <button class="btn" data-bact="reroll">Find New Target</button>
        <button class="btn" data-bact="raid" ${hasAnyCombatUnit()? "" : "disabled"}>
          <div class="left">
            <div class="name">RAID SETTLEMENT</div>
            <div class="desc">Resolve instantly · Loot + Raid Marks</div>
          </div>
          <small>RAID</small>
        </button>
      </div>
    `;
  }

  // Optional: history (secondary)
  const hist = (S.raidHistory||[]).slice(0,6);
  const historyBlock = `
    <div class="divider"></div>
    <button class="btn" data-bact="toggleHistory">
      <div class="left">
        <div class="name">Raid History</div>
        <div class="desc">Recent results (losses & loot)</div>
      </div>
      <small>${S.uiBattleShowHistory ? "HIDE" : "SHOW"}</small>
    </button>
    ${S.uiBattleShowHistory ? `
      <div class="rows" style="gap:10px; margin-top:10px">
        ${hist.map(r=>{
          const dt = new Date(r.t);
          const time = dt.toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"});
          const lootLine = Object.entries(r.loot||{}).filter(([k,v])=>v>0).map(([k,v])=>`${k.toUpperCase()} +${fmt(v)}`).join(" · ");
          const lossesLine = formatLosses(r.losses||{});
          return `
            <div class="row" style="align-items:flex-start">
              <div style="min-width:0">
                <div class="value"><b>${r.result==="WIN" ? "✅" : "❌"} ${escapeHtml(r.title)}</b></div>
                <div class="label">${time} · You ${fmt(r.atkPower)} vs Enemy ${fmt(r.defPower)}</div>
                <div class="label">Losses: ${escapeHtml(lossesLine)}${lootLine?` · Loot: ${escapeHtml(lootLine)}`:""}</div>
              </div>
              <div class="value">
                ${r.result==="WIN" ? `<span class="tag">+${fmt(r.marks)} Marks</span>` : `<span class="tag" style="border-color: rgba(255,107,107,.55); color: var(--danger);">Repelled</span>`}
              </div>
            </div>
          `;
        }).join("") || `<div class="row"><div class="label">No raids yet.</div><div class="value">Strike first when ready.</div></div>`}
      </div>
    ` : ``}
  `;

  panel.innerHTML = `
    ${headerRow}
    <div class="divider"></div>
    ${armyList}
    <div class="divider"></div>
    ${targetBlock}
    ${historyBlock}
  `;
}




  // ---------- UI: screen navigation ----------
  const screens = ["clicker","build","tech","battle","factions","log"];
  function showScreen(name){
for (const s of screens){
      const el = $("screen-" + s);
      if (el) el.classList.toggle("active", s === name);
    }
    document.querySelectorAll(".tab[data-screen]").forEach(btn => {
      btn.classList.toggle("active", btn.dataset.screen === name);
    });
    // render on switch so costs/buttons are fresh
    renderAll();
  }

  document.querySelectorAll(".tab[data-screen]").forEach(btn => {
    btn.addEventListener("click", () => showScreen(btn.dataset.screen));
  });

  // ---------- UI builders ----------
  function renderTopPills() {
    const el = $("topPills");
    el.innerHTML = "";
    // ensure expansions are initialised
    ensureExpansion();
    const pills = [
      ["SCRAP", S.scrap],
      ["FOOD", S.food],
      ["WATER", S.water],
      ["TECH", S.tech],
      ["CAPS", S.caps],
      ["POP", `${S.pop}/${housingCap()}`],
      ["RAD", `${Math.round(S.rad)}%`],
      ["MED", S.medData],
      ["BRK", S.breakthroughs],
      ["STR", S.strain]
    ];
    for (const [k,v] of pills) {
      const p = document.createElement("div");
      p.className = "pill";
      p.innerHTML = `${k}: <b>${typeof v === "number" ? fmt(v) : v}</b>`;
      el.appendChild(p);
    }
  }

  function renderWorkers() {
    const panel = $("workerPanel");
    if (!panel) return;
    panel.innerHTML = "";
    // ensure expansion fields are available
    ensureExpansion();

    // Always default to the Economy view.  The War tab has been removed because
    // militia and faction troops are now managed within the Battle screen.  If
    // older saves have S.workersTab set to 'war', reset it to 'economy'.
    S.workersTab = 'economy';

    // No tabs are displayed here.  We only render economy assignments.

    const makeAssign = (key, title, desc) => {
      const wrap = document.createElement("div");
      wrap.className = "row";
      wrap.innerHTML = `
        <div style="min-width:0;">
          <div style="font-family:var(--mono); color:var(--accent); font-size:0.88rem;">${title}</div>
          <div style="font-family:var(--sans); color:var(--muted); font-size:0.82rem; line-height:1.25;">${desc}</div>
        </div>
        <div style="display:flex; gap:10px; align-items:center;">
          <button class="closeBtn" data-act="minus" data-key="${key}" aria-label="Decrease ${title}">-</button>
          <span style="min-width:32px; text-align:center; font-family:var(--mono);">${S[key]}</span>
          <button class="closeBtn" data-act="plus" data-key="${key}" aria-label="Increase ${title}">+</button>
        </div>
      `;
      panel.appendChild(wrap);
    };
    // helper to render locked roles in grey
    const makeLocked = (title, desc) => {
      const wrap = document.createElement("div");
      wrap.className = "row locked";
      wrap.innerHTML = `
        <div style="min-width:0;">
          <div style="font-family:var(--mono); color:var(--muted); font-size:0.88rem;">${title}</div>
          <div style="font-family:var(--sans); color:var(--muted); font-size:0.82rem; line-height:1.25;">${desc}</div>
        </div>
        <div style="min-width:32px; text-align:center; font-family:var(--mono);">0</div>
      `;
      panel.appendChild(wrap);
    };

    // Economy tab (civilian roles)
    if (S.workersTab === 'economy'){
      makeAssign("scav", "Scavengers", "Passive Scrap (and a little Tech with Workshop).");
      makeAssign("farmers", "Farmhands", "Passive Food (better with Farms).");
      makeAssign("purifiers", "Purifier Crew", "Passive Water (better with Purifiers).");
    }

    // War assignments (militia + faction units) are intentionally omitted from this
    // worker panel.  Militia can be assigned and special faction units are shown
    // in the Battle screen instead.  This prevents duplicate interfaces and
    // keeps the workers page focused on economic roles.

    // expansion roles (Economy tab)
    if (S.workersTab !== 'economy') return;

    // expansion roles
    // Engineers: unlocked via Workshop tech
    if (S.techs && S.techs.workshop) {
      makeAssign('engineers', 'Engineers', 'Boost all production and salvage extra Tech.');
    } else {
      makeLocked('Engineers', 'Locked (Research Workshop)');
    }
    // Medics: unlocked via Medbay tech
    if (S.techs && S.techs.medbay) {
      makeAssign('medics', 'Medics', 'Generate Medical Data and slow radiation accumulation.');
    } else {
      makeLocked('Medics', 'Locked (Research Field Medbay)');
    }
    // Researchers: unlocked by building a Research Lab
    if ((S.lab || 0) > 0) {
      makeAssign('researchers', 'Researchers', 'Discover Breakthroughs to unlock powerful upgrades.');
    } else {
      makeLocked('Researchers', 'Locked (Build Research Lab)');
    }
    // Scouts: unlocked by Annex or Command Center
    if ((S.annex || 0) > 0 || (S.cmdcenter || 0) > 0) {
      makeAssign('scouts', 'Scouts', 'Improve mission success and uncover points of interest.');
    } else {
      makeLocked('Scouts', 'Locked (Build Workshop Annex or Command Center)');
    }
    // Propagandists: unlocked by Command Center
    if ((S.cmdcenter || 0) > 0) {
      makeAssign('propagandists', 'Propagandists', 'Generate faction reputation over time.');
    } else {
      makeLocked('Propagandists', 'Locked (Build Command Center)');
    }
    // Fixers: unlocked by Logistics Depot
    if ((S.depot || 0) > 0) {
      makeAssign('fixers', 'Fixers', 'Reduce strain and prevent breakdowns.');
    } else {
      makeLocked('Fixers', 'Locked (Build Logistics Depot)');
    }
  }

  function costText(cost) {
    return Object.entries(cost).map(([k,v]) => `${k.toUpperCase()} ${v}`).join("<br/>");
  }

  function renderBuildings() {
    const panel = $("buildPanel");
    if (!panel) return;
    panel.innerHTML = "";
    // ensure expansion fields are available
    ensureExpansion();

    const canAfford = (cost) => Object.entries(cost).every(([k,v]) => S[k] >= v);

    // helper to render a building purchase button with optional lock state
    const buyBtn = (name, desc, key, cost, extra="", unlocked=true, lockDesc="") => {
      const btn = document.createElement("button");
      btn.className = "btn";
      btn.dataset.buy = key;
      if (!unlocked) btn.classList.add("locked");
      if (unlocked) {
        btn.innerHTML = `
          <div class="left">
            <div class="name">${name} <span class="tag">x${S[key]}</span></div>
            <div class="desc">${desc}</div>
          </div>
          <small>${costText(cost)}${extra ? "<br/>"+extra : ""}</small>
        `;
        btn.disabled = !canAfford(cost);
      } else {
        btn.innerHTML = `
          <div class="left">
            <div class="name">${name} <span class="tag">x${S[key]}</span></div>
            <div class="desc">${lockDesc}</div>
          </div>
          <small>Locked</small>
        `;
        btn.disabled = true;
      }
      panel.appendChild(btn);
    };

    // Base buildings
    buyBtn("Tin Shack", "Adds housing for settlers.", "shack",
      { scrap: 18 + S.shack*10, caps: (S.shack < 2 ? 0 : (6 + S.shack*3)) },
      `Cap +4 (now ${housingCap()})`
    );

    buyBtn("Dust Farm", "Boosts Food production.", "farm",
      { scrap: 14 + S.farm*9, water: 6 + S.farm*3 }
    );

    buyBtn("Water Purifier", "Boosts Water production.", "purifier",
      { scrap: 22 + S.purifier*12, tech: Math.floor(S.purifier*0.7) }
    );

    buyBtn("Jury-Rigged Turret", "Big defense boost.", "turret",
      { scrap: 30 + S.turret*18, tech: 1 + Math.floor(S.turret*0.8), caps: 10 + S.turret*6 },
      `Defense +2.2`
    );

    // Expansion buildings
    // Workshop Annex: unlocked by Workshop tech
    const annexCost = { scrap: 30 + S.annex*24, tech: 6 + S.annex*2 };
    buyBtn("Workshop Annex", "Adds Engineer slots; improves Tech yield.", "annex", annexCost,
      `Unlocks Engineers`, S.techs && S.techs.workshop, "Requires Workshop tech");

    // Command Center: unlocked by Radio tech
    const cmdCost = { scrap: 40 + S.cmdcenter*28, caps: 40 + S.cmdcenter*12, tech: 8 };
    buyBtn("Command Center", "Issue global directives and hire Propagandists.", "cmdcenter", cmdCost,
      `Unlocks Directives`, S.techs && S.techs.radio, "Requires Radio Beacon");

    // Field Hospital: unlocked by Medbay tech
    const hospCost = { scrap: 48 + S.hospital*30, tech: 10 + S.hospital*3, water: 20 };
    buyBtn("Field Hospital", "Heal settlers and generate Medical Data.", "hospital", hospCost,
      `Unlocks Medics`, S.techs && S.techs.medbay, "Requires Field Medbay");

    // Black Market: unlocked by Radio tech
    const bmCost = { scrap: 70 + S.blackmarket*36, caps: 50 + S.blackmarket*20 };
    buyBtn("Black Market", "Trade resources at risky rates for windfall loot.", "blackmarket", bmCost,
      `Risk & Reward`, S.techs && S.techs.radio, "Requires Radio Beacon");

    // Research Lab: unlocked by Workshop tech
    const labCost = { scrap: 60 + S.lab*36, tech: 20 + S.lab*4, caps: 30 };
    buyBtn("Research Lab", "Unlock breakthrough discoveries.", "lab", labCost,
      `Unlocks Researchers`, S.techs && S.techs.workshop, "Requires Workshop tech");

    // Logistics Depot: unlocked by Caravan tech
    const depCost = { scrap: 55 + S.depot*32, caps: 24 + S.depot*8 };
    buyBtn("Logistics Depot", "Increase storage and reduce resource losses.", "depot", depCost,
      `Unlocks Fixers`, S.techs && S.techs.caravan, "Requires Caravan Route");
  }

  function renderTech() {
    const panel = $("techPanel");
    if (!panel) return;
    panel.innerHTML = "";

    const techs = [
      { key: "workshop", name: "Workshop Bench", desc: "Scavengers trickle Tech; +housing bonus.", cost: { tech: 6, scrap: 40, caps: 20 } },
      { key: "radio", name: "Radio Beacon", desc: "Recruiting cheaper; raids yield more.", cost: { tech: 10, scrap: 60, caps: 35 } },
      { key: "medbay", name: "Field Medbay", desc: "Radiation rises slower; decon stronger.", cost: { tech: 14, scrap: 80, water: 35 } },
      { key: "caravan", name: "Caravan Route", desc: "Passive Caps based on population.", cost: { tech: 18, scrap: 90, food: 60 } },
    ];

    const canAfford = (cost) => Object.entries(cost).every(([k,v]) => S[k] >= v);

    for (const t of techs) {
      const owned = !!S.techs[t.key];
      const btn = document.createElement("button");
      btn.className = "btn";
      btn.dataset.tech = t.key;
      btn.innerHTML = `
        <div class="left">
          <div class="name">${t.name} ${owned ? '<span class="tag">OWNED</span>' : ""}</div>
          <div class="desc">${t.desc}</div>
        </div>
        <small>${owned ? "—" : costText(t.cost)}</small>
      `;
      btn.disabled = owned || !canAfford(t.cost);
      panel.appendChild(btn);
    }
  }

    function renderFactions(){
    // Ensure required structures
    ensureFactions();
    ensureExpansion();
    const sum = $("factionSummary");
    const panel = $("factionPanel");
    if (!sum || !panel) return;
    sum.innerHTML = "";
    panel.innerHTML = "";

    const sponsor = S.factions.active;
    const b = activeFactionBonus();
    const cdLeft = Math.max(0, (S.factions.cooldownUntil||0) - now());
    const cdTxt = cdLeft > 0 ? ` · Swap in ${fmtTime(cdLeft)}` : "";

    // Summary rows
    const rowSponsor = document.createElement("div");
    rowSponsor.className = "row";
    rowSponsor.innerHTML =
      '<div class="label">Sponsor</div>' +
      '<div class="value">' + (sponsor ? (FACTIONS[sponsor]?.name || sponsor) : 'None') + ' ' +
      '<span class="tag">' + (sponsor ? rankName(S.factions.rank[sponsor]||0) : 'Neutral') + '</span>' +
      '<span class="tag">' + (cdLeft>0 ? 'Cooldown' : 'Ready') + '</span>' + '</div>';
    sum.appendChild(rowSponsor);

    // Build a string for current bonus text separately to avoid nested template literals
    let bonusText = '';
    if (sponsor) {
      bonusText = 'Defense +' + fmt(b.defFlat||0) + ' · Prod x' + fmt(b.prod||1) + ' · Caps x' + fmt(b.caps||1) + ' · RAD x' + fmt(1/(b.radRes||1)) + ' · Loot x' + fmt(b.loot||1);
    }
    const rowBonus = document.createElement('div');
    rowBonus.className = 'row';
    rowBonus.innerHTML =
      '<div class="label">Bonuses</div>' +
      '<div class="value">' + (bonusText || '—') + ' <span class="tag">Streak ' + (S.factions.streak||0) + '/5</span></div>';
    sum.appendChild(rowBonus);

    // If permanently aligned with a faction, show its currency in the summary
    if (S.factions.aligned) {
      const currId = S.factions.aligned;
      const currName = FACTIONS[currId]?.currencyName || 'Currency';
      const amt = S.factions.currency ? (S.factions.currency[currId] || 0) : 0;
      const rowCurr = document.createElement('div');
      rowCurr.className = 'row';
      rowCurr.innerHTML = '<div class="label">' + currName + '</div><div class="value">' + amt + '</div>';
      sum.appendChild(rowCurr);
    }

    // Contracts removed — faction loop now feeds the core game via Donations + Battle Paths + Shop.

    // Faction cards list
    // If permanently aligned, only show the chosen faction
    const ids = S.factions.aligned ? [S.factions.aligned] : Object.keys(FACTIONS);
    for (const id of ids){
      const f = FACTIONS[id];
      const rep = clamp(S.factions.rep[id] || 0, 0, 100);
      const rank = clamp(S.factions.rank[id] || rankForRep(rep), 0, 3);
      const isSponsor = (sponsor === id);
      // streak
      const streakActive = (S.factions.streakId === id) ? (S.factions.streak||0) : 0;
      const streakMult = 1 + Math.max(0, streakActive-1) * 0.05;
      // next bonus text
      let nextText = '';
      {
        const currBon = f.bonusesByRank[rank] || { defFlat:0, prod:1, caps:1, radRes:1, loot:1 };
        const nextBon = f.bonusesByRank[rank+1];
        if (nextBon){
          const diffs = [];
          const deltaDef = nextBon.defFlat - currBon.defFlat;
          if (Math.abs(deltaDef) > 0.0001) diffs.push('DEF ' + (deltaDef>=0?'+':'') + fmt(deltaDef));
          const deltaProd = nextBon.prod - currBon.prod;
          if (Math.abs(deltaProd) > 0.0001) diffs.push('PROD ' + (deltaProd>=0?'+':'') + (((deltaProd)*100).toFixed(1)) + '%');
          const deltaCaps = nextBon.caps - currBon.caps;
          if (Math.abs(deltaCaps) > 0.0001) diffs.push('CAPS ' + (deltaCaps>=0?'+':'') + (((deltaCaps)*100).toFixed(1)) + '%');
          const deltaRad = nextBon.radRes - currBon.radRes;
          if (Math.abs(deltaRad) > 0.0001) diffs.push('RADRES ' + (deltaRad>=0?'+':'') + (((deltaRad)*100).toFixed(1)) + '%');
          const deltaLoot = nextBon.loot - currBon.loot;
          if (Math.abs(deltaLoot) > 0.0001) diffs.push('LOOT ' + (deltaLoot>=0?'+':'') + (((deltaLoot)*100).toFixed(1)) + '%');
          nextText = diffs.length ? 'Next: ' + diffs.join(' · ') : '';
        } else {
          nextText = 'Max rank achieved';
        }
      }
      // Donations: scaled costs + short cooldown so it's not infinite spam.
      const dp = donatePlan(id);
      const canDonate = canDonateFaction(id);
      const donateCostLine = dp ? Object.entries(dp.cost).map(([k,v])=>`${k.toUpperCase()} ${v}`).join(' · ') : '';
      const donateText = dp
        ? (dp.cooldownLeft>0 ? `Donate (${fmtTime(dp.cooldownLeft)})` : `Donate (${donateCostLine})`)
        : 'Donate';
      // compute swap text separately to avoid nested template strings
      const swapText = cdLeft>0 ? ('Swap locked' + cdTxt) : 'Swap ready';
      // compute sponsor note if another faction is active
      const sponsorNote = (sponsor && sponsor !== id) ? '<div class="lockHint">You can still run jobs for any faction. Sponsor only affects passive bonuses.</div>' : '';
      // card element
      const card = document.createElement('div');
      card.className = 'facCard';
      // Build inner HTML using concatenation to avoid nested template syntax
      card.innerHTML =
        '<div class="facHead">' +
          '<span class="facName">' + f.name + '</span>' +
          '<span class="tag">' + rankName(rank) + '</span>' +
          (isSponsor ? '<span class="tag">SPONSOR</span>' : '') +
        '</div>' +
        '<div class="bar mini"><div class="barFill" style="width:' + rep + '%"></div></div>' +
        '<div class="facSub">' +
          '<span class="tag">REP ' + Math.round(rep) + '/100</span>' +
          '<span class="tag">' + f.tag + '</span>' +
          '<span class="tag">Streak ' + streakActive + '/5</span>' +
          '<span class="tag">Loot x' + fmt(streakMult) + '</span>' +
          '<span class="tag">' + swapText + '</span>' +
        '</div>' +
        '<div class="facDesc">' + f.desc + '</div>' +
        '<div class="facActions">' +
          (S.factions.aligned ? '' : ('<button class="fbtn2 ' + (isSponsor ? 'danger' : 'primary') + '" data-fact-act="' + (isSponsor ? 'leave' : 'ally') + '" data-fact-id="' + id + '" ' + (((!isSponsor && rep<20) || (!isSponsor && cdLeft>0)) ? 'disabled' : '') + '>' +
            (isSponsor ? 'End Sponsorship' : (rep>=20 ? 'Become Sponsor' : 'Sponsor (REP 20+)')) +
          '</button>')) +
          '<div class="miniRow">' +
            '<button class="miniBtn secondary" data-fact-act="donate" data-fact-id="' + id + '" ' + (canDonate ? '' : 'disabled') + '>' + donateText + '</button>' +
          '</div>' +
        '</div>' +
        sponsorNote;
      // Append card
      panel.appendChild(card);

      // Faction shop button (aligned only)
      if (S.factions.aligned && S.factions.aligned === id) {
        const shopRow = document.createElement("div");
        shopRow.className = "row";
        shopRow.innerHTML = `
          <div class="label">Faction</div>
          <div class="value" style="display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end;">
            <span class="tag">${FACTIONS[id].currencyName}: ${(S.factions.currency && (S.factions.currency[id]||0)) || 0}</span>
            <button class="miniBtn primary" data-fact-act="shop" data-fact-id="${id}">Faction Shop</button>
          </div>
        `;
        panel.appendChild(shopRow);
      }

    }

  }

  function renderStatsAndLog() {
    const rows = $("statRows");
    if (!rows) return;
    const prod = productionPerSec();
    rows.innerHTML = "";

    const data = [
      ["Idle Settlers", S.idle, "Unassigned workers"],
      ["Scavengers", S.scav, "Auto-gather Scrap"],
      ["Farmhands", S.farmers, "Auto-grow Food"],
      ["Purifier Crew", S.purifiers, "Auto-produce Water"],
      ["Militia", S.militia, "Defense + raids"],
      ["Buildings", `Shacks ${S.shack} · Farms ${S.farm} · Purifiers ${S.purifier} · Turrets ${S.turret} · Annex ${S.annex} · Cmd ${S.cmdcenter} · Hosp ${S.hospital} · Market ${S.blackmarket} · Lab ${S.lab} · Depot ${S.depot}`, "Counts"],
      ["Defense Power", fmt(defensePower()), "Higher = safer raids"],
      ["Net/sec", `+${fmt(prod.scavRate)} Scrap · ${fmt(prod.foodRate - prod.foodUse)} Food · ${fmt(prod.waterRate - prod.waterUse)} Water · +${fmt(prod.techRate)} Tech · +${fmt(prod.capsRate)} Caps`, "After consumption"],
      ["Faction", (S.factions && S.factions.active) ? (FACTIONS[S.factions.active]?.name || S.factions.active) : "None", "One active ally"],
      ["Daily Quest", questStatusText(), "Resets every 24h"],
      ["Prestige", `Lv ${S.prestige?.level||0} · Tokens ${S.prestige?.tokens||0}`, "Permanent bonuses"],
    ];

    for (const [label, val, tip] of data) {
      const r = document.createElement("div");
      r.className = "row";
      r.innerHTML = `<div class="label">${label}</div><div class="value">${val} <span class="tag">${tip}</span></div>`;
      rows.appendChild(r);
    }
  }


  // ---------- Battle (new system): Campaign Paths ----------
  // Design: choose a Path (alignment style) then clear tiered missions. Battles resolve instantly
  // using unit stats (ATK/DEF/HP) rather than a "fake" timer.

  const UNIT_DEFS = {
    militia: { name: "Militia", atk: 2, def: 2, hp: 5, tag: "Infantry" },
    // Faction special units (bought in the faction shop)
    bos_unit: { name: "BoS Paladin Knight", atk: 6, def: 5, hp: 10, tag: "Elite" },
    ncr_unit: { name: "NCR Ranger", atk: 5, def: 4, hp: 9, tag: "Elite" },
    followers_unit: { name: "Field Medic", atk: 2, def: 3, hp: 8, tag: "Support" },
    raiders_unit: { name: "Raider Brute", atk: 5, def: 3, hp: 8, tag: "Infantry" },
    enclave_unit: { name: "Enclave Trooper", atk: 6, def: 6, hp: 11, tag: "Elite" },
  };

  const PATHS = {
    lawful: {
      name: "Lawful",
      flavor: "Order. Contracts. Clean victories.",
      factionHint: "NCR",
      tiers: [
        { tier: 1, name: "Clear a roadblock", enemy: { atk: 8, def: 6, hp: 18 }, req: { units: 3 }, reward: { caps: 10, rep: 1 } },
        { tier: 2, name: "Break a smuggler ring", enemy: { atk: 15, def: 12, hp: 32 }, req: { units: 6 }, reward: { caps: 20, rep: 2 } },
        { tier: 3, name: "Secure a checkpoint", enemy: { atk: 26, def: 20, hp: 50 }, req: { units: 10 }, reward: { caps: 35, rep: 3 } },
        { tier: 4, name: "Liberate a settlement", enemy: { atk: 40, def: 30, hp: 80 }, req: { units: 16 }, reward: { caps: 55, rep: 4 } },
        { tier: 5, name: "Establish NCR control", enemy: { atk: 60, def: 46, hp: 120 }, req: { units: 24 }, reward: { caps: 80, rep: 5 } },
      ]
    },
    militaristic: {
      name: "Militaristic",
      flavor: "Steel. Discipline. High-stakes offensives.",
      factionHint: "Brotherhood",
      tiers: [
        { tier: 1, name: "Purge feral ghouls", enemy: { atk: 9, def: 7, hp: 20 }, req: { units: 3 }, reward: { scrap: 10, rep: 1 } },
        { tier: 2, name: "Recover pre-war tech", enemy: { atk: 17, def: 13, hp: 35 }, req: { units: 6 }, reward: { tech: 1, rep: 2 } },
        { tier: 3, name: "Assault a bunker", enemy: { atk: 30, def: 23, hp: 58 }, req: { units: 10 }, reward: { scrap: 25, rep: 3 } },
        { tier: 4, name: "Crush a warband", enemy: { atk: 46, def: 35, hp: 92 }, req: { units: 16 }, reward: { tech: 1, rep: 4 } },
        { tier: 5, name: "Secure a relic site", enemy: { atk: 70, def: 52, hp: 140 }, req: { units: 24 }, reward: { tech: 2, rep: 5 } },
      ]
    },
    ruthless: {
      name: "Ruthless",
      flavor: "Fear. Fire. Taking what you want.",
      factionHint: "Raiders",
      tiers: [
        { tier: 1, name: "Ambush a lone traveler", enemy: { atk: 7, def: 5, hp: 16 }, req: { units: 3 }, reward: { scrap: 12, rep: 1 } },
        { tier: 2, name: "Raid a small camp", enemy: { atk: 14, def: 10, hp: 30 }, req: { units: 6 }, reward: { scrap: 20, rep: 2 } },
        { tier: 3, name: "Sack a fortified settlement", enemy: { atk: 26, def: 18, hp: 56 }, req: { units: 10 }, reward: { scrap: 35, rep: 3 } },
        { tier: 4, name: "Capture a regional hub", enemy: { atk: 42, def: 28, hp: 86 }, req: { units: 16 }, reward: { scrap: 55, rep: 4 } },
        { tier: 5, name: "Establish Raider Dominion", enemy: { atk: 64, def: 44, hp: 130 }, req: { units: 24 }, reward: { scrap: 85, rep: 5 } },
      ]
    },
    humanitarian: {
      name: "Humanitarian",
      flavor: "Aid. Evacuation. Winning without becoming a monster.",
      factionHint: "Followers",
      tiers: [
        { tier: 1, name: "Escort refugees", enemy: { atk: 8, def: 6, hp: 18 }, req: { units: 3 }, reward: { medData: 3, rep: 1 } },
        { tier: 2, name: "Recover medical supplies", enemy: { atk: 15, def: 12, hp: 32 }, req: { units: 6 }, reward: { medData: 6, rep: 2 } },
        { tier: 3, name: "Break a siege", enemy: { atk: 26, def: 20, hp: 50 }, req: { units: 10 }, reward: { medData: 10, rep: 3 } },
        { tier: 4, name: "Stabilize a plague town", enemy: { atk: 40, def: 30, hp: 80 }, req: { units: 16 }, reward: { medData: 16, rep: 4 } },
        { tier: 5, name: "Found a regional clinic", enemy: { atk: 60, def: 46, hp: 120 }, req: { units: 24 }, reward: { medData: 24, rep: 5 } },
      ]
    }
  };

  function ensureBattle(){
    if (!S.battle){
      S.battle = {
        path: null,
        tier: 1,
        deploy: { militia: 0, faction: 0 },
        prog: { lawful: 0, militaristic: 0, ruthless: 0, humanitarian: 0 },
        // Rolling after-action reports (replaces the old "Last Mission" line)
        history: []
      };
    }
    // Back-compat for saves created before history existed
    if (!Array.isArray(S.battle.history)) S.battle.history = [];
  }

  function battleFlavor(pathKey, win){
    const pools = {
      lawful: {
        win: [
          "Rangers secure the perimeter and civilians return to the roads.",
          "The outpost files a clean report. Order restored.",
          "A checkpoint falls into compliant hands. Supplies flow again."
        ],
        lose: [
          "The target slips the net. Paperwork and body bags.",
          "Your unit breaks formation under crossfire. Retreat ordered.",
          "Smugglers vanish into the dunes. The road stays dangerous."
        ]
      },
      militaristic: {
        win: [
          "Power armor advances without hesitation. Resistance collapses.",
          "A decisive strike. Technology secured.",
          "The enemy line shatters under disciplined fire."
        ],
        lose: [
          "Hostiles exploit terrain. The squad falls back to regroup.",
          "The mission stalls — ammunition low, wounded mounting.",
          "Your force is outmaneuvered. Tactical withdrawal."
        ]
      },
      ruthless: {
        win: [
          "Fear does the rest. The camp is stripped bare.",
          "A brutal lesson spreads fast. Tribute follows.",
          "No prisoners. No delays. The haul is yours."
        ],
        lose: [
          "The mark fights back harder than expected. You scatter.",
          "Ambush turns on you. Survivors limp home.",
          "The raid collapses into chaos. Loot abandoned."
        ]
      },
      humanitarian: {
        win: [
          "You stabilize the wounded and secure the area.",
          "A calm extraction. Lives saved, violence minimized.",
          "Your medics hold the line long enough for evacuation."
        ],
        lose: [
          "You pull back to prevent a massacre. Triage begins.",
          "The situation spirals. You retreat to protect the vulnerable.",
          "Supplies run thin. You disengage before it becomes a slaughter."
        ]
      }
    };
    const p = pools[pathKey] || pools.militaristic;
    const arr = win ? p.win : p.lose;
    return arr[Math.floor(Math.random()*arr.length)];
  }

  function addBattleHistory(entry){
    ensureBattle();
    if (!Array.isArray(S.battle.history)) S.battle.history = [];
    S.battle.history.push(entry);
    // cap to keep UI light
    if (S.battle.history.length > 20) S.battle.history = S.battle.history.slice(-20);
  }

  // Legacy compatibility: older saves / code paths referenced timed "ops".
  // The new battle system doesn't use timers, but we keep this as a no-op so nothing crashes.
  function checkOps(){ /* deprecated */ }

  function alignedPath(){
    const a = S.factions?.aligned || null;
    if (a === "ncr") return "lawful";
    if (a === "bos") return "militaristic";
    if (a === "raiders") return "ruthless";
    if (a === "followers") return "humanitarian";
    // enclave doesn't map cleanly to the four; default to militaristic for now
    if (a === "enclave") return "militaristic";
    return null;
  }

  function ownedFactionUnitKey(){
    const a = S.factions?.aligned || null;
    if (!a) return null;
    return `${a}_unit`;
  }

  function ownedFactionUnitCount(){
    const a = S.factions?.aligned || null;
    if (!a) return 0;
    return (S.factions?.units?.[a] || 0) | 0;
  }

  function totalUnitStats(mil, fac){
    const m = UNIT_DEFS.militia;
    const facKey = ownedFactionUnitKey();
    const f = facKey ? (UNIT_DEFS[facKey] || null) : null;
    const atk = mil * m.atk + (f ? fac * f.atk : 0);
    const def = mil * m.def + (f ? fac * f.def : 0);
    const hp  = mil * m.hp  + (f ? fac * f.hp  : 0);
    return { atk, def, hp };
  }

  function missionDef(pathKey, tier){
    const p = PATHS[pathKey];
    return (p && p.tiers) ? (p.tiers.find(t => t.tier === tier) || null) : null;
  }

  // Deterministic-ish resolution: no dice for win/loss; casualties scale with how close it was.
  function resolveMission(pathKey, tier, mil, fac){
    const d = missionDef(pathKey, tier);
    if (!d) return null;
    const you = totalUnitStats(mil, fac);
    const e = d.enemy;

    // Power score weights: ATK & DEF matter, HP provides staying power.
    const youScore = (you.atk * 1.05) + (you.def * 1.0) + (you.hp * 0.55);
    const enScore  = (e.atk   * 1.05) + (e.def   * 1.0) + (e.hp   * 0.55);
    const ratio = youScore / Math.max(1, enScore);

    const win = ratio >= 1.0;

    // Losses: if you barely win, you still lose some. If you lose, losses are harsher.
    // Keep simple: only militia die first; faction units are rarer and lose at 1/4 the rate.
    let milLost = 0;
    let facLost = 0;
    const totalUnits = Math.max(1, mil + fac);

    if (win){
      // 8%..36% losses depending on margin (wins should still cost something when close)
      const closeness = clamp(1.25 - ratio, 0, 1.0); // 0 when strong win, up to 1 when barely
      const lossFrac = 0.08 + 0.28 * closeness;
      let losses = Math.round(totalUnits * lossFrac);
      // If it was a very close win, guarantee at least 1 casualty for immersion.
      if (ratio < 1.08) losses = Math.max(1, losses);
      losses = clamp(losses, 0, totalUnits);

      // Allocate: faction losses are rare on wins
      facLost = Math.min(fac, Math.floor(losses * 0.15));
      milLost = Math.min(mil, Math.max(0, losses - facLost));
    } else {
      // 30%..85% losses depending on how badly you lose (defeats should hurt)
      const badness = clamp(1.0 - ratio, 0, 1.0);
      const lossFrac = 0.30 + 0.55 * badness;
      let losses = Math.round(totalUnits * lossFrac);
      // Always at least 1 loss on a defeat when you deployed units.
      losses = Math.max(1, clamp(losses, 1, totalUnits));

      facLost = Math.min(fac, Math.floor(losses * 0.25));
      milLost = Math.min(mil, Math.max(0, losses - facLost));
    }

    // If we calculated losses but none landed on militia (common early-game rounding),
    // push 1 loss onto militia (unless you sent only faction units).
    if ((mil + fac) > 0 && (milLost + facLost) > 0 && milLost === 0 && mil > 0){
      milLost = 1;
      // keep total losses roughly consistent
      if (facLost > 0) facLost = Math.max(0, facLost - 1);
    }

    return { win, you, enemy: e, ratio, milLost, facLost, reward: d.reward };
  }

  function applyMissionResult(pathKey, tier, mil, fac, result){
    // Remove losses from global pools.
    if (result.milLost > 0){
      S.militia = Math.max(0, S.militia - result.milLost);
      S.pop = Math.max(0, S.pop - result.milLost);
    }
    const a = S.factions?.aligned || null;
    if (a && result.facLost > 0){
      if (!S.factions.units) S.factions.units = {};
      S.factions.units[a] = Math.max(0, (S.factions.units[a]||0) - result.facLost);
    }

    // Rewards on win only
    if (result.win){
      const r = result.reward || {};
      if (r.scrap) S.scrap += r.scrap;
      if (r.food) S.food += r.food;
      if (r.water) S.water += r.water;
      if (r.tech) S.tech += r.tech;
      if (r.caps) S.caps += r.caps;
      if (r.medData) S.medData = (S.medData||0) + r.medData;

      // Tier progression
      ensureBattle();
      S.battle.prog[pathKey] = Math.max(S.battle.prog[pathKey]||0, tier);

      // Faction rep drip if aligned & thematic
      if (S.factions?.aligned){
        const map = { lawful:"ncr", militaristic:"bos", ruthless:"raiders", humanitarian:"followers" };
        const fid = map[pathKey] || null;
        if (fid) {
          if (!S.factions.rep) S.factions.rep = { bos:0,ncr:0,followers:0,raiders:0,enclave:0 };
          S.factions.rep[fid] = (S.factions.rep[fid]||0) + (r.rep||1);
        }
      }
    }
  }

  // Legacy battle renderer for the Campaign Paths system (unused).  It
  // remains here for reference and debugging the old mission-based interface.
  function renderBattleCampaign(){
    ensureBattle();
    ensureExpansion();

    const stats = $("battleStats");
    const pathSelect = $("battlePathSelect");
    const tierList = $("battleTierList");
    const deploy = $("battleDeploy");
    const launchBtn = $("btnLaunchMission");
    const descEl = $("missionDesc");
    const hintEl = $("missionHint");
    const report = $("battleReport");
    if (!stats || !pathSelect || !tierList || !deploy || !launchBtn || !descEl || !hintEl || !report) return;

    const forcedPath = alignedPath();
    if (forcedPath && S.battle.path !== forcedPath) {
      S.battle.path = forcedPath;
      S.battle.tier = 1;
      S.battle.deploy = { militia: 0, faction: 0 };
    }

    const pKey = S.battle.path;
    const p = pKey ? PATHS[pKey] : null;
    const tier = S.battle.tier || 1;

    // Stats summary
    stats.innerHTML = "";
    const facName = S.factions?.aligned ? (FACTIONS[S.factions.aligned]?.name || S.factions.aligned) : "None";
    const yourFac = ownedFactionUnitCount();
    const rows = [
      ["Faction", facName, "Alignment"],
      ["Militia", S.militia|0, "Available"],
      ["Faction Units", yourFac, "Owned"],
      ["Campaign Progress", pKey ? `${(S.battle.prog[pKey]||0)}/5` : "0/5", "Tiers cleared"],
    ];
    for (const [label, val, tip] of rows){
      const r = document.createElement("div");
      r.className = "row";
      r.innerHTML = `<div class="label">${label}</div><div class="value">${val} <span class="tag">${tip}</span></div>`;
      stats.appendChild(r);
    }

    // Path selector
    pathSelect.innerHTML = "";
    const mapFactionToPath = { ncr:"lawful", bos:"militaristic", raiders:"ruthless", followers:"humanitarian", enclave:"militaristic" };
    const aligned = S.factions?.aligned || null;
    const allowed = aligned ? new Set([mapFactionToPath[aligned] || "militaristic"]) : null;

    for (const key of ["lawful","militaristic","ruthless","humanitarian"]){
      const def = PATHS[key];
      const btn = document.createElement("button");
      btn.className = "btn";
      btn.dataset.path = key;
      const locked = allowed && !allowed.has(key);
      btn.disabled = !!locked;
      btn.innerHTML = `
        <div class="left">
          <div class="name">${def.name} <span class="tag">${def.factionHint}</span></div>
          <div class="desc">${def.flavor}</div>
        </div>
        <small>${locked ? "Locked" : (S.battle.path===key?"Selected":"Choose")}</small>
      `;
      if (S.battle.path === key) btn.style.borderColor = "rgba(60,255,122,.85)";
      pathSelect.appendChild(btn);
    }

    // Tier list
    tierList.innerHTML = "";
    if (!p){
      const r = document.createElement("div");
      r.className = "row";
      r.innerHTML = `<div class="label">Choose a Path</div><div class="value">Pick how your outpost fights. <span class="tag">Step 1</span></div>`;
      tierList.appendChild(r);
    } else {
      const cleared = S.battle.prog[pKey] || 0;
      for (const t of p.tiers){
        const locked = (t.tier > cleared + 1);
        const btn = document.createElement("button");
        btn.className = "btn";
        btn.dataset.tier = String(t.tier);
        btn.disabled = locked;
        btn.innerHTML = `
          <div class="left">
            <div class="name">Tier ${t.tier}: ${t.name}</div>
            <div class="desc">Requires ${t.req.units} deployed units · Enemy ${statChipsHTML(t.enemy.atk, t.enemy.def, t.enemy.hp)}</div>
          </div>
          <small>${locked ? "Locked" : (tier===t.tier?"Selected":"Select")}</small>
        `;
        if (tier === t.tier) btn.style.borderColor = "rgba(60,255,122,.85)";
        tierList.appendChild(btn);
      }
    }

    // Deploy UI
    deploy.innerHTML = "";
    const mDef = (pKey ? missionDef(pKey, tier) : null);
    if (!pKey || !mDef){
      const r = document.createElement("div");
      r.className = "row";
      r.innerHTML = `<div class="label">Deployment</div><div class="value">Select a path and tier to deploy units. <span class="tag">Step 2</span></div>`;
      deploy.appendChild(r);
    } else {
      const facKey = ownedFactionUnitKey();
      const facUnit = facKey ? UNIT_DEFS[facKey] : null;

      const maxMil = S.militia|0;
      const maxFac = ownedFactionUnitCount();

      // Clamp
      S.battle.deploy.militia = clamp(S.battle.deploy.militia|0, 0, maxMil);
      S.battle.deploy.faction = clamp(S.battle.deploy.faction|0, 0, maxFac);

      const mkRow = (label, key, val, max, subtitle) => {
        const r = document.createElement("div");
        r.className = "row";
        r.innerHTML = `
          <div style="min-width:0;">
            <div class="label">${label}</div>
            <div class="miniHint">${subtitle}</div>
          </div>
          <div style="display:flex; gap:10px; align-items:center;">
            <button class="closeBtn" data-deploy="${key}" data-act="minus">-</button>
            <span class="tag" style="min-width:40px; text-align:center;">${val}/${max}</span>
            <button class="closeBtn" data-deploy="${key}" data-act="plus">+</button>
          </div>
        `;
        return r;
      };

      deploy.appendChild(mkRow("Militia", "militia", S.battle.deploy.militia, maxMil, `${statChipsHTML(UNIT_DEFS.militia.atk, UNIT_DEFS.militia.def, UNIT_DEFS.militia.hp)}`));

      if (facUnit){
        deploy.appendChild(mkRow(facUnit.name, "faction", S.battle.deploy.faction, maxFac, `${statChipsHTML(facUnit.atk, facUnit.def, facUnit.hp)} <span class="tag">${facUnit.tag}</span>`));
      } else {
        const r = document.createElement("div");
        r.className = "row";
        r.innerHTML = `<div class="label">Faction Unit</div><div class="value">Buy your faction unit in the shop to deploy it here. <span class="tag">Shop</span></div>`;
        deploy.appendChild(r);
      }

      const deployed = (S.battle.deploy.militia|0) + (S.battle.deploy.faction|0);
      const you = totalUnitStats(S.battle.deploy.militia|0, S.battle.deploy.faction|0);
      const youLine = `Your Force ${statChipsHTML(you.atk, you.def, you.hp)}`;
      const enLine = `Enemy ${statChipsHTML(mDef.enemy.atk, mDef.enemy.def, mDef.enemy.hp)}`;

      const info = document.createElement("div");
      info.className = "row";
      info.innerHTML = `<div class="label">Battle Preview</div><div class="value">${youLine}<br/>${enLine} <span class="tag">Deployed ${deployed}/${mDef.req.units}</span></div>`;
      deploy.appendChild(info);

      const canLaunch = deployed >= mDef.req.units && deployed > 0;
      launchBtn.disabled = !canLaunch;
      descEl.textContent = `Tier ${tier}: ${mDef.name}`;
      hintEl.innerHTML = canLaunch
        ? `Deploy ${mDef.req.units} units or more.`
        : `Need ${Math.max(0, mDef.req.units - deployed)} more unit(s).`;
    }

    // After-action reports (flavorful battle log)
    report.innerHTML = "";
    const hist = (S.battle.history || []).slice(-6).reverse();
    if (hist.length){
      const head = document.createElement("div");
      head.className = "row";
      head.innerHTML = `<div class="label">After-Action</div><div class="value">Recent field reports. <span class="tag">${hist.length} recent</span></div>`;
      report.appendChild(head);

      for (const h of hist){
        const row = document.createElement("div");
        row.className = "row";
        const tone = h.win ? "good" : "danger";
        const when = fmtShortTimeAgo(h.ts);
        const losses = (h.milLost||0) || (h.facLost||0)
          ? `Losses: -${h.milLost||0} militia${h.facLost?` · -${h.facLost} elite`:``}`
          : "Losses: none";
        const rew = h.win && h.rewardLine ? h.rewardLine : (h.win ? "Rewards: minimal" : "Rewards: none");
        row.innerHTML = `
          <div class="label">${escapeHtml(when)}</div>
          <div class="value">
            <b>${escapeHtml(h.title)}</b> <span class="tag ${tone}">${h.win?"SUCCESS":"FAILED"}</span><br/>
            ${escapeHtml(h.flavor)}<br/>
            <span class="tag">Deployed ${h.deployed}</span>
            <span class="tag">Ratio x${fmt(h.ratio)}</span>
            <span class="tag">${losses}</span>
            <span class="tag">${escapeHtml(rew)}</span>
          </div>
        `;
        report.appendChild(row);
      }
    } else {
      const r = document.createElement("div");
      r.className = "row";
      r.innerHTML = `<div class="label">After-Action</div><div class="value">No reports yet. Launch a mission to generate your first field log. <span class="tag">Campaign</span></div>`;
      report.appendChild(r);
    }
  }


  function renderActionCosts() {
    const p = purifyCost();
    if ($("purifyCost")) $("purifyCost").innerHTML = `SCRAP ${p.scrap}<br/>+WATER ${p.waterGain}`;

    const r = recruitCost();
    const mod = S.techs.radio ? 0.82 : 1;
    if ($("recruitCost")) $("recruitCost").innerHTML = `FOOD ${Math.floor(r.food*mod)}<br/>WATER ${Math.floor(r.water*mod)}`;

    const d = deconCost();
    if ($("deconCost")) $("deconCost").innerHTML = `WATER ${d.water}<br/>RAD -${d.radDown}%`;

    const tr = tradeCost();
    if ($("tradeCost")) $("tradeCost").innerHTML = `SCRAP ${tr.scrap}<br/>+CAPS ${tr.capsGain}`;
  }

  function renderAll() {
    renderTopPills();
    renderActionCosts();
    renderWorkers();
    renderBuildings();
    renderTech();
    renderBattle();
    renderFactions();
renderStatsAndLog();
  }

  // ---------- Core actions ----------
  function scavengeTap(srcEl=null){
    const baseScrap = 3 + Math.floor(S.scav*0.15);
    const baseFood = 1 + (Math.random() < 0.45 ? 1 : 0);
    const water = (Math.random() < 0.18) ? 1 : 0;

        const mm = momentumMult();
    const gotScrap = Math.floor(baseScrap * mm);
    const gotFood  = Math.floor(baseFood * mm);
    const gotWater = Math.floor(water * mm);

    S.scrap += gotScrap;
    S.food  += gotFood;
    S.water += gotWater;

    addMomentum(1);

    const techChance = (S.techs.workshop ? 0.08 : 0.03) + Math.min(0.05, S.day*0.002);
    if (Math.random() < techChance) { S.tech += 1; log(`You found a pre‑war component. +1 TECH.`); }

    S.rad = clamp(S.rad + (Math.random() < 0.25 ? 0.2 : 0), 0, 100);
    popNearEl(srcEl || $("btnScavenge"), `+${gotScrap} Scrap${gotFood?` · +${gotFood} Food`:``}${gotWater?` · +${gotWater} Water`:``}`, "good");
        log(`Scavenged the ruins: +${gotScrap} Scrap, +${gotFood} Food${gotWater?`, +${gotWater} Water`:``}.`);
    incQuest("scavenge", 1);
  }

  function purify(srcEl=null){
    const p = purifyCost();
    if (S.scrap < p.scrap) { toast(`Need ${p.scrap} Scrap.`, "warn"); popNearEl(srcEl || $("btnPurify"), `Need ${p.scrap} Scrap`, "warn"); return; }
    S.scrap -= p.scrap;
    S.water += p.waterGain;
    popNearEl(srcEl || $("btnPurify"), `+${p.waterGain} Water`, "good");
    log(`Ran the purifier: -${p.scrap} Scrap, +${p.waterGain} Water.`);
  }

  function decontaminate(srcEl=null){
    const d = deconCost();
    if (S.water < d.water) { toast(`Need ${d.water} Water.`, "warn"); log(`Not enough Water to decontaminate.`, "warn"); return; }
    if (S.rad <= 0.1) { toast(`RAD already low.`, "warn"); log(`Radiation already low.`, "warn"); return; }
    S.water -= d.water;
    S.rad = clamp(S.rad - d.radDown, 0, 100);
    popNearEl(srcEl || $("btnHealRad"), `RAD -${d.radDown}%`, "good");
    log(`Decontamination complete: -${d.water} Water, RAD -${d.radDown}%.`, "warn");
  }

  function tradeScrap(srcEl=null){
    const tr = tradeCost();
    if (S.scrap < tr.scrap) { toast(`Need ${tr.scrap} Scrap.`, "warn"); log(`Not enough Scrap to trade.`, "warn"); return; }
    S.scrap -= tr.scrap;
    S.caps += tr.capsGain;
    popNearEl(srcEl || $("btnTrade"), `+${tr.capsGain} Caps`, "good");
    log(`Traded with a wandering merchant: -${tr.scrap} Scrap, +${tr.capsGain} Caps.`, "warn");
  }


  function recruit(srcEl=null){
    if (S.pop >= housingCap()) { toast(`No housing. Build Tin Shacks.`, "warn"); log(`No room. Build more housing (Tin Shacks).`, "warn"); return; }
    const c = recruitCost();
    const mod = S.techs.radio ? 0.82 : 1;
    const f = Math.floor(c.food*mod);
    const w = Math.floor(c.water*mod);
    if (S.food < f || S.water < w) { toast(`Need Food ${f} + Water ${w}.`, "warn"); return; }
    S.food -= f; S.water -= w;
    S.pop += 1; S.idle += 1;
    popNearEl(srcEl || $("btnRecruit"), `POP +1`, "good");
    log(`A drifter joined your outpost. POP +1.`);
    incQuest("recruit", 1);
  }

  function raid(srcEl=null){
    const plan = raidPlan();
    if (S.militia <= 0) { toast(`Assign Militia first.`, "warn"); log(`No militia. Assign settlers to Militia first.`, "warn"); return; }
    const raidFood = 3 + Math.floor(plan.threat);
    const raidWater = 2 + Math.floor(plan.threat*0.6);
    if (S.food < raidFood || S.water < raidWater) { log(`Not enough supplies to raid (need Food ${raidFood}, Water ${raidWater}).`, "warn"); return; }
    S.food -= raidFood; S.water -= raidWater;

    const roll = Math.random();
    const lootMult = (S.techs.radio ? 1.15 : 1) * (activeFactionBonus().loot || 1) * momentumMult();

    if (roll < plan.chance) {
      S.raidsWon += 1;
      addMomentum(1);
      const s = Math.floor(plan.lootScrap * lootMult);
      const f = Math.floor(plan.lootFood * lootMult);
      const c = Math.floor(plan.lootCaps * lootMult);
      S.scrap += s; S.food += f; S.caps += c;
      if (plan.lootTech) S.tech += 1;
      log(`Raid success. +${s} Scrap, +${f} Food, +${c} Caps${plan.lootTech?`, +1 Tech`:``}.`);
      incQuest("raid", 1);
      if (Math.random() < 0.25) S.rad = clamp(S.rad - 1.5, 0, 100);
    } else {
      const lossChance = clamp(0.25 + (plan.threat - defensePower())*0.10, 0.15, 0.75);
      if (Math.random() < lossChance && S.militia > 0) {
        S.militia -= 1; S.pop -= 1;
        popNearEl(srcEl || $("btnRaid"), `Lost a fighter`, "danger");
        log(`Raid failed. You lost a fighter. POP -1, Militia -1.`, "danger");
      } else {
        popNearEl(srcEl || $("btnRaid"), `Raid failed`, "danger");
        log(`Raid failed. You retreated with bruises and empty pockets.`, "danger");
      }
      S.rad = clamp(S.rad + 2.0, 0, 100);
    }
  }

  function assignWorker(key, delta) {
    if (delta > 0) { if (S.idle <= 0) return; S[key] += 1; S.idle -= 1; }
    else { if (S[key] <= 0) return; S[key] -= 1; S.idle += 1; }
  }

  function buyBuilding(key) {
    const costs = {
      shack: { scrap: 18 + S.shack*10, caps: (S.shack < 2 ? 0 : (6 + S.shack*3)) },
      farm: { scrap: 14 + S.farm*9, water: 6 + S.farm*3 },
      purifier: { scrap: 22 + S.purifier*12, tech: Math.floor(S.purifier*0.7) },
      turret: { scrap: 30 + S.turret*18, tech: 1 + Math.floor(S.turret*0.8), caps: 10 + S.turret*6 },
      annex: { scrap: 30 + S.annex*24, tech: 6 + S.annex*2 },
      cmdcenter: { scrap: 40 + S.cmdcenter*28, caps: 40 + S.cmdcenter*12, tech: 8 },
      hospital: { scrap: 48 + S.hospital*30, tech: 10 + S.hospital*3, water: 20 },
      blackmarket: { scrap: 70 + S.blackmarket*36, caps: 50 + S.blackmarket*20 },
      lab: { scrap: 60 + S.lab*36, tech: 20 + S.lab*4, caps: 30 },
      depot: { scrap: 55 + S.depot*32, caps: 24 + S.depot*8 },
    }[key];

    if (!costs) return;
    for (const [k,v] of Object.entries(costs)) if (S[k] < v) return;
    for (const [k,v] of Object.entries(costs)) S[k] -= v;
    S[key] += 1;

    const msgMap = {
      shack:"Built a Tin Shack. Housing increased.",
      farm:"Planted a Dust Farm. Food output improved.",
      purifier:"Installed a Water Purifier. Water output improved.",
      turret:"Mounted a Jury-Rigged Turret. Defense increased.",
      annex:"Constructed a Workshop Annex. Engineers can now be assigned.",
      cmdcenter:"Erected a Command Center. Issue directives and hire Propagandists.",
      hospital:"Built a Field Hospital. Medics can now be assigned.",
      blackmarket:"Set up a Black Market. Risky trades unlocked.",
      lab:"Established a Research Lab. Researchers can now discover breakthroughs.",
      depot:"Added a Logistics Depot. Storage and Fixers unlocked."
    };
    const msg = msgMap[key];
    if (msg) log(msg);
    incQuest("build", 1);
  }

  function buyTech(key) {
    const techDefs = {
      workshop: { tech: 6, scrap: 40, caps: 20, msg: "Workshop online. Scavengers can now salvage Tech more reliably." },
      radio: { tech: 10, scrap: 60, caps: 35, msg: "Radio Beacon broadcasting. Recruiting is cheaper; raids yield more." },
      medbay: { tech: 14, scrap: 80, water: 35, msg: "Field Medbay set up. Radiation rises slower." },
      caravan: { tech: 18, scrap: 90, food: 60, msg: "Caravan Route established. Caps now trickle in." },
    }[key];
    if (!techDefs || S.techs[key]) return;
    for (const [k,v] of Object.entries(techDefs)) { if (k==="msg") continue; if (S[k] < v) return; }
    for (const [k,v] of Object.entries(techDefs)) { if (k==="msg") continue; S[k] -= v; }
    S.techs[key] = true;
    log(techDefs.msg);
  }

  // ---------- Tick / simulation ----------
  let last = now();
  function tick() {
    // keep momentum and ensure expansion fields are present
    syncMomentum();
    ensureExpansion();
    const t = now();
    const dt = Math.min(1.0, (t - last) / 1000);
    last = t;

    const prod = productionPerSec();
    S.scrap += prod.scavRate * dt;
    S.food += prod.foodRate * dt;
    S.water += prod.waterRate * dt;
    S.tech += prod.techRate * dt;
    S.caps += prod.capsRate * dt;

    S.food -= prod.foodUse * dt;
    S.water -= prod.waterUse * dt;

    S.scrap = Math.max(0, S.scrap);
    S.food = Math.max(0, S.food);
    S.water = Math.max(0, S.water);
    S.tech = Math.max(0, S.tech);
    S.caps = Math.max(0, S.caps);

    S.rad = clamp(S.rad + prod.radGain * dt, 0, 100);

    // expansion: generate MED and BRK resources and adjust strain
    if (S.medics) {
      S.medData += S.medics * dt * 0.05;
    }
    if (S.researchers) {
      S.breakthroughs += S.researchers * dt * 0.02;
    }
    // Strain rises slowly when directives are active (e.g. when Command Center built) and falls with Fixers
    if (S.cmdcenter > 0) {
      S.strain += dt * 0.01;
    }
    if (S.fixers) {
      S.strain = Math.max(0, S.strain - dt * 0.05 * S.fixers);
    }
    // propagandists slowly add faction rep for the active sponsor
    if (S.propagandists && S.factions && S.factions.active) {
      const facId = S.factions.active;
      if (S.factions.rep && facId) {
        S.factions.rep[facId] = clamp((S.factions.rep[facId] || 0) + S.propagandists * dt * 0.02, 0, 100);
      }
    }

    if (S.rad > 75 && Math.random() < 0.0035 * dt * (S.rad - 74)) {
      const lossF = 2 + Math.floor(Math.random()*4);
      const lossW = 1 + Math.floor(Math.random()*3);
      S.food = Math.max(0, S.food - lossF);
      S.water = Math.max(0, S.water - lossW);
      log(`Radiation sickness flares. -${lossF} Food, -${lossW} Water.`, "warn");
    }

    const starving = (S.food <= 0.1);
    const thirsty = (S.water <= 0.1);
    if ((starving || thirsty) && Math.random() < 0.0025 * dt * (1 + S.pop*0.05)) {
      if (S.pop > 0) {
        S.pop -= 1;
        let removed = false;
        for (const k of ["militia","purifiers","farmers","scav"]) {
          if (S[k] > 0) { S[k] -= 1; removed = true; break; }
        }
        if (!removed) S.idle = Math.max(0, S.idle - 1);
        log(`A settler left due to ${thirsty ? "thirst" : "hunger"}. POP -1.`, "danger");
      }
    }

    S.day += dt * 0.02;

    // Contracts removed
    checkOps();

    if (Math.random() < 0.01) save();

    renderAll();
  }

  // ---------- Save/Load/Offline ----------
  function save() {
    S.t = now();
    localStorage.setItem(KEY, JSON.stringify(S));
    return true;
  }

  // ---------- Robust autosave (mobile-friendly) ----------
  let _dirty = false;
  let _saveTimer = null;

  function queueSave(){
    _dirty = true;
    if (_saveTimer) return;
    _saveTimer = setTimeout(() => flushSave(), 1500);
  }

  function flushSave(){
    if (_saveTimer){ clearTimeout(_saveTimer); _saveTimer = null; }
    if (!_dirty) return;
    try { save(); } catch {}
    _dirty = false;
  }

  // iOS Safari sometimes only persists storage after a user gesture
  document.addEventListener("pointerdown", () => {
    try { localStorage.setItem("bf_initialized", "1"); } catch {}
  }, { once:true });

  document.addEventListener("visibilitychange", () => {
    if (document.visibilityState === "hidden") flushSave();
  });
  window.addEventListener("pagehide", flushSave);
  window.addEventListener("beforeunload", flushSave);


  function migrateSave(data){
    if (!data || !data.version) return null;

    // v3 -> v5: add prestige/quests/factions/contract while keeping existing resources/buildings/etc.
    if (data.version === 3){
      const merged = structuredClone(DEFAULT);
      for (const k of Object.keys(merged)) {
        if (data[k] !== undefined) merged[k] = data[k];
      }
      // Ensure nested structures exist
      merged.factions = merged.factions || structuredClone(DEFAULT.factions);
      merged.factions.rep = Object.assign(structuredClone(DEFAULT.factions.rep), (data.factions && data.factions.rep) || {});
      merged.factions.rank = Object.assign(structuredClone(DEFAULT.factions.rank), (data.factions && data.factions.rank) || {});
      merged.factions.active = (data.factions && data.factions.active) || null;

      merged.contract = structuredClone(DEFAULT.contract);
      merged.version = 5;
      return merged;
    }

    // v4 -> v5: introduce contract loop
    if (data.version === 4){
      const merged = structuredClone(DEFAULT);
      for (const k of Object.keys(merged)) {
        if (data[k] !== undefined) merged[k] = data[k];
      }
      merged.factions = merged.factions || structuredClone(DEFAULT.factions);
      merged.factions.rep = Object.assign(structuredClone(DEFAULT.factions.rep), (data.factions && data.factions.rep) || {});
      merged.factions.rank = Object.assign(structuredClone(DEFAULT.factions.rank), (data.factions && data.factions.rank) || {});
      merged.factions.active = (data.factions && data.factions.active) || null;

      merged.contract = (data.contract) ? Object.assign(structuredClone(DEFAULT.contract), data.contract) : structuredClone(DEFAULT.contract);
      merged.version = 5;
      return merged;
    }

    // v5 -> v6: add battle operations state
    if (data.version === 5){
      const merged = structuredClone(DEFAULT);
      for (const k of Object.keys(merged)) {
        if (data[k] !== undefined) merged[k] = data[k];
      }
      merged.ops = (data.ops) ? Object.assign(structuredClone(DEFAULT.ops), data.ops) : structuredClone(DEFAULT.ops);
      merged.version = 6;
      return merged;
    }

    if (data.version === 6) return data;
    return null;

  }

  function load() {
    try {
      const candidates = [KEY, "wasteland_outpost_save_v3"];
      for (const k of candidates){
        const raw = localStorage.getItem(k);
        if (!raw) continue;
        const data = JSON.parse(raw);
        const migrated = migrateSave(data);
        if (!migrated) continue;
        // Write into the new key so future loads are fast
        localStorage.setItem(KEY, JSON.stringify(migrated));
        return migrated;
      }
      return null;
    } catch { return null; }
  }

  function applyOfflineProgress() {
    const t0 = S.t || now();
    const elapsed = clamp((now() - t0) / 1000, 0, 60 * 60 * 4);
    if (elapsed < 2) return;

    const steps = 120;
    const dt = elapsed / steps;
    for (let i=0;i<steps;i++){
      const prod = productionPerSec();
      S.scrap += prod.scavRate * dt;
      S.food += prod.foodRate * dt;
      S.water += prod.waterRate * dt;
      S.tech += prod.techRate * dt;
      S.caps += prod.capsRate * dt;
      S.food -= prod.foodUse * dt;
      S.water -= prod.waterUse * dt;
      S.scrap = Math.max(0,S.scrap);
      S.food = Math.max(0,S.food);
      S.water = Math.max(0,S.water);
      S.tech = Math.max(0,S.tech);
      S.caps = Math.max(0,S.caps);
      S.rad = clamp(S.rad + productionPerSec().radGain * dt, 0, 100);
      S.day += dt * 0.02;
    }

    log(`You were away for ${Math.floor(elapsed/60)}m. The outpost kept running.`, "warn");
    // Contracts removed
    checkOps();
  }

  // ---------- Event wiring ----------
  bindTap($("btnScavenge"), (e) => { flashBtn(e.currentTarget); haptic(8); scavengeTap(e.currentTarget); renderAll(); });
  bindTap($("btnPurify"), (e) => { flashBtn(e.currentTarget); haptic(8); purify(e.currentTarget); renderAll(); });
  bindTap($("btnRecruit"), (e) => { flashBtn(e.currentTarget); haptic(8); recruit(e.currentTarget); renderAll(); });
  bindTap($("btnHealRad"), (e) => { flashBtn(e.currentTarget); haptic(8); decontaminate(e.currentTarget); renderAll(); });
  bindTap($("btnTrade"), (e) => { flashBtn(e.currentTarget); haptic(8); tradeScrap(e.currentTarget); renderAll(); });

  // Battle: Campaign Paths wiring removed (replaced by Automated Raids UI)

$("workerPanel").addEventListener("click", (e) => {
    const btn = e.target.closest("button");
    if (!btn) return;

    // Switch Economy/War view
    const tab = btn.dataset.workersTab;
    if (tab) {
      S.workersTab = tab;
      renderAll();
      queueSave();
      return;
    }

    const key = btn.dataset.key;
    const act = btn.dataset.act;
    if (!key || !act) return;
    assignWorker(key, act === "plus" ? +1 : -1);
    renderAll();
  
    queueSave();
});

  $("buildPanel").addEventListener("click", (e) => {
    const btn = e.target.closest("button");
    if (!btn) return;
    const key = btn.dataset.buy;
    if (!key) return;
    buyBuilding(key);
    renderAll();
  
    queueSave();
});

  $("techPanel").addEventListener("click", (e) => {
    const btn = e.target.closest("button");
    if (!btn) return;
    const key = btn.dataset.tech;
    if (!key) return;
    buyTech(key);
    renderAll();
  
    queueSave();
});

$("factionSummary").addEventListener("click", (e) => {
  const btn = e.target.closest("button");
  if (!btn) return;
  const act = btn.dataset.factAct;
  if (!act) return;

  const id = btn.dataset.factId;
  if (!id) return;

  if (act === "pick") {
    // Toggle expand/collapse when tapping the same faction again
    S.factions.uiSelected = (S.factions.uiSelected === id) ? null : id;
    renderAll();
    queueSave();
    return;
  }
  if (act === "donate") donateToFaction(id);
  if (act === "ally") sponsorFaction(id);
  if (act === "leave") clearActiveFaction();
  if (act === "shop") openFactionShop(id);

  renderAll();
  queueSave();
});

  
$("factionPanel").addEventListener("click", (e) => {
  const btn = e.target.closest("button");
  if (!btn) return;
  const id = btn.dataset.factId;
  const act = btn.dataset.factAct;
  if (!id || !act) return;

  if (act === "pick") {
    // Toggle expand/collapse when tapping the same faction again
    S.factions.uiSelected = (S.factions.uiSelected === id) ? null : id;
    renderAll();
    queueSave();
    return;
  }
  if (act === "donate") donateToFaction(id);
  if (act === "ally") sponsorFaction(id);
  if (act === "leave") clearActiveFaction();
  if (act === "shop") openFactionShop(id);


  renderAll();
  queueSave();
});




  // ---------- Menu modal (save/export/import/reset/help) ----------
  const modal = $("modal");
  $("modalClose").addEventListener("click", () => closeModal());
  $("btnMenu").addEventListener("click", () => openMenu());

  function openMenu(){
    showModal("Menu", `
      <div class="rows" style="gap:12px;">
        <button class="btn" id="mSave">
          <div class="left"><div class="name">Save</div><div class="desc">Write progress to this device</div></div>
          <small>Local</small>
        </button>
        <button class="btn" id="mExport">
          <div class="left"><div class="name">Export Save</div><div class="desc">Copy a save string</div></div>
          <small>Clipboard</small>
        </button>
        <button class="btn" id="mImport">
          <div class="left"><div class="name">Import Save</div><div class="desc">Paste a save string</div></div>
          <small>Restore</small>
        </button>
        <button class="btn" id="mReset">
          <div class="left"><div class="name">Reset</div><div class="desc">Start over</div></div>
          <small style="color:var(--danger);">Wipes</small>
        </button>
        <button class="btn" id="mHelp">
          <div class="left"><div class="name">Help</div><div class="desc">How to play</div></div>
          <small>Tips</small>
        </button>

        <button class="btn" id="mPrestige">
          <div class="left"><div class="name">Wasteland Reset (Prestige)</div><div class="desc">Reset for permanent bonuses</div></div>
          <small>Lv ${S.prestige?.level||0}</small>
        </button>
      </div>
    `);

    setTimeout(() => {
      $("mSave").onclick = () => { save(); log("Saved.", "warn"); closeModal(); };
      $("mExport").onclick = () => exportSave();
      $("mImport").onclick = () => importSave();
      $("mReset").onclick = () => confirmReset();
      $("mHelp").onclick = () => showHelp();
      $("mPrestige").onclick = () => showPrestige();
    }, 0);
  }

  async function exportSave(){
    save();
    const raw = localStorage.getItem(KEY) || "";
    try {
      await navigator.clipboard.writeText(raw);
      log("Export copied to clipboard.", "warn");
      closeModal();
    } catch {
      showModal("Export Save", `<p>Copy this save string:</p><p><span class="kbd" style="display:block; white-space:pre-wrap; word-break:break-all; padding:12px;">${escapeHtml(raw)}</span></p>`);
    }
  }

  function importSave(){
    showModal("Import Save", `
      <p>Paste a save string below and press <span class="kbd">Import</span>.</p>
      <textarea id="importBox" style="width:100%; min-height:160px; border-radius:16px; border:1px solid rgba(31,58,42,.85); background:rgba(0,0,0,.25); color:var(--text); padding:12px; font-family:var(--mono); font-size:0.82rem;"></textarea>
      <div style="display:flex; gap:12px; margin-top:12px; flex-wrap:wrap;">
        <button class="tab" id="doImport" style="justify-content:center;">Import</button>
        <button class="tab" id="cancelImport" style="justify-content:center;">Cancel</button>
      </div>
    `);
    setTimeout(() => {
      $("doImport").onclick = () => {
        const txt = $("importBox").value.trim();
        try{
          const data = JSON.parse(txt);
          const migrated = migrateSave(data);
          if (!migrated) throw new Error("Bad save");
          S = migrated;
          save();
          log("Imported save.", "warn");
          closeModal();
          renderAll();
        } catch {
          log("Import failed (invalid save).", "danger");
        }
      };
      $("cancelImport").onclick = () => closeModal();
    }, 0);
  }

  function confirmReset(){
    showModal("Reset Game", `
      <p>This will wipe your current outpost. This can't be undone.</p>
      <div style="display:flex; gap:12px; margin-top:12px; flex-wrap:wrap;">
        <button class="tab" id="doReset" style="justify-content:center; border-color: rgba(255,107,107,.55);">Reset</button>
        <button class="tab" id="cancelReset" style="justify-content:center;">Cancel</button>
      </div>
    `);
    setTimeout(() => {
      $("doReset").onclick = () => {
        S = structuredClone(DEFAULT);
        save();
        // clear log area
        const el = $("log"); if (el) el.innerHTML = "";
        log("Reset complete.", "warn");
        closeModal();
        renderAll();
        showScreen("clicker");
      };
      $("cancelReset").onclick = () => closeModal();
    }, 0);
  }


  function showPrestige(){
    const ready = canPrestige();
    const est = prestigeGainEstimate();
    const lvl = S.prestige?.level || 0;
    const tok = S.prestige?.tokens || 0;
    const b = prestigeBonus();
    showModal("Wasteland Reset (Prestige)", `
      <p><b>Prestige Level:</b> ${lvl} · <b>Tokens:</b> ${tok}</p>
      <p><b>Current bonuses:</b> +${Math.round((b.prod-1)*100)}% production, +${Math.round((b.caps-1)*100)}% caps, lower radiation gain.</p>
      <p><b>Reset requirement:</b> POP ≥ 25, or Raids Won ≥ 12, or TECH ≥ 50.</p>
      <p><b>You would gain:</b> ~${est} tokens.</p>
      <button class="btn" id="doPrestigeNow" ${ready ? "" : "disabled"}>
        <div class="left"><div class="name">Reset Now</div><div class="desc">${ready ? "Start a new run with bonuses" : "Not ready yet"}</div></div>
        <small>${ready ? "GO" : "LOCKED"}</small>
      </button>
    `);
    setTimeout(() => {
      const b = document.getElementById("doPrestigeNow");
      if (b) b.onclick = () => { doPrestige(); closeModal(); };
    }, 0);
  }

  function showHelp(){
    showModal("How to Play", `
      <p><b>Resources</b>: tap <span class="kbd">Scavenge</span>, then assign settlers to automate.</p>
      <p><b>Build</b>: Shacks raise housing, Farms & Purifiers raise production, Turrets raise defense.</p>
      <p><b>Battle</b>: run time-based operations (Patrol/Raid/Assault). Choose a squad size; militia sent out won’t defend until they return.</p>
      <p><b>Radiation</b>: grows with time/pop. Use <span class="kbd">Decontaminate</span> (stronger with Medbay).</p>
      <p><b>Tip</b>: Early game is usually Water‑limited—build a Purifier and assign Purifier Crew.</p>
    `);
  }

  function showModal(title, html) {
    $("modalTitle").textContent = title;
    $("modalBody").innerHTML = html;
    modal.showModal();
  }


$("battlePanel").addEventListener("click", (e) => {
  const btn = e.target.closest("button");
  if (!btn) return;
  const act = btn.dataset.bact;
  if (!act) return;

  if (act === "unlock") unlockCombat();

  if (act === "inc") recruitUnit(btn.dataset.unit, +1);
  if (act === "dec") recruitUnit(btn.dataset.unit, -1);

  // Adjust militia via plus/minus buttons. Uses assignWorker to shift settlers
  // between idle and militia pools. Only modifies counts when possible.
  if (act === "militia-inc") {
    assignWorker('militia', +1);
    renderAll(); queueSave();
  }
  if (act === "militia-dec") {
    assignWorker('militia', -1);
    renderAll(); queueSave();
  }

  if (act === "find") { rollRaidTarget(); renderAll(); queueSave(); }
  if (act === "reroll") { rollRaidTarget(); renderAll(); queueSave(); }

  if (act === "toggleHistory") {
    S.uiBattleShowHistory = !S.uiBattleShowHistory;
    renderAll(); queueSave();
  }

  if (act === "raid") simulateRaid();
});

  // Outcome popup (shown after the sim finishes)
  function showBattleOutcomePopup({ pathKey, tier, def, mil, fac, res }){
    const title = res.win ? "Outcome — SUCCESS" : "Outcome — FAILED";

    const yourAfter = {
      mil: Math.max(0, (mil|0) - (res.milLost|0)),
      fac: Math.max(0, (fac|0) - (res.facLost|0))
    };

    const lossLine = (res.milLost||0) || (res.facLost||0)
      ? `<div class="row"><div class="label">Losses</div><div class="value">-${res.milLost||0} militia${(res.facLost||0)?` · -${res.facLost||0} faction unit(s)`:``} <span class="tag">Permanent</span></div></div>`
      : `<div class="row"><div class="label">Losses</div><div class="value">None <span class="tag">Clean win</span></div></div>`;

    const rewardPairs = Object.entries(res.reward || {})
      .filter(([k,v]) => k !== "rep" && v)
      .map(([k,v]) => `+${v} ${k.toUpperCase()}`);

    const rewardLine = res.win
      ? `<div class="row"><div class="label">Rewards</div><div class="value">${rewardPairs.length ? rewardPairs.join(" · ") : "None"} <span class="tag">Loot</span></div></div>`
      : `<div class="row"><div class="label">Rewards</div><div class="value">None <span class="tag">Retreat</span></div></div>`;

    const repGain = res.win ? ((res.reward && res.reward.rep) ? res.reward.rep : 1) : 0;
    const repLine = (res.win && repGain)
      ? `<div class="row"><div class="label">Reputation</div><div class="value">+${repGain} REP <span class="tag">If aligned</span></div></div>`
      : ``;

    const youBefore = totalUnitStats(mil|0, fac|0);
    const youAfterStats = totalUnitStats(yourAfter.mil, yourAfter.fac);

    showModal(title, `
      <div class="rows">
        <div class="row"><div class="label">Mission</div><div class="value">${escapeHtml(PATHS[pathKey]?.name || "Path")} · Tier ${tier}: ${escapeHtml(def?.name || "")}</div></div>
        <div class="row"><div class="label">Your Force</div><div class="value">${statChipsHTML(youBefore.atk, youBefore.def, youBefore.hp)} <span class="tag">Deployed</span></div></div>
        <div class="row"><div class="label">Enemy Force</div><div class="value">${statChipsHTML((def?.enemy?.atk)||0, (def?.enemy?.def)||0, (def?.enemy?.hp)||0)} <span class="tag">Opposition</span></div></div>
        <div class="row"><div class="label">Aftermath</div><div class="value">${statChipsHTML(youAfterStats.atk, youAfterStats.def, youAfterStats.hp)} <span class="tag">Survivors</span></div></div>
        ${lossLine}
        ${rewardLine}
        ${repLine}
      </div>

      <div style="display:flex; gap:12px; margin-top:12px; flex-wrap:wrap;">
        <button class="btn" id="outcomeContinue">
          <div class="left"><div class="name">Continue</div><div class="desc">Back to Battle Paths</div></div>
          <small>OK</small>
        </button>
      </div>
    `);

    setTimeout(() => {
      const b = $("outcomeContinue");
      if (b) b.onclick = () => { closeModal(); };
    }, 0);
  }
  function closeModal() { if (modal.open) modal.close(); }
  function escapeHtml(s){
    return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }

  // ---------- Init ----------
  ensureQuest();
  ensureFactions();
  ensureContract();
  applyOfflineProgress();
  renderAll();
  log("Outpost initialized. The wasteland waits…");
  log("Early tip: Use Trade Scrap to get Caps for your first Tin Shacks (housing) and Turrets.", "warn");
  log("New: Daily Quest & Prestige! Check Log for quest progress; use Menu → Wasteland Reset when you qualify.", "warn");
  log("New: Factions tab — donate supplies (scaled costs), build REP, align permanently at 50, then spend faction tokens in the shop.", "warn");
  setInterval(tick, 250);

})();</script>

  <script>
    // --- Ads integration hooks (safe no-op in browser) ---
    // Mobile wrappers (Cordova/Capacitor/Android WebView/iOS WKWebView) can override these.
    window.Ads = window.Ads || {};
    (function(){
      const slots = {
        top: document.getElementById('adBannerTop'),
        bottom: document.getElementById('adBannerBottom'),
        nativeBattle: document.getElementById('adNativeBattle')
      };

      function setSlotVisible(el, on){
        if(!el) return;
        el.style.display = on ? 'flex' : 'none';
      }

      // Banner helpers
      window.Ads.showBanner = function(position='bottom'){
        if(position === 'top'){ setSlotVisible(slots.top, true); setSlotVisible(slots.bottom, false); }
        else { setSlotVisible(slots.bottom, true); setSlotVisible(slots.top, false); }
        document.dispatchEvent(new CustomEvent('ads:banner:show', {detail:{position}}));
      };
      window.Ads.hideBanner = function(){
        setSlotVisible(slots.top, false);
        setSlotVisible(slots.bottom, false);
        document.dispatchEvent(new CustomEvent('ads:banner:hide'));
      };

      // Interstitial / Rewarded: call into native if available, otherwise simulate.
      // Your native layer can listen for these events and then call Ads._onInterstitialClosed(), etc.
      window.Ads.showInterstitial = function(placement='generic'){
        document.dispatchEvent(new CustomEvent('ads:interstitial:request', {detail:{placement}}));
        // Web fallback: instantly close (no-op)
        window.setTimeout(()=>window.Ads._onInterstitialClosed(placement), 50);
      };
      window.Ads.showRewarded = function(placement='reward'){
        document.dispatchEvent(new CustomEvent('ads:rewarded:request', {detail:{placement}}));
        // Web fallback: instantly grant
        window.setTimeout(()=>window.Ads._onRewarded(placement, true), 50);
      };

      // Callbacks for native layer
      window.Ads._onInterstitialClosed = function(placement){
        document.dispatchEvent(new CustomEvent('ads:interstitial:closed', {detail:{placement}}));
      };
      window.Ads._onRewarded = function(placement, granted){
        document.dispatchEvent(new CustomEvent('ads:rewarded:closed', {detail:{placement, granted: !!granted}}));
      };

      // Default behavior in-browser: show bottom banner placeholder
      window.Ads.showBanner('bottom');
    })();
  </script>

</body>
</html>
